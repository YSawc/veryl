// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

// Disable clippy warnings that can result in the way how parol generates code.
#![allow(clippy::enum_variant_names)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::upper_case_acronyms)]

use parol_runtime::derive_builder::Builder;
use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::parol_macros::{pop_and_reverse_item, pop_item};
use parol_runtime::parser::{ParseTreeType, UserActionsTrait};
use parol_runtime::{ParserError, Result};
use std::marker::PhantomData;

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait VerylGrammarTrait {
    /// Semantic action for non-terminal 'CommentsTerm'
    fn comments_term(&mut self, _arg: &CommentsTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StringLiteralTerm'
    fn string_literal_term(&mut self, _arg: &StringLiteralTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ExponentTerm'
    fn exponent_term(&mut self, _arg: &ExponentTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FixedPointTerm'
    fn fixed_point_term(&mut self, _arg: &FixedPointTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BasedTerm'
    fn based_term(&mut self, _arg: &BasedTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AllBitTerm'
    fn all_bit_term(&mut self, _arg: &AllBitTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BaseLessTerm'
    fn base_less_term(&mut self, _arg: &BaseLessTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MinusColonTerm'
    fn minus_colon_term(&mut self, _arg: &MinusColonTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MinusGTTerm'
    fn minus_g_t_term(&mut self, _arg: &MinusGTTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PlusColonTerm'
    fn plus_colon_term(&mut self, _arg: &PlusColonTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AssignmentOperatorTerm'
    fn assignment_operator_term(&mut self, _arg: &AssignmentOperatorTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator11Term'
    fn operator11_term(&mut self, _arg: &Operator11Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator10Term'
    fn operator10_term(&mut self, _arg: &Operator10Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator09Term'
    fn operator09_term(&mut self, _arg: &Operator09Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator08Term'
    fn operator08_term(&mut self, _arg: &Operator08Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator07Term'
    fn operator07_term(&mut self, _arg: &Operator07Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator06Term'
    fn operator06_term(&mut self, _arg: &Operator06Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator02Term'
    fn operator02_term(&mut self, _arg: &Operator02Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator01Term'
    fn operator01_term(&mut self, _arg: &Operator01Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator05Term'
    fn operator05_term(&mut self, _arg: &Operator05Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator04Term'
    fn operator04_term(&mut self, _arg: &Operator04Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator03Term'
    fn operator03_term(&mut self, _arg: &Operator03Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'UnaryOperatorTerm'
    fn unary_operator_term(&mut self, _arg: &UnaryOperatorTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ColonColonTerm'
    fn colon_colon_term(&mut self, _arg: &ColonColonTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ColonTerm'
    fn colon_term(&mut self, _arg: &ColonTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CommaTerm'
    fn comma_term(&mut self, _arg: &CommaTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DollarTerm'
    fn dollar_term(&mut self, _arg: &DollarTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DotDotEquTerm'
    fn dot_dot_equ_term(&mut self, _arg: &DotDotEquTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DotDotTerm'
    fn dot_dot_term(&mut self, _arg: &DotDotTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DotTerm'
    fn dot_term(&mut self, _arg: &DotTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EquTerm'
    fn equ_term(&mut self, _arg: &EquTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'HashTerm'
    fn hash_term(&mut self, _arg: &HashTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LAngleTerm'
    fn l_angle_term(&mut self, _arg: &LAngleTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LBraceTerm'
    fn l_brace_term(&mut self, _arg: &LBraceTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LBracketTerm'
    fn l_bracket_term(&mut self, _arg: &LBracketTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LParenTerm'
    fn l_paren_term(&mut self, _arg: &LParenTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RAngleTerm'
    fn r_angle_term(&mut self, _arg: &RAngleTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RBraceTerm'
    fn r_brace_term(&mut self, _arg: &RBraceTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RBracketTerm'
    fn r_bracket_term(&mut self, _arg: &RBracketTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RParenTerm'
    fn r_paren_term(&mut self, _arg: &RParenTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SemicolonTerm'
    fn semicolon_term(&mut self, _arg: &SemicolonTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StarTerm'
    fn star_term(&mut self, _arg: &StarTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysCombTerm'
    fn always_comb_term(&mut self, _arg: &AlwaysCombTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysFfTerm'
    fn always_ff_term(&mut self, _arg: &AlwaysFfTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AssignTerm'
    fn assign_term(&mut self, _arg: &AssignTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AsyncHighTerm'
    fn async_high_term(&mut self, _arg: &AsyncHighTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AsyncLowTerm'
    fn async_low_term(&mut self, _arg: &AsyncLowTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AsTerm'
    fn as_term(&mut self, _arg: &AsTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BitTerm'
    fn bit_term(&mut self, _arg: &BitTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CaseTerm'
    fn case_term(&mut self, _arg: &CaseTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DefaultTerm'
    fn default_term(&mut self, _arg: &DefaultTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ElseTerm'
    fn else_term(&mut self, _arg: &ElseTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EnumTerm'
    fn enum_term(&mut self, _arg: &EnumTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ExportTerm'
    fn export_term(&mut self, _arg: &ExportTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'F32Term'
    fn f32_term(&mut self, _arg: &F32Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'F64Term'
    fn f64_term(&mut self, _arg: &F64Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FinalTerm'
    fn final_term(&mut self, _arg: &FinalTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ForTerm'
    fn for_term(&mut self, _arg: &ForTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FunctionTerm'
    fn function_term(&mut self, _arg: &FunctionTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'I32Term'
    fn i32_term(&mut self, _arg: &I32Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'I64Term'
    fn i64_term(&mut self, _arg: &I64Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IfResetTerm'
    fn if_reset_term(&mut self, _arg: &IfResetTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IfTerm'
    fn if_term(&mut self, _arg: &IfTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ImportTerm'
    fn import_term(&mut self, _arg: &ImportTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InitialTerm'
    fn initial_term(&mut self, _arg: &InitialTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InoutTerm'
    fn inout_term(&mut self, _arg: &InoutTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InputTerm'
    fn input_term(&mut self, _arg: &InputTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InsideTerm'
    fn inside_term(&mut self, _arg: &InsideTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InstTerm'
    fn inst_term(&mut self, _arg: &InstTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InterfaceTerm'
    fn interface_term(&mut self, _arg: &InterfaceTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InTerm'
    fn in_term(&mut self, _arg: &InTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LocalparamTerm'
    fn localparam_term(&mut self, _arg: &LocalparamTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LogicTerm'
    fn logic_term(&mut self, _arg: &LogicTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LsbTerm'
    fn lsb_term(&mut self, _arg: &LsbTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModportTerm'
    fn modport_term(&mut self, _arg: &ModportTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModuleTerm'
    fn module_term(&mut self, _arg: &ModuleTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MsbTerm'
    fn msb_term(&mut self, _arg: &MsbTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'NegedgeTerm'
    fn negedge_term(&mut self, _arg: &NegedgeTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OutputTerm'
    fn output_term(&mut self, _arg: &OutputTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OutsideTerm'
    fn outside_term(&mut self, _arg: &OutsideTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PackageTerm'
    fn package_term(&mut self, _arg: &PackageTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ParameterTerm'
    fn parameter_term(&mut self, _arg: &ParameterTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PosedgeTerm'
    fn posedge_term(&mut self, _arg: &PosedgeTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RefTerm'
    fn ref_term(&mut self, _arg: &RefTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RepeatTerm'
    fn repeat_term(&mut self, _arg: &RepeatTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ReturnTerm'
    fn return_term(&mut self, _arg: &ReturnTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SignedTerm'
    fn signed_term(&mut self, _arg: &SignedTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StepTerm'
    fn step_term(&mut self, _arg: &StepTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StringTerm'
    fn string_term(&mut self, _arg: &StringTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StructTerm'
    fn struct_term(&mut self, _arg: &StructTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SyncHighTerm'
    fn sync_high_term(&mut self, _arg: &SyncHighTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SyncLowTerm'
    fn sync_low_term(&mut self, _arg: &SyncLowTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TriTerm'
    fn tri_term(&mut self, _arg: &TriTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TypeTerm'
    fn type_term(&mut self, _arg: &TypeTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'U32Term'
    fn u32_term(&mut self, _arg: &U32Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'U64Term'
    fn u64_term(&mut self, _arg: &U64Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'VarTerm'
    fn var_term(&mut self, _arg: &VarTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IdentifierTerm'
    fn identifier_term(&mut self, _arg: &IdentifierTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Comments'
    fn comments(&mut self, _arg: &Comments) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StartToken'
    fn start_token(&mut self, _arg: &StartToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StringLiteralToken'
    fn string_literal_token(&mut self, _arg: &StringLiteralToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ExponentToken'
    fn exponent_token(&mut self, _arg: &ExponentToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FixedPointToken'
    fn fixed_point_token(&mut self, _arg: &FixedPointToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BasedToken'
    fn based_token(&mut self, _arg: &BasedToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BaseLessToken'
    fn base_less_token(&mut self, _arg: &BaseLessToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AllBitToken'
    fn all_bit_token(&mut self, _arg: &AllBitToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AssignmentOperatorToken'
    fn assignment_operator_token(&mut self, _arg: &AssignmentOperatorToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator01Token'
    fn operator01_token(&mut self, _arg: &Operator01Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator02Token'
    fn operator02_token(&mut self, _arg: &Operator02Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator03Token'
    fn operator03_token(&mut self, _arg: &Operator03Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator04Token'
    fn operator04_token(&mut self, _arg: &Operator04Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator05Token'
    fn operator05_token(&mut self, _arg: &Operator05Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator06Token'
    fn operator06_token(&mut self, _arg: &Operator06Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator07Token'
    fn operator07_token(&mut self, _arg: &Operator07Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator08Token'
    fn operator08_token(&mut self, _arg: &Operator08Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator09Token'
    fn operator09_token(&mut self, _arg: &Operator09Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator10Token'
    fn operator10_token(&mut self, _arg: &Operator10Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator11Token'
    fn operator11_token(&mut self, _arg: &Operator11Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'UnaryOperatorToken'
    fn unary_operator_token(&mut self, _arg: &UnaryOperatorToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ColonToken'
    fn colon_token(&mut self, _arg: &ColonToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ColonColonToken'
    fn colon_colon_token(&mut self, _arg: &ColonColonToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CommaToken'
    fn comma_token(&mut self, _arg: &CommaToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DollarToken'
    fn dollar_token(&mut self, _arg: &DollarToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DotDotToken'
    fn dot_dot_token(&mut self, _arg: &DotDotToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DotDotEquToken'
    fn dot_dot_equ_token(&mut self, _arg: &DotDotEquToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DotToken'
    fn dot_token(&mut self, _arg: &DotToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EquToken'
    fn equ_token(&mut self, _arg: &EquToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'HashToken'
    fn hash_token(&mut self, _arg: &HashToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LAngleToken'
    fn l_angle_token(&mut self, _arg: &LAngleToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LBraceToken'
    fn l_brace_token(&mut self, _arg: &LBraceToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LBracketToken'
    fn l_bracket_token(&mut self, _arg: &LBracketToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LParenToken'
    fn l_paren_token(&mut self, _arg: &LParenToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MinusColonToken'
    fn minus_colon_token(&mut self, _arg: &MinusColonToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MinusGTToken'
    fn minus_g_t_token(&mut self, _arg: &MinusGTToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PlusColonToken'
    fn plus_colon_token(&mut self, _arg: &PlusColonToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RAngleToken'
    fn r_angle_token(&mut self, _arg: &RAngleToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RBraceToken'
    fn r_brace_token(&mut self, _arg: &RBraceToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RBracketToken'
    fn r_bracket_token(&mut self, _arg: &RBracketToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RParenToken'
    fn r_paren_token(&mut self, _arg: &RParenToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SemicolonToken'
    fn semicolon_token(&mut self, _arg: &SemicolonToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StarToken'
    fn star_token(&mut self, _arg: &StarToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysCombToken'
    fn always_comb_token(&mut self, _arg: &AlwaysCombToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysFfToken'
    fn always_ff_token(&mut self, _arg: &AlwaysFfToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AsToken'
    fn as_token(&mut self, _arg: &AsToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AssignToken'
    fn assign_token(&mut self, _arg: &AssignToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AsyncHighToken'
    fn async_high_token(&mut self, _arg: &AsyncHighToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AsyncLowToken'
    fn async_low_token(&mut self, _arg: &AsyncLowToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BitToken'
    fn bit_token(&mut self, _arg: &BitToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CaseToken'
    fn case_token(&mut self, _arg: &CaseToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DefaultToken'
    fn default_token(&mut self, _arg: &DefaultToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ElseToken'
    fn else_token(&mut self, _arg: &ElseToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EnumToken'
    fn enum_token(&mut self, _arg: &EnumToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ExportToken'
    fn export_token(&mut self, _arg: &ExportToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'F32Token'
    fn f32_token(&mut self, _arg: &F32Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'F64Token'
    fn f64_token(&mut self, _arg: &F64Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FinalToken'
    fn final_token(&mut self, _arg: &FinalToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ForToken'
    fn for_token(&mut self, _arg: &ForToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FunctionToken'
    fn function_token(&mut self, _arg: &FunctionToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'I32Token'
    fn i32_token(&mut self, _arg: &I32Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'I64Token'
    fn i64_token(&mut self, _arg: &I64Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IfResetToken'
    fn if_reset_token(&mut self, _arg: &IfResetToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IfToken'
    fn if_token(&mut self, _arg: &IfToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ImportToken'
    fn import_token(&mut self, _arg: &ImportToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InitialToken'
    fn initial_token(&mut self, _arg: &InitialToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InoutToken'
    fn inout_token(&mut self, _arg: &InoutToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InputToken'
    fn input_token(&mut self, _arg: &InputToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InsideToken'
    fn inside_token(&mut self, _arg: &InsideToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InstToken'
    fn inst_token(&mut self, _arg: &InstToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InterfaceToken'
    fn interface_token(&mut self, _arg: &InterfaceToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InToken'
    fn in_token(&mut self, _arg: &InToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LocalparamToken'
    fn localparam_token(&mut self, _arg: &LocalparamToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LogicToken'
    fn logic_token(&mut self, _arg: &LogicToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LsbToken'
    fn lsb_token(&mut self, _arg: &LsbToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModportToken'
    fn modport_token(&mut self, _arg: &ModportToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModuleToken'
    fn module_token(&mut self, _arg: &ModuleToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MsbToken'
    fn msb_token(&mut self, _arg: &MsbToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'NegedgeToken'
    fn negedge_token(&mut self, _arg: &NegedgeToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OutputToken'
    fn output_token(&mut self, _arg: &OutputToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OutsideToken'
    fn outside_token(&mut self, _arg: &OutsideToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PackageToken'
    fn package_token(&mut self, _arg: &PackageToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ParameterToken'
    fn parameter_token(&mut self, _arg: &ParameterToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PosedgeToken'
    fn posedge_token(&mut self, _arg: &PosedgeToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RefToken'
    fn ref_token(&mut self, _arg: &RefToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RepeatToken'
    fn repeat_token(&mut self, _arg: &RepeatToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ReturnToken'
    fn return_token(&mut self, _arg: &ReturnToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SignedToken'
    fn signed_token(&mut self, _arg: &SignedToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StepToken'
    fn step_token(&mut self, _arg: &StepToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StringToken'
    fn string_token(&mut self, _arg: &StringToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StructToken'
    fn struct_token(&mut self, _arg: &StructToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SyncHighToken'
    fn sync_high_token(&mut self, _arg: &SyncHighToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SyncLowToken'
    fn sync_low_token(&mut self, _arg: &SyncLowToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TriToken'
    fn tri_token(&mut self, _arg: &TriToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TypeToken'
    fn type_token(&mut self, _arg: &TypeToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'U32Token'
    fn u32_token(&mut self, _arg: &U32Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'U64Token'
    fn u64_token(&mut self, _arg: &U64Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'VarToken'
    fn var_token(&mut self, _arg: &VarToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IdentifierToken'
    fn identifier_token(&mut self, _arg: &IdentifierToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Start'
    fn start(&mut self, _arg: &Start) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StringLiteral'
    fn string_literal(&mut self, _arg: &StringLiteral) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Exponent'
    fn exponent(&mut self, _arg: &Exponent) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FixedPoint'
    fn fixed_point(&mut self, _arg: &FixedPoint) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Based'
    fn based(&mut self, _arg: &Based) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BaseLess'
    fn base_less(&mut self, _arg: &BaseLess) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AllBit'
    fn all_bit(&mut self, _arg: &AllBit) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AssignmentOperator'
    fn assignment_operator(&mut self, _arg: &AssignmentOperator) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator01'
    fn operator01(&mut self, _arg: &Operator01) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator02'
    fn operator02(&mut self, _arg: &Operator02) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator03'
    fn operator03(&mut self, _arg: &Operator03) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator04'
    fn operator04(&mut self, _arg: &Operator04) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator05'
    fn operator05(&mut self, _arg: &Operator05) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator06'
    fn operator06(&mut self, _arg: &Operator06) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator07'
    fn operator07(&mut self, _arg: &Operator07) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator08'
    fn operator08(&mut self, _arg: &Operator08) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator09'
    fn operator09(&mut self, _arg: &Operator09) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator10'
    fn operator10(&mut self, _arg: &Operator10) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator11'
    fn operator11(&mut self, _arg: &Operator11) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'UnaryOperator'
    fn unary_operator(&mut self, _arg: &UnaryOperator) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Colon'
    fn colon(&mut self, _arg: &Colon) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ColonColon'
    fn colon_colon(&mut self, _arg: &ColonColon) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Comma'
    fn comma(&mut self, _arg: &Comma) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Dollar'
    fn dollar(&mut self, _arg: &Dollar) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DotDot'
    fn dot_dot(&mut self, _arg: &DotDot) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DotDotEqu'
    fn dot_dot_equ(&mut self, _arg: &DotDotEqu) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Dot'
    fn dot(&mut self, _arg: &Dot) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Equ'
    fn equ(&mut self, _arg: &Equ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Hash'
    fn hash(&mut self, _arg: &Hash) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LAngle'
    fn l_angle(&mut self, _arg: &LAngle) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LBrace'
    fn l_brace(&mut self, _arg: &LBrace) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LBracket'
    fn l_bracket(&mut self, _arg: &LBracket) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LParen'
    fn l_paren(&mut self, _arg: &LParen) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MinusColon'
    fn minus_colon(&mut self, _arg: &MinusColon) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MinusGT'
    fn minus_g_t(&mut self, _arg: &MinusGT) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PlusColon'
    fn plus_colon(&mut self, _arg: &PlusColon) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RAngle'
    fn r_angle(&mut self, _arg: &RAngle) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RBrace'
    fn r_brace(&mut self, _arg: &RBrace) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RBracket'
    fn r_bracket(&mut self, _arg: &RBracket) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RParen'
    fn r_paren(&mut self, _arg: &RParen) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Semicolon'
    fn semicolon(&mut self, _arg: &Semicolon) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Star'
    fn star(&mut self, _arg: &Star) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysComb'
    fn always_comb(&mut self, _arg: &AlwaysComb) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysFf'
    fn always_ff(&mut self, _arg: &AlwaysFf) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'As'
    fn r#as(&mut self, _arg: &As) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Assign'
    fn assign(&mut self, _arg: &Assign) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AsyncHigh'
    fn async_high(&mut self, _arg: &AsyncHigh) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AsyncLow'
    fn async_low(&mut self, _arg: &AsyncLow) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Bit'
    fn bit(&mut self, _arg: &Bit) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Case'
    fn case(&mut self, _arg: &Case) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Defaul'
    fn defaul(&mut self, _arg: &Defaul) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Else'
    fn r#else(&mut self, _arg: &Else) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Enum'
    fn r#enum(&mut self, _arg: &Enum) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Export'
    fn export(&mut self, _arg: &Export) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'F32'
    fn f32(&mut self, _arg: &F32) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'F64'
    fn f64(&mut self, _arg: &F64) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Final'
    fn r#final(&mut self, _arg: &Final) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'For'
    fn r#for(&mut self, _arg: &For) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Function'
    fn function(&mut self, _arg: &Function) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'I32'
    fn i32(&mut self, _arg: &I32) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'I64'
    fn i64(&mut self, _arg: &I64) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'If'
    fn r#if(&mut self, _arg: &If) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IfReset'
    fn if_reset(&mut self, _arg: &IfReset) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Import'
    fn import(&mut self, _arg: &Import) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'In'
    fn r#in(&mut self, _arg: &In) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Initial'
    fn initial(&mut self, _arg: &Initial) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Inout'
    fn inout(&mut self, _arg: &Inout) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Input'
    fn input(&mut self, _arg: &Input) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Inside'
    fn inside(&mut self, _arg: &Inside) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Inst'
    fn inst(&mut self, _arg: &Inst) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Interface'
    fn interface(&mut self, _arg: &Interface) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Localparam'
    fn localparam(&mut self, _arg: &Localparam) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Logic'
    fn logic(&mut self, _arg: &Logic) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Lsb'
    fn lsb(&mut self, _arg: &Lsb) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Modport'
    fn modport(&mut self, _arg: &Modport) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Module'
    fn module(&mut self, _arg: &Module) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Msb'
    fn msb(&mut self, _arg: &Msb) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Negedge'
    fn negedge(&mut self, _arg: &Negedge) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Output'
    fn output(&mut self, _arg: &Output) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Outside'
    fn outside(&mut self, _arg: &Outside) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Package'
    fn package(&mut self, _arg: &Package) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Parameter'
    fn parameter(&mut self, _arg: &Parameter) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Posedge'
    fn posedge(&mut self, _arg: &Posedge) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Ref'
    fn r#ref(&mut self, _arg: &Ref) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Repeat'
    fn repeat(&mut self, _arg: &Repeat) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Return'
    fn r#return(&mut self, _arg: &Return) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Signed'
    fn signed(&mut self, _arg: &Signed) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Step'
    fn step(&mut self, _arg: &Step) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Strin'
    fn strin(&mut self, _arg: &Strin) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Struct'
    fn r#struct(&mut self, _arg: &Struct) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SyncHigh'
    fn sync_high(&mut self, _arg: &SyncHigh) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SyncLow'
    fn sync_low(&mut self, _arg: &SyncLow) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Tri'
    fn tri(&mut self, _arg: &Tri) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Type'
    fn r#type(&mut self, _arg: &Type) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'U32'
    fn u32(&mut self, _arg: &U32) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'U64'
    fn u64(&mut self, _arg: &U64) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Var'
    fn var(&mut self, _arg: &Var) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Identifier'
    fn identifier(&mut self, _arg: &Identifier) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Number'
    fn number(&mut self, _arg: &Number) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IntegralNumber'
    fn integral_number(&mut self, _arg: &IntegralNumber) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RealNumber'
    fn real_number(&mut self, _arg: &RealNumber) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'HierarchicalIdentifier'
    fn hierarchical_identifier(&mut self, _arg: &HierarchicalIdentifier) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ScopedIdentifier'
    fn scoped_identifier(&mut self, _arg: &ScopedIdentifier) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ExpressionIdentifier'
    fn expression_identifier(&mut self, _arg: &ExpressionIdentifier) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression'
    fn expression(&mut self, _arg: &Expression) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression01'
    fn expression01(&mut self, _arg: &Expression01) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression02'
    fn expression02(&mut self, _arg: &Expression02) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression03'
    fn expression03(&mut self, _arg: &Expression03) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression04'
    fn expression04(&mut self, _arg: &Expression04) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression05'
    fn expression05(&mut self, _arg: &Expression05) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression06'
    fn expression06(&mut self, _arg: &Expression06) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression07'
    fn expression07(&mut self, _arg: &Expression07) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression08'
    fn expression08(&mut self, _arg: &Expression08) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression09'
    fn expression09(&mut self, _arg: &Expression09) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression10'
    fn expression10(&mut self, _arg: &Expression10) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression11'
    fn expression11(&mut self, _arg: &Expression11) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression12'
    fn expression12(&mut self, _arg: &Expression12) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Factor'
    fn factor(&mut self, _arg: &Factor) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FunctionCall'
    fn function_call(&mut self, _arg: &FunctionCall) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArgumentList'
    fn argument_list(&mut self, _arg: &ArgumentList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArgumentItem'
    fn argument_item(&mut self, _arg: &ArgumentItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ConcatenationList'
    fn concatenation_list(&mut self, _arg: &ConcatenationList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ConcatenationItem'
    fn concatenation_item(&mut self, _arg: &ConcatenationItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IfExpression'
    fn if_expression(&mut self, _arg: &IfExpression) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CaseExpression'
    fn case_expression(&mut self, _arg: &CaseExpression) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TypeExpression'
    fn type_expression(&mut self, _arg: &TypeExpression) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InsideExpression'
    fn inside_expression(&mut self, _arg: &InsideExpression) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OutsideExpression'
    fn outside_expression(&mut self, _arg: &OutsideExpression) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RangeList'
    fn range_list(&mut self, _arg: &RangeList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RangeItem'
    fn range_item(&mut self, _arg: &RangeItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Select'
    fn select(&mut self, _arg: &Select) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SelectOperator'
    fn select_operator(&mut self, _arg: &SelectOperator) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Width'
    fn width(&mut self, _arg: &Width) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Array'
    fn array(&mut self, _arg: &Array) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Range'
    fn range(&mut self, _arg: &Range) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RangeOperator'
    fn range_operator(&mut self, _arg: &RangeOperator) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FixedType'
    fn fixed_type(&mut self, _arg: &FixedType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'VariableType'
    fn variable_type(&mut self, _arg: &VariableType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TypeModifier'
    fn type_modifier(&mut self, _arg: &TypeModifier) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ScalarType'
    fn scalar_type(&mut self, _arg: &ScalarType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayType'
    fn array_type(&mut self, _arg: &ArrayType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Statement'
    fn statement(&mut self, _arg: &Statement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IdentifierStatement'
    fn identifier_statement(&mut self, _arg: &IdentifierStatement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Assignment'
    fn assignment(&mut self, _arg: &Assignment) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IfStatement'
    fn if_statement(&mut self, _arg: &IfStatement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IfResetStatement'
    fn if_reset_statement(&mut self, _arg: &IfResetStatement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ReturnStatement'
    fn return_statement(&mut self, _arg: &ReturnStatement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ForStatement'
    fn for_statement(&mut self, _arg: &ForStatement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CaseStatement'
    fn case_statement(&mut self, _arg: &CaseStatement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CaseItem'
    fn case_item(&mut self, _arg: &CaseItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Attribute'
    fn attribute(&mut self, _arg: &Attribute) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AttributeList'
    fn attribute_list(&mut self, _arg: &AttributeList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AttributeItem'
    fn attribute_item(&mut self, _arg: &AttributeItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'VarDeclaration'
    fn var_declaration(&mut self, _arg: &VarDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LocalparamDeclaration'
    fn localparam_declaration(&mut self, _arg: &LocalparamDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysFfDeclaration'
    fn always_ff_declaration(&mut self, _arg: &AlwaysFfDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysFfClock'
    fn always_ff_clock(&mut self, _arg: &AlwaysFfClock) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysFfReset'
    fn always_ff_reset(&mut self, _arg: &AlwaysFfReset) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysCombDeclaration'
    fn always_comb_declaration(&mut self, _arg: &AlwaysCombDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AssignDeclaration'
    fn assign_declaration(&mut self, _arg: &AssignDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModportDeclaration'
    fn modport_declaration(&mut self, _arg: &ModportDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModportList'
    fn modport_list(&mut self, _arg: &ModportList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModportGroup'
    fn modport_group(&mut self, _arg: &ModportGroup) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModportItem'
    fn modport_item(&mut self, _arg: &ModportItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EnumDeclaration'
    fn enum_declaration(&mut self, _arg: &EnumDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EnumList'
    fn enum_list(&mut self, _arg: &EnumList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EnumGroup'
    fn enum_group(&mut self, _arg: &EnumGroup) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EnumItem'
    fn enum_item(&mut self, _arg: &EnumItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StructDeclaration'
    fn struct_declaration(&mut self, _arg: &StructDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StructList'
    fn struct_list(&mut self, _arg: &StructList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StructGroup'
    fn struct_group(&mut self, _arg: &StructGroup) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StructItem'
    fn struct_item(&mut self, _arg: &StructItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InitialDeclaration'
    fn initial_declaration(&mut self, _arg: &InitialDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InitialItem'
    fn initial_item(&mut self, _arg: &InitialItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FinalDeclaration'
    fn final_declaration(&mut self, _arg: &FinalDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InstDeclaration'
    fn inst_declaration(&mut self, _arg: &InstDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InstParameter'
    fn inst_parameter(&mut self, _arg: &InstParameter) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InstParameterList'
    fn inst_parameter_list(&mut self, _arg: &InstParameterList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InstParameterGroup'
    fn inst_parameter_group(&mut self, _arg: &InstParameterGroup) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InstParameterItem'
    fn inst_parameter_item(&mut self, _arg: &InstParameterItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InstPortList'
    fn inst_port_list(&mut self, _arg: &InstPortList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InstPortGroup'
    fn inst_port_group(&mut self, _arg: &InstPortGroup) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InstPortItem'
    fn inst_port_item(&mut self, _arg: &InstPortItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WithParameter'
    fn with_parameter(&mut self, _arg: &WithParameter) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WithParameterList'
    fn with_parameter_list(&mut self, _arg: &WithParameterList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WithParameterGroup'
    fn with_parameter_group(&mut self, _arg: &WithParameterGroup) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WithParameterItem'
    fn with_parameter_item(&mut self, _arg: &WithParameterItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PortDeclaration'
    fn port_declaration(&mut self, _arg: &PortDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PortDeclarationList'
    fn port_declaration_list(&mut self, _arg: &PortDeclarationList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PortDeclarationGroup'
    fn port_declaration_group(&mut self, _arg: &PortDeclarationGroup) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PortDeclarationItem'
    fn port_declaration_item(&mut self, _arg: &PortDeclarationItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Direction'
    fn direction(&mut self, _arg: &Direction) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FunctionDeclaration'
    fn function_declaration(&mut self, _arg: &FunctionDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FunctionItem'
    fn function_item(&mut self, _arg: &FunctionItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ImportDeclaration'
    fn import_declaration(&mut self, _arg: &ImportDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ExportDeclaration'
    fn export_declaration(&mut self, _arg: &ExportDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModuleDeclaration'
    fn module_declaration(&mut self, _arg: &ModuleDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModuleIfDeclaration'
    fn module_if_declaration(&mut self, _arg: &ModuleIfDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModuleForDeclaration'
    fn module_for_declaration(&mut self, _arg: &ModuleForDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModuleNamedBlock'
    fn module_named_block(&mut self, _arg: &ModuleNamedBlock) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModuleOptionalNamedBlock'
    fn module_optional_named_block(&mut self, _arg: &ModuleOptionalNamedBlock) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModuleGroup'
    fn module_group(&mut self, _arg: &ModuleGroup) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModuleItem'
    fn module_item(&mut self, _arg: &ModuleItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InterfaceDeclaration'
    fn interface_declaration(&mut self, _arg: &InterfaceDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InterfaceIfDeclaration'
    fn interface_if_declaration(&mut self, _arg: &InterfaceIfDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InterfaceForDeclaration'
    fn interface_for_declaration(&mut self, _arg: &InterfaceForDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InterfaceNamedBlock'
    fn interface_named_block(&mut self, _arg: &InterfaceNamedBlock) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InterfaceOptionalNamedBlock'
    fn interface_optional_named_block(&mut self, _arg: &InterfaceOptionalNamedBlock) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InterfaceGroup'
    fn interface_group(&mut self, _arg: &InterfaceGroup) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InterfaceItem'
    fn interface_item(&mut self, _arg: &InterfaceItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PackageDeclaration'
    fn package_declaration(&mut self, _arg: &PackageDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PackageGroup'
    fn package_group(&mut self, _arg: &PackageGroup) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PackageItem'
    fn package_item(&mut self, _arg: &PackageItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DescriptionGroup'
    fn description_group(&mut self, _arg: &DescriptionGroup) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DescriptionItem'
    fn description_item(&mut self, _arg: &DescriptionItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Veryl'
    fn veryl(&mut self, _arg: &Veryl) -> Result<()> {
        Ok(())
    }
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 297
///
/// Number: IntegralNumber;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NumberIntegralNumber {
    pub integral_number: Box<IntegralNumber>,
}

///
/// Type derived for production 298
///
/// Number: RealNumber;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NumberRealNumber {
    pub real_number: Box<RealNumber>,
}

///
/// Type derived for production 299
///
/// IntegralNumber: Based;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IntegralNumberBased {
    pub based: Box<Based>,
}

///
/// Type derived for production 300
///
/// IntegralNumber: BaseLess;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IntegralNumberBaseLess {
    pub base_less: Box<BaseLess>,
}

///
/// Type derived for production 301
///
/// IntegralNumber: AllBit;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IntegralNumberAllBit {
    pub all_bit: Box<AllBit>,
}

///
/// Type derived for production 302
///
/// RealNumber: FixedPoint;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RealNumberFixedPoint {
    pub fixed_point: Box<FixedPoint>,
}

///
/// Type derived for production 303
///
/// RealNumber: Exponent;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RealNumberExponent {
    pub exponent: Box<Exponent>,
}

///
/// Type derived for production 315
///
/// ExpressionIdentifierGroup: ColonColon Identifier ExpressionIdentifierGroupList /* Vec */ ExpressionIdentifierGroupList0 /* Vec */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExpressionIdentifierGroupColonColonIdentifierExpressionIdentifierGroupListExpressionIdentifierGroupList0
{
    pub colon_colon: Box<ColonColon>,
    pub identifier: Box<Identifier>,
    pub expression_identifier_group_list: Vec<ExpressionIdentifierGroupList>,
    pub expression_identifier_group_list0: Vec<ExpressionIdentifierGroupList0>,
}

///
/// Type derived for production 320
///
/// ExpressionIdentifierGroup: ExpressionIdentifierGroupList1 /* Vec */ ExpressionIdentifierGroupList2 /* Vec */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExpressionIdentifierGroupExpressionIdentifierGroupList1ExpressionIdentifierGroupList2 {
    pub expression_identifier_group_list1: Vec<ExpressionIdentifierGroupList1>,
    pub expression_identifier_group_list2: Vec<ExpressionIdentifierGroupList2>,
}

///
/// Type derived for production 358
///
/// Expression09ListGroup: Operator10;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression09ListGroupOperator10 {
    pub operator10: Box<Operator10>,
}

///
/// Type derived for production 359
///
/// Expression09ListGroup: Star;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression09ListGroupStar {
    pub star: Box<Star>,
}

///
/// Type derived for production 369
///
/// Expression12ListGroup: UnaryOperator;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression12ListGroupUnaryOperator {
    pub unary_operator: Box<UnaryOperator>,
}

///
/// Type derived for production 370
///
/// Expression12ListGroup: Operator09;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression12ListGroupOperator09 {
    pub operator09: Box<Operator09>,
}

///
/// Type derived for production 371
///
/// Expression12ListGroup: Operator05;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression12ListGroupOperator05 {
    pub operator05: Box<Operator05>,
}

///
/// Type derived for production 372
///
/// Expression12ListGroup: Operator03;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression12ListGroupOperator03 {
    pub operator03: Box<Operator03>,
}

///
/// Type derived for production 373
///
/// Expression12ListGroup: Operator04;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression12ListGroupOperator04 {
    pub operator04: Box<Operator04>,
}

///
/// Type derived for production 375
///
/// Factor: Number;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorNumber {
    pub number: Box<Number>,
}

///
/// Type derived for production 376
///
/// Factor: ExpressionIdentifier FactorOpt /* Option */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorExpressionIdentifierFactorOpt {
    pub expression_identifier: Box<ExpressionIdentifier>,
    pub factor_opt: Option<Box<FactorOpt>>,
}

///
/// Type derived for production 377
///
/// Factor: LParen Expression RParen;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorLParenExpressionRParen {
    pub l_paren: Box<LParen>,
    pub expression: Box<Expression>,
    pub r_paren: Box<RParen>,
}

///
/// Type derived for production 378
///
/// Factor: LBrace ConcatenationList RBrace;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorLBraceConcatenationListRBrace {
    pub l_brace: Box<LBrace>,
    pub concatenation_list: Box<ConcatenationList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for production 379
///
/// Factor: IfExpression;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorIfExpression {
    pub if_expression: Box<IfExpression>,
}

///
/// Type derived for production 380
///
/// Factor: CaseExpression;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorCaseExpression {
    pub case_expression: Box<CaseExpression>,
}

///
/// Type derived for production 381
///
/// Factor: StringLiteral;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorStringLiteral {
    pub string_literal: Box<StringLiteral>,
}

///
/// Type derived for production 382
///
/// Factor: FactorGroup;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorFactorGroup {
    pub factor_group: Box<FactorGroup>,
}

///
/// Type derived for production 383
///
/// FactorGroup: Msb;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorGroupMsb {
    pub msb: Box<Msb>,
}

///
/// Type derived for production 384
///
/// FactorGroup: Lsb;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorGroupLsb {
    pub lsb: Box<Lsb>,
}

///
/// Type derived for production 385
///
/// Factor: InsideExpression;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorInsideExpression {
    pub inside_expression: Box<InsideExpression>,
}

///
/// Type derived for production 386
///
/// Factor: OutsideExpression;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorOutsideExpression {
    pub outside_expression: Box<OutsideExpression>,
}

///
/// Type derived for production 414
///
/// TypeExpression: ScalarType;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypeExpressionScalarType {
    pub scalar_type: Box<ScalarType>,
}

///
/// Type derived for production 415
///
/// TypeExpression: Type LParen Expression RParen;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypeExpressionTypeLParenExpressionRParen {
    pub r#type: Box<Type>,
    pub l_paren: Box<LParen>,
    pub expression: Box<Expression>,
    pub r_paren: Box<RParen>,
}

///
/// Type derived for production 427
///
/// SelectOperator: Colon;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SelectOperatorColon {
    pub colon: Box<Colon>,
}

///
/// Type derived for production 428
///
/// SelectOperator: PlusColon;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SelectOperatorPlusColon {
    pub plus_colon: Box<PlusColon>,
}

///
/// Type derived for production 429
///
/// SelectOperator: MinusColon;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SelectOperatorMinusColon {
    pub minus_colon: Box<MinusColon>,
}

///
/// Type derived for production 430
///
/// SelectOperator: Step;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SelectOperatorStep {
    pub step: Box<Step>,
}

///
/// Type derived for production 440
///
/// RangeOperator: DotDot;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RangeOperatorDotDot {
    pub dot_dot: Box<DotDot>,
}

///
/// Type derived for production 441
///
/// RangeOperator: DotDotEqu;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RangeOperatorDotDotEqu {
    pub dot_dot_equ: Box<DotDotEqu>,
}

///
/// Type derived for production 442
///
/// FixedType: U32;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FixedTypeU32 {
    pub u32: Box<U32>,
}

///
/// Type derived for production 443
///
/// FixedType: U64;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FixedTypeU64 {
    pub u64: Box<U64>,
}

///
/// Type derived for production 444
///
/// FixedType: I32;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FixedTypeI32 {
    pub i32: Box<I32>,
}

///
/// Type derived for production 445
///
/// FixedType: I64;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FixedTypeI64 {
    pub i64: Box<I64>,
}

///
/// Type derived for production 446
///
/// FixedType: F32;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FixedTypeF32 {
    pub f32: Box<F32>,
}

///
/// Type derived for production 447
///
/// FixedType: F64;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FixedTypeF64 {
    pub f64: Box<F64>,
}

///
/// Type derived for production 448
///
/// FixedType: Strin;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FixedTypeStrin {
    pub strin: Box<Strin>,
}

///
/// Type derived for production 450
///
/// VariableTypeGroup: Logic;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct VariableTypeGroupLogic {
    pub logic: Box<Logic>,
}

///
/// Type derived for production 451
///
/// VariableTypeGroup: Bit;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct VariableTypeGroupBit {
    pub bit: Box<Bit>,
}

///
/// Type derived for production 452
///
/// VariableTypeGroup: ScopedIdentifier;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct VariableTypeGroupScopedIdentifier {
    pub scoped_identifier: Box<ScopedIdentifier>,
}

///
/// Type derived for production 455
///
/// TypeModifier: Tri;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypeModifierTri {
    pub tri: Box<Tri>,
}

///
/// Type derived for production 456
///
/// TypeModifier: Signed;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypeModifierSigned {
    pub signed: Box<Signed>,
}

///
/// Type derived for production 458
///
/// ScalarTypeGroup: VariableType;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScalarTypeGroupVariableType {
    pub variable_type: Box<VariableType>,
}

///
/// Type derived for production 459
///
/// ScalarTypeGroup: FixedType;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScalarTypeGroupFixedType {
    pub fixed_type: Box<FixedType>,
}

///
/// Type derived for production 465
///
/// Statement: IdentifierStatement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementIdentifierStatement {
    pub identifier_statement: Box<IdentifierStatement>,
}

///
/// Type derived for production 466
///
/// Statement: IfStatement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementIfStatement {
    pub if_statement: Box<IfStatement>,
}

///
/// Type derived for production 467
///
/// Statement: IfResetStatement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementIfResetStatement {
    pub if_reset_statement: Box<IfResetStatement>,
}

///
/// Type derived for production 468
///
/// Statement: ReturnStatement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementReturnStatement {
    pub return_statement: Box<ReturnStatement>,
}

///
/// Type derived for production 469
///
/// Statement: ForStatement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementForStatement {
    pub for_statement: Box<ForStatement>,
}

///
/// Type derived for production 470
///
/// Statement: CaseStatement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementCaseStatement {
    pub case_statement: Box<CaseStatement>,
}

///
/// Type derived for production 472
///
/// IdentifierStatementGroup: FunctionCall;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IdentifierStatementGroupFunctionCall {
    pub function_call: Box<FunctionCall>,
}

///
/// Type derived for production 473
///
/// IdentifierStatementGroup: Assignment;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IdentifierStatementGroupAssignment {
    pub assignment: Box<Assignment>,
}

///
/// Type derived for production 475
///
/// AssignmentGroup: Equ;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AssignmentGroupEqu {
    pub equ: Box<Equ>,
}

///
/// Type derived for production 476
///
/// AssignmentGroup: AssignmentOperator;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AssignmentGroupAssignmentOperator {
    pub assignment_operator: Box<AssignmentOperator>,
}

///
/// Type derived for production 509
///
/// CaseItemGroup0: Statement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CaseItemGroup0Statement {
    pub statement: Box<Statement>,
}

///
/// Type derived for production 510
///
/// CaseItemGroup0: LBrace CaseItemGroup0List /* Vec */ RBrace;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CaseItemGroup0LBraceCaseItemGroup0ListRBrace {
    pub l_brace: Box<LBrace>,
    pub case_item_group0_list: Vec<CaseItemGroup0List>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for production 513
///
/// CaseItemGroup: Expression;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CaseItemGroupExpression {
    pub expression: Box<Expression>,
}

///
/// Type derived for production 514
///
/// CaseItemGroup: Defaul;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CaseItemGroupDefaul {
    pub defaul: Box<Defaul>,
}

///
/// Type derived for production 523
///
/// AttributeItem: Identifier;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AttributeItemIdentifier {
    pub identifier: Box<Identifier>,
}

///
/// Type derived for production 524
///
/// AttributeItem: StringLiteral;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AttributeItemStringLiteral {
    pub string_literal: Box<StringLiteral>,
}

///
/// Type derived for production 529
///
/// LocalparamDeclarationGroup: ArrayType Equ Expression;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LocalparamDeclarationGroupArrayTypeEquExpression {
    pub array_type: Box<ArrayType>,
    pub equ: Box<Equ>,
    pub expression: Box<Expression>,
}

///
/// Type derived for production 530
///
/// LocalparamDeclarationGroup: Type Equ TypeExpression;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LocalparamDeclarationGroupTypeEquTypeExpression {
    pub r#type: Box<Type>,
    pub equ: Box<Equ>,
    pub type_expression: Box<TypeExpression>,
}

///
/// Type derived for production 538
///
/// AlwaysFfClockOptGroup: Posedge;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysFfClockOptGroupPosedge {
    pub posedge: Box<Posedge>,
}

///
/// Type derived for production 539
///
/// AlwaysFfClockOptGroup: Negedge;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysFfClockOptGroupNegedge {
    pub negedge: Box<Negedge>,
}

///
/// Type derived for production 543
///
/// AlwaysFfResetOptGroup: AsyncLow;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysFfResetOptGroupAsyncLow {
    pub async_low: Box<AsyncLow>,
}

///
/// Type derived for production 544
///
/// AlwaysFfResetOptGroup: AsyncHigh;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysFfResetOptGroupAsyncHigh {
    pub async_high: Box<AsyncHigh>,
}

///
/// Type derived for production 545
///
/// AlwaysFfResetOptGroup: SyncLow;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysFfResetOptGroupSyncLow {
    pub sync_low: Box<SyncLow>,
}

///
/// Type derived for production 546
///
/// AlwaysFfResetOptGroup: SyncHigh;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysFfResetOptGroupSyncHigh {
    pub sync_high: Box<SyncHigh>,
}

///
/// Type derived for production 559
///
/// ModportGroupGroup: LBrace ModportList RBrace;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModportGroupGroupLBraceModportListRBrace {
    pub l_brace: Box<LBrace>,
    pub modport_list: Box<ModportList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for production 560
///
/// ModportGroupGroup: ModportItem;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModportGroupGroupModportItem {
    pub modport_item: Box<ModportItem>,
}

///
/// Type derived for production 571
///
/// EnumGroupGroup: LBrace EnumList RBrace;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EnumGroupGroupLBraceEnumListRBrace {
    pub l_brace: Box<LBrace>,
    pub enum_list: Box<EnumList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for production 572
///
/// EnumGroupGroup: EnumItem;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EnumGroupGroupEnumItem {
    pub enum_item: Box<EnumItem>,
}

///
/// Type derived for production 585
///
/// StructGroupGroup: LBrace StructList RBrace;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StructGroupGroupLBraceStructListRBrace {
    pub l_brace: Box<LBrace>,
    pub struct_list: Box<StructList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for production 586
///
/// StructGroupGroup: StructItem;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StructGroupGroupStructItem {
    pub struct_item: Box<StructItem>,
}

///
/// Type derived for production 593
///
/// InitialItem: Statement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InitialItemStatement {
    pub statement: Box<Statement>,
}

///
/// Type derived for production 594
///
/// InitialItem: Assignment;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InitialItemAssignment {
    pub assignment: Box<Assignment>,
}

///
/// Type derived for production 616
///
/// InstParameterGroupGroup: LBrace InstParameterList RBrace;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstParameterGroupGroupLBraceInstParameterListRBrace {
    pub l_brace: Box<LBrace>,
    pub inst_parameter_list: Box<InstParameterList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for production 617
///
/// InstParameterGroupGroup: InstParameterItem;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstParameterGroupGroupInstParameterItem {
    pub inst_parameter_item: Box<InstParameterItem>,
}

///
/// Type derived for production 629
///
/// InstPortGroupGroup: LBrace InstPortList RBrace;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstPortGroupGroupLBraceInstPortListRBrace {
    pub l_brace: Box<LBrace>,
    pub inst_port_list: Box<InstPortList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for production 630
///
/// InstPortGroupGroup: InstPortItem;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstPortGroupGroupInstPortItem {
    pub inst_port_item: Box<InstPortItem>,
}

///
/// Type derived for production 645
///
/// WithParameterGroupGroup: LBrace WithParameterList RBrace;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct WithParameterGroupGroupLBraceWithParameterListRBrace {
    pub l_brace: Box<LBrace>,
    pub with_parameter_list: Box<WithParameterList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for production 646
///
/// WithParameterGroupGroup: WithParameterItem;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct WithParameterGroupGroupWithParameterItem {
    pub with_parameter_item: Box<WithParameterItem>,
}

///
/// Type derived for production 650
///
/// WithParameterItemGroup0: ArrayType Equ Expression;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct WithParameterItemGroup0ArrayTypeEquExpression {
    pub array_type: Box<ArrayType>,
    pub equ: Box<Equ>,
    pub expression: Box<Expression>,
}

///
/// Type derived for production 651
///
/// WithParameterItemGroup0: Type Equ TypeExpression;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct WithParameterItemGroup0TypeEquTypeExpression {
    pub r#type: Box<Type>,
    pub equ: Box<Equ>,
    pub type_expression: Box<TypeExpression>,
}

///
/// Type derived for production 652
///
/// WithParameterItemGroup: Parameter;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct WithParameterItemGroupParameter {
    pub parameter: Box<Parameter>,
}

///
/// Type derived for production 653
///
/// WithParameterItemGroup: Localparam;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct WithParameterItemGroupLocalparam {
    pub localparam: Box<Localparam>,
}

///
/// Type derived for production 663
///
/// PortDeclarationGroupGroup: LBrace PortDeclarationList RBrace;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PortDeclarationGroupGroupLBracePortDeclarationListRBrace {
    pub l_brace: Box<LBrace>,
    pub port_declaration_list: Box<PortDeclarationList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for production 664
///
/// PortDeclarationGroupGroup: PortDeclarationItem;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PortDeclarationGroupGroupPortDeclarationItem {
    pub port_declaration_item: Box<PortDeclarationItem>,
}

///
/// Type derived for production 668
///
/// PortDeclarationItemGroup: Direction ArrayType;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PortDeclarationItemGroupDirectionArrayType {
    pub direction: Box<Direction>,
    pub array_type: Box<ArrayType>,
}

///
/// Type derived for production 669
///
/// PortDeclarationItemGroup: Interface PortDeclarationItemOpt /* Option */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PortDeclarationItemGroupInterfacePortDeclarationItemOpt {
    pub interface: Box<Interface>,
    pub port_declaration_item_opt: Option<Box<PortDeclarationItemOpt>>,
}

///
/// Type derived for production 672
///
/// Direction: Input;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DirectionInput {
    pub input: Box<Input>,
}

///
/// Type derived for production 673
///
/// Direction: Output;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DirectionOutput {
    pub output: Box<Output>,
}

///
/// Type derived for production 674
///
/// Direction: Inout;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DirectionInout {
    pub inout: Box<Inout>,
}

///
/// Type derived for production 675
///
/// Direction: Ref;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DirectionRef {
    pub r#ref: Box<Ref>,
}

///
/// Type derived for production 676
///
/// Direction: Modport;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DirectionModport {
    pub modport: Box<Modport>,
}

///
/// Type derived for production 684
///
/// FunctionItem: VarDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionItemVarDeclaration {
    pub var_declaration: Box<VarDeclaration>,
}

///
/// Type derived for production 685
///
/// FunctionItem: Statement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionItemStatement {
    pub statement: Box<Statement>,
}

///
/// Type derived for production 687
///
/// ImportDeclarationGroup: Identifier;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ImportDeclarationGroupIdentifier {
    pub identifier: Box<Identifier>,
}

///
/// Type derived for production 688
///
/// ImportDeclarationGroup: Star;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ImportDeclarationGroupStar {
    pub star: Box<Star>,
}

///
/// Type derived for production 690
///
/// ExportDeclarationGroup0: Identifier;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExportDeclarationGroup0Identifier {
    pub identifier: Box<Identifier>,
}

///
/// Type derived for production 691
///
/// ExportDeclarationGroup0: Star;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExportDeclarationGroup0Star {
    pub star: Box<Star>,
}

///
/// Type derived for production 692
///
/// ExportDeclarationGroup: Identifier;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExportDeclarationGroupIdentifier {
    pub identifier: Box<Identifier>,
}

///
/// Type derived for production 693
///
/// ExportDeclarationGroup: Star;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExportDeclarationGroupStar {
    pub star: Box<Star>,
}

///
/// Type derived for production 718
///
/// ModuleGroupGroup: LBrace ModuleGroupGroupList /* Vec */ RBrace;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleGroupGroupLBraceModuleGroupGroupListRBrace {
    pub l_brace: Box<LBrace>,
    pub module_group_group_list: Vec<ModuleGroupGroupList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for production 721
///
/// ModuleGroupGroup: ModuleItem;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleGroupGroupModuleItem {
    pub module_item: Box<ModuleItem>,
}

///
/// Type derived for production 724
///
/// ModuleItem: VarDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleItemVarDeclaration {
    pub var_declaration: Box<VarDeclaration>,
}

///
/// Type derived for production 725
///
/// ModuleItem: InstDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleItemInstDeclaration {
    pub inst_declaration: Box<InstDeclaration>,
}

///
/// Type derived for production 726
///
/// ModuleItem: LocalparamDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleItemLocalparamDeclaration {
    pub localparam_declaration: Box<LocalparamDeclaration>,
}

///
/// Type derived for production 727
///
/// ModuleItem: AlwaysFfDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleItemAlwaysFfDeclaration {
    pub always_ff_declaration: Box<AlwaysFfDeclaration>,
}

///
/// Type derived for production 728
///
/// ModuleItem: AlwaysCombDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleItemAlwaysCombDeclaration {
    pub always_comb_declaration: Box<AlwaysCombDeclaration>,
}

///
/// Type derived for production 729
///
/// ModuleItem: AssignDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleItemAssignDeclaration {
    pub assign_declaration: Box<AssignDeclaration>,
}

///
/// Type derived for production 730
///
/// ModuleItem: FunctionDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleItemFunctionDeclaration {
    pub function_declaration: Box<FunctionDeclaration>,
}

///
/// Type derived for production 731
///
/// ModuleItem: ModuleIfDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleItemModuleIfDeclaration {
    pub module_if_declaration: Box<ModuleIfDeclaration>,
}

///
/// Type derived for production 732
///
/// ModuleItem: ModuleForDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleItemModuleForDeclaration {
    pub module_for_declaration: Box<ModuleForDeclaration>,
}

///
/// Type derived for production 733
///
/// ModuleItem: EnumDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleItemEnumDeclaration {
    pub enum_declaration: Box<EnumDeclaration>,
}

///
/// Type derived for production 734
///
/// ModuleItem: StructDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleItemStructDeclaration {
    pub struct_declaration: Box<StructDeclaration>,
}

///
/// Type derived for production 735
///
/// ModuleItem: ModuleNamedBlock;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleItemModuleNamedBlock {
    pub module_named_block: Box<ModuleNamedBlock>,
}

///
/// Type derived for production 736
///
/// ModuleItem: ImportDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleItemImportDeclaration {
    pub import_declaration: Box<ImportDeclaration>,
}

///
/// Type derived for production 737
///
/// ModuleItem: InitialDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleItemInitialDeclaration {
    pub initial_declaration: Box<InitialDeclaration>,
}

///
/// Type derived for production 738
///
/// ModuleItem: FinalDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleItemFinalDeclaration {
    pub final_declaration: Box<FinalDeclaration>,
}

///
/// Type derived for production 761
///
/// InterfaceGroupGroup: LBrace InterfaceGroupGroupList /* Vec */ RBrace;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceGroupGroupLBraceInterfaceGroupGroupListRBrace {
    pub l_brace: Box<LBrace>,
    pub interface_group_group_list: Vec<InterfaceGroupGroupList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for production 764
///
/// InterfaceGroupGroup: InterfaceItem;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceGroupGroupInterfaceItem {
    pub interface_item: Box<InterfaceItem>,
}

///
/// Type derived for production 767
///
/// InterfaceItem: VarDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceItemVarDeclaration {
    pub var_declaration: Box<VarDeclaration>,
}

///
/// Type derived for production 768
///
/// InterfaceItem: LocalparamDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceItemLocalparamDeclaration {
    pub localparam_declaration: Box<LocalparamDeclaration>,
}

///
/// Type derived for production 769
///
/// InterfaceItem: ModportDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceItemModportDeclaration {
    pub modport_declaration: Box<ModportDeclaration>,
}

///
/// Type derived for production 770
///
/// InterfaceItem: InterfaceIfDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceItemInterfaceIfDeclaration {
    pub interface_if_declaration: Box<InterfaceIfDeclaration>,
}

///
/// Type derived for production 771
///
/// InterfaceItem: InterfaceForDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceItemInterfaceForDeclaration {
    pub interface_for_declaration: Box<InterfaceForDeclaration>,
}

///
/// Type derived for production 772
///
/// InterfaceItem: EnumDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceItemEnumDeclaration {
    pub enum_declaration: Box<EnumDeclaration>,
}

///
/// Type derived for production 773
///
/// InterfaceItem: StructDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceItemStructDeclaration {
    pub struct_declaration: Box<StructDeclaration>,
}

///
/// Type derived for production 774
///
/// InterfaceItem: InterfaceNamedBlock;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceItemInterfaceNamedBlock {
    pub interface_named_block: Box<InterfaceNamedBlock>,
}

///
/// Type derived for production 775
///
/// InterfaceItem: FunctionDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceItemFunctionDeclaration {
    pub function_declaration: Box<FunctionDeclaration>,
}

///
/// Type derived for production 776
///
/// InterfaceItem: ImportDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceItemImportDeclaration {
    pub import_declaration: Box<ImportDeclaration>,
}

///
/// Type derived for production 777
///
/// InterfaceItem: InitialDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceItemInitialDeclaration {
    pub initial_declaration: Box<InitialDeclaration>,
}

///
/// Type derived for production 778
///
/// InterfaceItem: FinalDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceItemFinalDeclaration {
    pub final_declaration: Box<FinalDeclaration>,
}

///
/// Type derived for production 783
///
/// PackageGroupGroup: LBrace PackageGroupGroupList /* Vec */ RBrace;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PackageGroupGroupLBracePackageGroupGroupListRBrace {
    pub l_brace: Box<LBrace>,
    pub package_group_group_list: Vec<PackageGroupGroupList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for production 786
///
/// PackageGroupGroup: PackageItem;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PackageGroupGroupPackageItem {
    pub package_item: Box<PackageItem>,
}

///
/// Type derived for production 789
///
/// PackageItem: VarDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PackageItemVarDeclaration {
    pub var_declaration: Box<VarDeclaration>,
}

///
/// Type derived for production 790
///
/// PackageItem: LocalparamDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PackageItemLocalparamDeclaration {
    pub localparam_declaration: Box<LocalparamDeclaration>,
}

///
/// Type derived for production 791
///
/// PackageItem: EnumDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PackageItemEnumDeclaration {
    pub enum_declaration: Box<EnumDeclaration>,
}

///
/// Type derived for production 792
///
/// PackageItem: StructDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PackageItemStructDeclaration {
    pub struct_declaration: Box<StructDeclaration>,
}

///
/// Type derived for production 793
///
/// PackageItem: FunctionDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PackageItemFunctionDeclaration {
    pub function_declaration: Box<FunctionDeclaration>,
}

///
/// Type derived for production 794
///
/// PackageItem: ImportDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PackageItemImportDeclaration {
    pub import_declaration: Box<ImportDeclaration>,
}

///
/// Type derived for production 795
///
/// PackageItem: ExportDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PackageItemExportDeclaration {
    pub export_declaration: Box<ExportDeclaration>,
}

///
/// Type derived for production 796
///
/// PackageItem: InitialDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PackageItemInitialDeclaration {
    pub initial_declaration: Box<InitialDeclaration>,
}

///
/// Type derived for production 797
///
/// PackageItem: FinalDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PackageItemFinalDeclaration {
    pub final_declaration: Box<FinalDeclaration>,
}

///
/// Type derived for production 799
///
/// DescriptionGroupGroup: LBrace DescriptionGroupGroupList /* Vec */ RBrace;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DescriptionGroupGroupLBraceDescriptionGroupGroupListRBrace {
    pub l_brace: Box<LBrace>,
    pub description_group_group_list: Vec<DescriptionGroupGroupList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for production 802
///
/// DescriptionGroupGroup: DescriptionItem;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DescriptionGroupGroupDescriptionItem {
    pub description_item: Box<DescriptionItem>,
}

///
/// Type derived for production 805
///
/// DescriptionItem: ModuleDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DescriptionItemModuleDeclaration {
    pub module_declaration: Box<ModuleDeclaration>,
}

///
/// Type derived for production 806
///
/// DescriptionItem: InterfaceDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DescriptionItemInterfaceDeclaration {
    pub interface_declaration: Box<InterfaceDeclaration>,
}

///
/// Type derived for production 807
///
/// DescriptionItem: PackageDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DescriptionItemPackageDeclaration {
    pub package_declaration: Box<PackageDeclaration>,
}

///
/// Type derived for production 808
///
/// DescriptionItem: ImportDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DescriptionItemImportDeclaration {
    pub import_declaration: Box<ImportDeclaration>,
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal AllBit
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AllBit {
    pub all_bit_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal AllBitTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AllBitTerm {
    pub all_bit_term: crate::veryl_token::Token, /* (?:[0-9]+(?:_[0-9]+)*)?'[01xzXZ] */
}

///
/// Type derived for non-terminal AllBitToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AllBitToken {
    pub all_bit_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal AlwaysComb
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysComb {
    pub always_comb_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal AlwaysCombDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysCombDeclaration {
    pub always_comb: Box<AlwaysComb>,
    pub l_brace: Box<LBrace>,
    pub always_comb_declaration_list: Vec<AlwaysCombDeclarationList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal AlwaysCombDeclarationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysCombDeclarationList {
    pub statement: Box<Statement>,
}

///
/// Type derived for non-terminal AlwaysCombTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysCombTerm {
    pub always_comb_term: crate::veryl_token::Token, /* (?-u:\b)always_comb(?-u:\b) */
}

///
/// Type derived for non-terminal AlwaysCombToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysCombToken {
    pub always_comb_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal AlwaysFf
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysFf {
    pub always_ff_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal AlwaysFfClock
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysFfClock {
    pub always_ff_clock_opt: Option<Box<AlwaysFfClockOpt>>,
    pub hierarchical_identifier: Box<HierarchicalIdentifier>,
}

///
/// Type derived for non-terminal AlwaysFfClockOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysFfClockOpt {
    pub always_ff_clock_opt_group: Box<AlwaysFfClockOptGroup>,
}

///
/// Type derived for non-terminal AlwaysFfClockOptGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum AlwaysFfClockOptGroup {
    Posedge(AlwaysFfClockOptGroupPosedge),
    Negedge(AlwaysFfClockOptGroupNegedge),
}

///
/// Type derived for non-terminal AlwaysFfDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysFfDeclaration {
    pub always_ff: Box<AlwaysFf>,
    pub l_paren: Box<LParen>,
    pub always_ff_clock: Box<AlwaysFfClock>,
    pub always_ff_declaration_opt: Option<Box<AlwaysFfDeclarationOpt>>,
    pub r_paren: Box<RParen>,
    pub l_brace: Box<LBrace>,
    pub always_ff_declaration_list: Vec<AlwaysFfDeclarationList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal AlwaysFfDeclarationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysFfDeclarationList {
    pub statement: Box<Statement>,
}

///
/// Type derived for non-terminal AlwaysFfDeclarationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysFfDeclarationOpt {
    pub comma: Box<Comma>,
    pub always_ff_reset: Box<AlwaysFfReset>,
}

///
/// Type derived for non-terminal AlwaysFfReset
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysFfReset {
    pub always_ff_reset_opt: Option<Box<AlwaysFfResetOpt>>,
    pub hierarchical_identifier: Box<HierarchicalIdentifier>,
}

///
/// Type derived for non-terminal AlwaysFfResetOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysFfResetOpt {
    pub always_ff_reset_opt_group: Box<AlwaysFfResetOptGroup>,
}

///
/// Type derived for non-terminal AlwaysFfResetOptGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum AlwaysFfResetOptGroup {
    AsyncLow(AlwaysFfResetOptGroupAsyncLow),
    AsyncHigh(AlwaysFfResetOptGroupAsyncHigh),
    SyncLow(AlwaysFfResetOptGroupSyncLow),
    SyncHigh(AlwaysFfResetOptGroupSyncHigh),
}

///
/// Type derived for non-terminal AlwaysFfTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysFfTerm {
    pub always_ff_term: crate::veryl_token::Token, /* (?-u:\b)always_ff(?-u:\b) */
}

///
/// Type derived for non-terminal AlwaysFfToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysFfToken {
    pub always_ff_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal ArgumentItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArgumentItem {
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal ArgumentList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArgumentList {
    pub argument_item: Box<ArgumentItem>,
    pub argument_list_list: Vec<ArgumentListList>,
    pub argument_list_opt: Option<Box<ArgumentListOpt>>,
}

///
/// Type derived for non-terminal ArgumentListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArgumentListList {
    pub comma: Box<Comma>,
    pub argument_item: Box<ArgumentItem>,
}

///
/// Type derived for non-terminal ArgumentListOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArgumentListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal Array
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Array {
    pub l_bracket: Box<LBracket>,
    pub expression: Box<Expression>,
    pub array_list: Vec<ArrayList>,
    pub r_bracket: Box<RBracket>,
}

///
/// Type derived for non-terminal ArrayList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayList {
    pub comma: Box<Comma>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal ArrayType
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayType {
    pub scalar_type: Box<ScalarType>,
    pub array_type_opt: Option<Box<ArrayTypeOpt>>,
}

///
/// Type derived for non-terminal ArrayTypeOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ArrayTypeOpt {
    pub array: Box<Array>,
}

///
/// Type derived for non-terminal As
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct As {
    pub as_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal AsTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AsTerm {
    pub as_term: crate::veryl_token::Token, /* (?-u:\b)as(?-u:\b) */
}

///
/// Type derived for non-terminal AsToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AsToken {
    pub as_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Assign
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Assign {
    pub assign_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal AssignDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AssignDeclaration {
    pub assign: Box<Assign>,
    pub hierarchical_identifier: Box<HierarchicalIdentifier>,
    pub equ: Box<Equ>,
    pub expression: Box<Expression>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal AssignTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AssignTerm {
    pub assign_term: crate::veryl_token::Token, /* (?-u:\b)assign(?-u:\b) */
}

///
/// Type derived for non-terminal AssignToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AssignToken {
    pub assign_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Assignment
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Assignment {
    pub assignment_group: Box<AssignmentGroup>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal AssignmentGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum AssignmentGroup {
    Equ(AssignmentGroupEqu),
    AssignmentOperator(AssignmentGroupAssignmentOperator),
}

///
/// Type derived for non-terminal AssignmentOperator
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AssignmentOperator {
    pub assignment_operator_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal AssignmentOperatorTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AssignmentOperatorTerm {
    pub assignment_operator_term: crate::veryl_token::Token, /* \+=|-=|\*=|/=|%=|&=|\|=|\^=|<<=|>>=|<<<=|>>>= */
}

///
/// Type derived for non-terminal AssignmentOperatorToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AssignmentOperatorToken {
    pub assignment_operator_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal AsyncHigh
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AsyncHigh {
    pub async_high_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal AsyncHighTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AsyncHighTerm {
    pub async_high_term: crate::veryl_token::Token, /* (?-u:\b)async_high(?-u:\b) */
}

///
/// Type derived for non-terminal AsyncHighToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AsyncHighToken {
    pub async_high_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal AsyncLow
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AsyncLow {
    pub async_low_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal AsyncLowTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AsyncLowTerm {
    pub async_low_term: crate::veryl_token::Token, /* (?-u:\b)async_low(?-u:\b) */
}

///
/// Type derived for non-terminal AsyncLowToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AsyncLowToken {
    pub async_low_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Attribute
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Attribute {
    pub hash: Box<Hash>,
    pub l_bracket: Box<LBracket>,
    pub identifier: Box<Identifier>,
    pub attribute_opt: Option<Box<AttributeOpt>>,
    pub r_bracket: Box<RBracket>,
}

///
/// Type derived for non-terminal AttributeItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum AttributeItem {
    Identifier(AttributeItemIdentifier),
    StringLiteral(AttributeItemStringLiteral),
}

///
/// Type derived for non-terminal AttributeList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AttributeList {
    pub attribute_item: Box<AttributeItem>,
    pub attribute_list_list: Vec<AttributeListList>,
    pub attribute_list_opt: Option<Box<AttributeListOpt>>,
}

///
/// Type derived for non-terminal AttributeListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AttributeListList {
    pub comma: Box<Comma>,
    pub attribute_item: Box<AttributeItem>,
}

///
/// Type derived for non-terminal AttributeListOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AttributeListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal AttributeOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AttributeOpt {
    pub l_paren: Box<LParen>,
    pub attribute_list: Box<AttributeList>,
    pub r_paren: Box<RParen>,
}

///
/// Type derived for non-terminal BaseLess
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BaseLess {
    pub base_less_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal BaseLessTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BaseLessTerm {
    pub base_less_term: crate::veryl_token::Token, /* [0-9]+(?:_[0-9]+)* */
}

///
/// Type derived for non-terminal BaseLessToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BaseLessToken {
    pub base_less_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Based
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Based {
    pub based_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal BasedTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BasedTerm {
    pub based_term: crate::veryl_token::Token, /* (?:[0-9]+(?:_[0-9]+)*)?'[bodh][0-9a-fA-FxzXZ]+(?:_[0-9a-fA-FxzXZ]+)* */
}

///
/// Type derived for non-terminal BasedToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BasedToken {
    pub based_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Bit
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Bit {
    pub bit_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal BitTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BitTerm {
    pub bit_term: crate::veryl_token::Token, /* (?-u:\b)bit(?-u:\b) */
}

///
/// Type derived for non-terminal BitToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BitToken {
    pub bit_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Case
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Case {
    pub case_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal CaseExpression
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CaseExpression {
    pub case: Box<Case>,
    pub expression: Box<Expression>,
    pub l_brace: Box<LBrace>,
    pub expression0: Box<Expression>,
    pub colon: Box<Colon>,
    pub expression1: Box<Expression>,
    pub comma: Box<Comma>,
    pub case_expression_list: Vec<CaseExpressionList>,
    pub defaul: Box<Defaul>,
    pub colon0: Box<Colon>,
    pub expression2: Box<Expression>,
    pub case_expression_opt: Option<Box<CaseExpressionOpt>>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal CaseExpressionList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CaseExpressionList {
    pub expression: Box<Expression>,
    pub colon: Box<Colon>,
    pub expression0: Box<Expression>,
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal CaseExpressionOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CaseExpressionOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal CaseItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CaseItem {
    pub case_item_group: Box<CaseItemGroup>,
    pub colon: Box<Colon>,
    pub case_item_group0: Box<CaseItemGroup0>,
}

///
/// Type derived for non-terminal CaseItemGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum CaseItemGroup {
    Expression(CaseItemGroupExpression),
    Defaul(CaseItemGroupDefaul),
}

///
/// Type derived for non-terminal CaseItemGroup0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum CaseItemGroup0 {
    Statement(CaseItemGroup0Statement),
    LBraceCaseItemGroup0ListRBrace(CaseItemGroup0LBraceCaseItemGroup0ListRBrace),
}

///
/// Type derived for non-terminal CaseItemGroup0List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CaseItemGroup0List {
    pub statement: Box<Statement>,
}

///
/// Type derived for non-terminal CaseStatement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CaseStatement {
    pub case: Box<Case>,
    pub expression: Box<Expression>,
    pub l_brace: Box<LBrace>,
    pub case_statement_list: Vec<CaseStatementList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal CaseStatementList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CaseStatementList {
    pub case_item: Box<CaseItem>,
}

///
/// Type derived for non-terminal CaseTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CaseTerm {
    pub case_term: crate::veryl_token::Token, /* (?-u:\b)case(?-u:\b) */
}

///
/// Type derived for non-terminal CaseToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CaseToken {
    pub case_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Colon
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Colon {
    pub colon_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ColonColon
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ColonColon {
    pub colon_colon_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ColonColonTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ColonColonTerm {
    pub colon_colon_term: crate::veryl_token::Token, /* :: */
}

///
/// Type derived for non-terminal ColonColonToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ColonColonToken {
    pub colon_colon_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal ColonTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ColonTerm {
    pub colon_term: crate::veryl_token::Token, /* : */
}

///
/// Type derived for non-terminal ColonToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ColonToken {
    pub colon_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Comma
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Comma {
    pub comma_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal CommaTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CommaTerm {
    pub comma_term: crate::veryl_token::Token, /* , */
}

///
/// Type derived for non-terminal CommaToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CommaToken {
    pub comma_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Comments
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Comments {
    pub comments_opt: Option<Box<CommentsOpt>>,
}

///
/// Type derived for non-terminal CommentsOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CommentsOpt {
    pub comments_term: Box<CommentsTerm>,
}

///
/// Type derived for non-terminal CommentsTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CommentsTerm {
    pub comments_term: crate::veryl_token::Token, /* (?:(?:(?://.*(?:\r\n|\r|\n|$))|(?:(?ms)/\u{2a}.*?\u{2a}/))\s*)+ */
}

///
/// Type derived for non-terminal ConcatenationItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ConcatenationItem {
    pub expression: Box<Expression>,
    pub concatenation_item_opt: Option<Box<ConcatenationItemOpt>>,
}

///
/// Type derived for non-terminal ConcatenationItemOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ConcatenationItemOpt {
    pub repeat: Box<Repeat>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal ConcatenationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ConcatenationList {
    pub concatenation_item: Box<ConcatenationItem>,
    pub concatenation_list_list: Vec<ConcatenationListList>,
    pub concatenation_list_opt: Option<Box<ConcatenationListOpt>>,
}

///
/// Type derived for non-terminal ConcatenationListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ConcatenationListList {
    pub comma: Box<Comma>,
    pub concatenation_item: Box<ConcatenationItem>,
}

///
/// Type derived for non-terminal ConcatenationListOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ConcatenationListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal Defaul
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Defaul {
    pub default_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal DefaultTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DefaultTerm {
    pub default_term: crate::veryl_token::Token, /* (?-u:\b)default(?-u:\b) */
}

///
/// Type derived for non-terminal DefaultToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DefaultToken {
    pub default_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal DescriptionGroup
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DescriptionGroup {
    pub description_group_list: Vec<DescriptionGroupList>,
    pub description_group_group: Box<DescriptionGroupGroup>,
}

///
/// Type derived for non-terminal DescriptionGroupGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum DescriptionGroupGroup {
    LBraceDescriptionGroupGroupListRBrace(
        DescriptionGroupGroupLBraceDescriptionGroupGroupListRBrace,
    ),
    DescriptionItem(DescriptionGroupGroupDescriptionItem),
}

///
/// Type derived for non-terminal DescriptionGroupGroupList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DescriptionGroupGroupList {
    pub description_group: Box<DescriptionGroup>,
}

///
/// Type derived for non-terminal DescriptionGroupList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DescriptionGroupList {
    pub attribute: Box<Attribute>,
}

///
/// Type derived for non-terminal DescriptionItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum DescriptionItem {
    ModuleDeclaration(DescriptionItemModuleDeclaration),
    InterfaceDeclaration(DescriptionItemInterfaceDeclaration),
    PackageDeclaration(DescriptionItemPackageDeclaration),
    ImportDeclaration(DescriptionItemImportDeclaration),
}

///
/// Type derived for non-terminal Direction
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Direction {
    Input(DirectionInput),
    Output(DirectionOutput),
    Inout(DirectionInout),
    Ref(DirectionRef),
    Modport(DirectionModport),
}

///
/// Type derived for non-terminal Dollar
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Dollar {
    pub dollar_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal DollarTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DollarTerm {
    pub dollar_term: crate::veryl_token::Token, /* $ */
}

///
/// Type derived for non-terminal DollarToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DollarToken {
    pub dollar_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Dot
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Dot {
    pub dot_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal DotDot
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DotDot {
    pub dot_dot_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal DotDotEqu
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DotDotEqu {
    pub dot_dot_equ_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal DotDotEquTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DotDotEquTerm {
    pub dot_dot_equ_term: crate::veryl_token::Token, /* ..= */
}

///
/// Type derived for non-terminal DotDotEquToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DotDotEquToken {
    pub dot_dot_equ_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal DotDotTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DotDotTerm {
    pub dot_dot_term: crate::veryl_token::Token, /* .. */
}

///
/// Type derived for non-terminal DotDotToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DotDotToken {
    pub dot_dot_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal DotTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DotTerm {
    pub dot_term: crate::veryl_token::Token, /* . */
}

///
/// Type derived for non-terminal DotToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DotToken {
    pub dot_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Else
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Else {
    pub else_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ElseTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElseTerm {
    pub else_term: crate::veryl_token::Token, /* (?-u:\b)else(?-u:\b) */
}

///
/// Type derived for non-terminal ElseToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElseToken {
    pub else_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Enum
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Enum {
    pub enum_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal EnumDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EnumDeclaration {
    pub r#enum: Box<Enum>,
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub scalar_type: Box<ScalarType>,
    pub l_brace: Box<LBrace>,
    pub enum_list: Box<EnumList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal EnumGroup
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EnumGroup {
    pub enum_group_list: Vec<EnumGroupList>,
    pub enum_group_group: Box<EnumGroupGroup>,
}

///
/// Type derived for non-terminal EnumGroupGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum EnumGroupGroup {
    LBraceEnumListRBrace(EnumGroupGroupLBraceEnumListRBrace),
    EnumItem(EnumGroupGroupEnumItem),
}

///
/// Type derived for non-terminal EnumGroupList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EnumGroupList {
    pub attribute: Box<Attribute>,
}

///
/// Type derived for non-terminal EnumItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EnumItem {
    pub identifier: Box<Identifier>,
    pub enum_item_opt: Option<Box<EnumItemOpt>>,
}

///
/// Type derived for non-terminal EnumItemOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EnumItemOpt {
    pub equ: Box<Equ>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal EnumList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EnumList {
    pub enum_group: Box<EnumGroup>,
    pub enum_list_list: Vec<EnumListList>,
    pub enum_list_opt: Option<Box<EnumListOpt>>,
}

///
/// Type derived for non-terminal EnumListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EnumListList {
    pub comma: Box<Comma>,
    pub enum_group: Box<EnumGroup>,
}

///
/// Type derived for non-terminal EnumListOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EnumListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal EnumTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EnumTerm {
    pub enum_term: crate::veryl_token::Token, /* (?-u:\b)enum(?-u:\b) */
}

///
/// Type derived for non-terminal EnumToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EnumToken {
    pub enum_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Equ
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Equ {
    pub equ_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal EquTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EquTerm {
    pub equ_term: crate::veryl_token::Token, /* = */
}

///
/// Type derived for non-terminal EquToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EquToken {
    pub equ_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Exponent
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Exponent {
    pub exponent_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ExponentTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExponentTerm {
    pub exponent_term: crate::veryl_token::Token, /* [0-9]+(?:_[0-9]+)*\.[0-9]+(?:_[0-9]+)*[eE][+-]?[0-9]+(?:_[0-9]+)* */
}

///
/// Type derived for non-terminal ExponentToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExponentToken {
    pub exponent_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Export
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Export {
    pub export_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ExportDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExportDeclaration {
    pub export: Box<Export>,
    pub export_declaration_group: Box<ExportDeclarationGroup>,
    pub colon_colon: Box<ColonColon>,
    pub export_declaration_group0: Box<ExportDeclarationGroup0>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal ExportDeclarationGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ExportDeclarationGroup {
    Identifier(ExportDeclarationGroupIdentifier),
    Star(ExportDeclarationGroupStar),
}

///
/// Type derived for non-terminal ExportDeclarationGroup0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ExportDeclarationGroup0 {
    Identifier(ExportDeclarationGroup0Identifier),
    Star(ExportDeclarationGroup0Star),
}

///
/// Type derived for non-terminal ExportTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExportTerm {
    pub export_term: crate::veryl_token::Token, /* (?-u:\b)export(?-u:\b) */
}

///
/// Type derived for non-terminal ExportToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExportToken {
    pub export_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Expression
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression {
    pub expression01: Box<Expression01>,
    pub expression_list: Vec<ExpressionList>,
}

///
/// Type derived for non-terminal Expression01
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression01 {
    pub expression02: Box<Expression02>,
    pub expression01_list: Vec<Expression01List>,
}

///
/// Type derived for non-terminal Expression01List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression01List {
    pub operator02: Box<Operator02>,
    pub expression02: Box<Expression02>,
}

///
/// Type derived for non-terminal Expression02
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression02 {
    pub expression03: Box<Expression03>,
    pub expression02_list: Vec<Expression02List>,
}

///
/// Type derived for non-terminal Expression02List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression02List {
    pub operator03: Box<Operator03>,
    pub expression03: Box<Expression03>,
}

///
/// Type derived for non-terminal Expression03
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression03 {
    pub expression04: Box<Expression04>,
    pub expression03_list: Vec<Expression03List>,
}

///
/// Type derived for non-terminal Expression03List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression03List {
    pub operator04: Box<Operator04>,
    pub expression04: Box<Expression04>,
}

///
/// Type derived for non-terminal Expression04
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression04 {
    pub expression05: Box<Expression05>,
    pub expression04_list: Vec<Expression04List>,
}

///
/// Type derived for non-terminal Expression04List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression04List {
    pub operator05: Box<Operator05>,
    pub expression05: Box<Expression05>,
}

///
/// Type derived for non-terminal Expression05
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression05 {
    pub expression06: Box<Expression06>,
    pub expression05_list: Vec<Expression05List>,
}

///
/// Type derived for non-terminal Expression05List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression05List {
    pub operator06: Box<Operator06>,
    pub expression06: Box<Expression06>,
}

///
/// Type derived for non-terminal Expression06
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression06 {
    pub expression07: Box<Expression07>,
    pub expression06_list: Vec<Expression06List>,
}

///
/// Type derived for non-terminal Expression06List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression06List {
    pub operator07: Box<Operator07>,
    pub expression07: Box<Expression07>,
}

///
/// Type derived for non-terminal Expression07
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression07 {
    pub expression08: Box<Expression08>,
    pub expression07_list: Vec<Expression07List>,
}

///
/// Type derived for non-terminal Expression07List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression07List {
    pub operator08: Box<Operator08>,
    pub expression08: Box<Expression08>,
}

///
/// Type derived for non-terminal Expression08
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression08 {
    pub expression09: Box<Expression09>,
    pub expression08_list: Vec<Expression08List>,
}

///
/// Type derived for non-terminal Expression08List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression08List {
    pub operator09: Box<Operator09>,
    pub expression09: Box<Expression09>,
}

///
/// Type derived for non-terminal Expression09
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression09 {
    pub expression10: Box<Expression10>,
    pub expression09_list: Vec<Expression09List>,
}

///
/// Type derived for non-terminal Expression09List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression09List {
    pub expression09_list_group: Box<Expression09ListGroup>,
    pub expression10: Box<Expression10>,
}

///
/// Type derived for non-terminal Expression09ListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Expression09ListGroup {
    Operator10(Expression09ListGroupOperator10),
    Star(Expression09ListGroupStar),
}

///
/// Type derived for non-terminal Expression10
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression10 {
    pub expression11: Box<Expression11>,
    pub expression10_list: Vec<Expression10List>,
}

///
/// Type derived for non-terminal Expression10List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression10List {
    pub operator11: Box<Operator11>,
    pub expression11: Box<Expression11>,
}

///
/// Type derived for non-terminal Expression11
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression11 {
    pub expression12: Box<Expression12>,
    pub expression11_list: Vec<Expression11List>,
}

///
/// Type derived for non-terminal Expression11List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression11List {
    pub r#as: Box<As>,
    pub scoped_identifier: Box<ScopedIdentifier>,
}

///
/// Type derived for non-terminal Expression12
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression12 {
    pub expression12_list: Vec<Expression12List>,
    pub factor: Box<Factor>,
}

///
/// Type derived for non-terminal Expression12List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression12List {
    pub expression12_list_group: Box<Expression12ListGroup>,
}

///
/// Type derived for non-terminal Expression12ListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Expression12ListGroup {
    UnaryOperator(Expression12ListGroupUnaryOperator),
    Operator09(Expression12ListGroupOperator09),
    Operator05(Expression12ListGroupOperator05),
    Operator03(Expression12ListGroupOperator03),
    Operator04(Expression12ListGroupOperator04),
}

///
/// Type derived for non-terminal ExpressionIdentifier
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExpressionIdentifier {
    pub expression_identifier_opt: Option<Box<ExpressionIdentifierOpt>>,
    pub identifier: Box<Identifier>,
    pub expression_identifier_group: Box<ExpressionIdentifierGroup>,
}

///
/// Type derived for non-terminal ExpressionIdentifierGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ExpressionIdentifierGroup {
    ColonColonIdentifierExpressionIdentifierGroupListExpressionIdentifierGroupList0(ExpressionIdentifierGroupColonColonIdentifierExpressionIdentifierGroupListExpressionIdentifierGroupList0),
    ExpressionIdentifierGroupList1ExpressionIdentifierGroupList2(ExpressionIdentifierGroupExpressionIdentifierGroupList1ExpressionIdentifierGroupList2),
 }

///
/// Type derived for non-terminal ExpressionIdentifierGroupList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExpressionIdentifierGroupList {
    pub colon_colon: Box<ColonColon>,
    pub identifier: Box<Identifier>,
}

///
/// Type derived for non-terminal ExpressionIdentifierGroupList0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExpressionIdentifierGroupList0 {
    pub select: Box<Select>,
}

///
/// Type derived for non-terminal ExpressionIdentifierGroupList1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExpressionIdentifierGroupList1 {
    pub select: Box<Select>,
}

///
/// Type derived for non-terminal ExpressionIdentifierGroupList2
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExpressionIdentifierGroupList2 {
    pub dot: Box<Dot>,
    pub identifier: Box<Identifier>,
    pub expression_identifier_group_list2_list: Vec<ExpressionIdentifierGroupList2List>,
}

///
/// Type derived for non-terminal ExpressionIdentifierGroupList2List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExpressionIdentifierGroupList2List {
    pub select: Box<Select>,
}

///
/// Type derived for non-terminal ExpressionIdentifierOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExpressionIdentifierOpt {
    pub dollar: Box<Dollar>,
}

///
/// Type derived for non-terminal ExpressionList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExpressionList {
    pub operator01: Box<Operator01>,
    pub expression01: Box<Expression01>,
}

///
/// Type derived for non-terminal F32
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct F32 {
    pub f32_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal F32Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct F32Term {
    pub f32_term: crate::veryl_token::Token, /* (?-u:\b)f32(?-u:\b) */
}

///
/// Type derived for non-terminal F32Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct F32Token {
    pub f32_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal F64
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct F64 {
    pub f64_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal F64Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct F64Term {
    pub f64_term: crate::veryl_token::Token, /* (?-u:\b)f64(?-u:\b) */
}

///
/// Type derived for non-terminal F64Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct F64Token {
    pub f64_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Factor
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Factor {
    Number(FactorNumber),
    ExpressionIdentifierFactorOpt(FactorExpressionIdentifierFactorOpt),
    LParenExpressionRParen(FactorLParenExpressionRParen),
    LBraceConcatenationListRBrace(FactorLBraceConcatenationListRBrace),
    IfExpression(FactorIfExpression),
    CaseExpression(FactorCaseExpression),
    StringLiteral(FactorStringLiteral),
    FactorGroup(FactorFactorGroup),
    InsideExpression(FactorInsideExpression),
    OutsideExpression(FactorOutsideExpression),
}

///
/// Type derived for non-terminal FactorGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum FactorGroup {
    Msb(FactorGroupMsb),
    Lsb(FactorGroupLsb),
}

///
/// Type derived for non-terminal FactorOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorOpt {
    pub function_call: Box<FunctionCall>,
}

///
/// Type derived for non-terminal Final
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Final {
    pub final_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal FinalDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FinalDeclaration {
    pub r#final: Box<Final>,
    pub l_brace: Box<LBrace>,
    pub final_declaration_list: Vec<FinalDeclarationList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal FinalDeclarationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FinalDeclarationList {
    pub statement: Box<Statement>,
}

///
/// Type derived for non-terminal FinalTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FinalTerm {
    pub final_term: crate::veryl_token::Token, /* (?-u:\b)final(?-u:\b) */
}

///
/// Type derived for non-terminal FinalToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FinalToken {
    pub final_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal FixedPoint
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FixedPoint {
    pub fixed_point_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal FixedPointTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FixedPointTerm {
    pub fixed_point_term: crate::veryl_token::Token, /* [0-9]+(?:_[0-9]+)*\.[0-9]+(?:_[0-9]+)* */
}

///
/// Type derived for non-terminal FixedPointToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FixedPointToken {
    pub fixed_point_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal FixedType
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum FixedType {
    U32(FixedTypeU32),
    U64(FixedTypeU64),
    I32(FixedTypeI32),
    I64(FixedTypeI64),
    F32(FixedTypeF32),
    F64(FixedTypeF64),
    Strin(FixedTypeStrin),
}

///
/// Type derived for non-terminal For
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct For {
    pub for_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ForStatement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ForStatement {
    pub r#for: Box<For>,
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub scalar_type: Box<ScalarType>,
    pub r#in: Box<In>,
    pub range: Box<Range>,
    pub for_statement_opt: Option<Box<ForStatementOpt>>,
    pub l_brace: Box<LBrace>,
    pub for_statement_list: Vec<ForStatementList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal ForStatementList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ForStatementList {
    pub statement: Box<Statement>,
}

///
/// Type derived for non-terminal ForStatementOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ForStatementOpt {
    pub step: Box<Step>,
    pub assignment_operator: Box<AssignmentOperator>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal ForTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ForTerm {
    pub for_term: crate::veryl_token::Token, /* (?-u:\b)for(?-u:\b) */
}

///
/// Type derived for non-terminal ForToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ForToken {
    pub for_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Function
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Function {
    pub function_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal FunctionCall
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionCall {
    pub l_paren: Box<LParen>,
    pub function_call_opt: Option<Box<FunctionCallOpt>>,
    pub r_paren: Box<RParen>,
}

///
/// Type derived for non-terminal FunctionCallOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionCallOpt {
    pub argument_list: Box<ArgumentList>,
}

///
/// Type derived for non-terminal FunctionDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionDeclaration {
    pub function: Box<Function>,
    pub identifier: Box<Identifier>,
    pub function_declaration_opt: Option<Box<FunctionDeclarationOpt>>,
    pub function_declaration_opt0: Option<Box<FunctionDeclarationOpt0>>,
    pub minus_g_t: Box<MinusGT>,
    pub scalar_type: Box<ScalarType>,
    pub l_brace: Box<LBrace>,
    pub function_declaration_list: Vec<FunctionDeclarationList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal FunctionDeclarationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionDeclarationList {
    pub function_item: Box<FunctionItem>,
}

///
/// Type derived for non-terminal FunctionDeclarationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionDeclarationOpt {
    pub with_parameter: Box<WithParameter>,
}

///
/// Type derived for non-terminal FunctionDeclarationOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionDeclarationOpt0 {
    pub port_declaration: Box<PortDeclaration>,
}

///
/// Type derived for non-terminal FunctionItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum FunctionItem {
    VarDeclaration(FunctionItemVarDeclaration),
    Statement(FunctionItemStatement),
}

///
/// Type derived for non-terminal FunctionTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionTerm {
    pub function_term: crate::veryl_token::Token, /* (?-u:\b)function(?-u:\b) */
}

///
/// Type derived for non-terminal FunctionToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionToken {
    pub function_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Hash
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Hash {
    pub hash_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal HashTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct HashTerm {
    pub hash_term: crate::veryl_token::Token, /* # */
}

///
/// Type derived for non-terminal HashToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct HashToken {
    pub hash_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal HierarchicalIdentifier
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct HierarchicalIdentifier {
    pub identifier: Box<Identifier>,
    pub hierarchical_identifier_list: Vec<HierarchicalIdentifierList>,
    pub hierarchical_identifier_list0: Vec<HierarchicalIdentifierList0>,
}

///
/// Type derived for non-terminal HierarchicalIdentifierList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct HierarchicalIdentifierList {
    pub select: Box<Select>,
}

///
/// Type derived for non-terminal HierarchicalIdentifierList0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct HierarchicalIdentifierList0 {
    pub dot: Box<Dot>,
    pub identifier: Box<Identifier>,
    pub hierarchical_identifier_list0_list: Vec<HierarchicalIdentifierList0List>,
}

///
/// Type derived for non-terminal HierarchicalIdentifierList0List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct HierarchicalIdentifierList0List {
    pub select: Box<Select>,
}

///
/// Type derived for non-terminal I32
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct I32 {
    pub i32_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal I32Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct I32Term {
    pub i32_term: crate::veryl_token::Token, /* (?-u:\b)i32(?-u:\b) */
}

///
/// Type derived for non-terminal I32Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct I32Token {
    pub i32_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal I64
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct I64 {
    pub i64_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal I64Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct I64Term {
    pub i64_term: crate::veryl_token::Token, /* (?-u:\b)i64(?-u:\b) */
}

///
/// Type derived for non-terminal I64Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct I64Token {
    pub i64_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Identifier
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Identifier {
    pub identifier_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal IdentifierStatement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IdentifierStatement {
    pub expression_identifier: Box<ExpressionIdentifier>,
    pub identifier_statement_group: Box<IdentifierStatementGroup>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal IdentifierStatementGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum IdentifierStatementGroup {
    FunctionCall(IdentifierStatementGroupFunctionCall),
    Assignment(IdentifierStatementGroupAssignment),
}

///
/// Type derived for non-terminal IdentifierTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IdentifierTerm {
    pub identifier_term: crate::veryl_token::Token, /* [a-zA-Z_][0-9a-zA-Z_]* */
}

///
/// Type derived for non-terminal IdentifierToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IdentifierToken {
    pub identifier_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal If
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct If {
    pub if_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal IfExpression
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfExpression {
    pub r#if: Box<If>,
    pub expression: Box<Expression>,
    pub l_brace: Box<LBrace>,
    pub expression0: Box<Expression>,
    pub r_brace: Box<RBrace>,
    pub if_expression_list: Vec<IfExpressionList>,
    pub r#else: Box<Else>,
    pub l_brace0: Box<LBrace>,
    pub expression1: Box<Expression>,
    pub r_brace0: Box<RBrace>,
}

///
/// Type derived for non-terminal IfExpressionList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfExpressionList {
    pub r#else: Box<Else>,
    pub r#if: Box<If>,
    pub expression: Box<Expression>,
    pub l_brace: Box<LBrace>,
    pub expression0: Box<Expression>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal IfReset
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfReset {
    pub if_reset_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal IfResetStatement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfResetStatement {
    pub if_reset: Box<IfReset>,
    pub l_brace: Box<LBrace>,
    pub if_reset_statement_list: Vec<IfResetStatementList>,
    pub r_brace: Box<RBrace>,
    pub if_reset_statement_list0: Vec<IfResetStatementList0>,
    pub if_reset_statement_opt: Option<Box<IfResetStatementOpt>>,
}

///
/// Type derived for non-terminal IfResetStatementList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfResetStatementList {
    pub statement: Box<Statement>,
}

///
/// Type derived for non-terminal IfResetStatementList0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfResetStatementList0 {
    pub r#else: Box<Else>,
    pub r#if: Box<If>,
    pub expression: Box<Expression>,
    pub l_brace: Box<LBrace>,
    pub if_reset_statement_list0_list: Vec<IfResetStatementList0List>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal IfResetStatementList0List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfResetStatementList0List {
    pub statement: Box<Statement>,
}

///
/// Type derived for non-terminal IfResetStatementOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfResetStatementOpt {
    pub r#else: Box<Else>,
    pub l_brace: Box<LBrace>,
    pub if_reset_statement_opt_list: Vec<IfResetStatementOptList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal IfResetStatementOptList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfResetStatementOptList {
    pub statement: Box<Statement>,
}

///
/// Type derived for non-terminal IfResetTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfResetTerm {
    pub if_reset_term: crate::veryl_token::Token, /* (?-u:\b)if_reset(?-u:\b) */
}

///
/// Type derived for non-terminal IfResetToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfResetToken {
    pub if_reset_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal IfStatement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfStatement {
    pub r#if: Box<If>,
    pub expression: Box<Expression>,
    pub l_brace: Box<LBrace>,
    pub if_statement_list: Vec<IfStatementList>,
    pub r_brace: Box<RBrace>,
    pub if_statement_list0: Vec<IfStatementList0>,
    pub if_statement_opt: Option<Box<IfStatementOpt>>,
}

///
/// Type derived for non-terminal IfStatementList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfStatementList {
    pub statement: Box<Statement>,
}

///
/// Type derived for non-terminal IfStatementList0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfStatementList0 {
    pub r#else: Box<Else>,
    pub r#if: Box<If>,
    pub expression: Box<Expression>,
    pub l_brace: Box<LBrace>,
    pub if_statement_list0_list: Vec<IfStatementList0List>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal IfStatementList0List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfStatementList0List {
    pub statement: Box<Statement>,
}

///
/// Type derived for non-terminal IfStatementOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfStatementOpt {
    pub r#else: Box<Else>,
    pub l_brace: Box<LBrace>,
    pub if_statement_opt_list: Vec<IfStatementOptList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal IfStatementOptList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfStatementOptList {
    pub statement: Box<Statement>,
}

///
/// Type derived for non-terminal IfTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfTerm {
    pub if_term: crate::veryl_token::Token, /* (?-u:\b)if(?-u:\b) */
}

///
/// Type derived for non-terminal IfToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfToken {
    pub if_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Import
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Import {
    pub import_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ImportDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ImportDeclaration {
    pub import: Box<Import>,
    pub identifier: Box<Identifier>,
    pub colon_colon: Box<ColonColon>,
    pub import_declaration_group: Box<ImportDeclarationGroup>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal ImportDeclarationGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ImportDeclarationGroup {
    Identifier(ImportDeclarationGroupIdentifier),
    Star(ImportDeclarationGroupStar),
}

///
/// Type derived for non-terminal ImportTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ImportTerm {
    pub import_term: crate::veryl_token::Token, /* (?-u:\b)import(?-u:\b) */
}

///
/// Type derived for non-terminal ImportToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ImportToken {
    pub import_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal In
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct In {
    pub in_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal InTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InTerm {
    pub in_term: crate::veryl_token::Token, /* (?-u:\b)in(?-u:\b) */
}

///
/// Type derived for non-terminal InToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InToken {
    pub in_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Initial
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Initial {
    pub initial_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal InitialDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InitialDeclaration {
    pub initial: Box<Initial>,
    pub l_brace: Box<LBrace>,
    pub initial_declaration_list: Vec<InitialDeclarationList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal InitialDeclarationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InitialDeclarationList {
    pub initial_item: Box<InitialItem>,
}

///
/// Type derived for non-terminal InitialItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum InitialItem {
    Statement(InitialItemStatement),
    Assignment(InitialItemAssignment),
}

///
/// Type derived for non-terminal InitialTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InitialTerm {
    pub initial_term: crate::veryl_token::Token, /* (?-u:\b)initial(?-u:\b) */
}

///
/// Type derived for non-terminal InitialToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InitialToken {
    pub initial_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Inout
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Inout {
    pub inout_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal InoutTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InoutTerm {
    pub inout_term: crate::veryl_token::Token, /* (?-u:\b)inout(?-u:\b) */
}

///
/// Type derived for non-terminal InoutToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InoutToken {
    pub inout_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Input
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Input {
    pub input_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal InputTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InputTerm {
    pub input_term: crate::veryl_token::Token, /* (?-u:\b)input(?-u:\b) */
}

///
/// Type derived for non-terminal InputToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InputToken {
    pub input_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Inside
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Inside {
    pub inside_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal InsideExpression
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InsideExpression {
    pub inside: Box<Inside>,
    pub expression: Box<Expression>,
    pub l_brace: Box<LBrace>,
    pub range_list: Box<RangeList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal InsideTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InsideTerm {
    pub inside_term: crate::veryl_token::Token, /* (?-u:\b)inside(?-u:\b) */
}

///
/// Type derived for non-terminal InsideToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InsideToken {
    pub inside_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Inst
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Inst {
    pub inst_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal InstDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstDeclaration {
    pub inst: Box<Inst>,
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub scoped_identifier: Box<ScopedIdentifier>,
    pub inst_declaration_opt: Option<Box<InstDeclarationOpt>>,
    pub inst_declaration_opt0: Option<Box<InstDeclarationOpt0>>,
    pub inst_declaration_opt1: Option<Box<InstDeclarationOpt1>>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal InstDeclarationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstDeclarationOpt {
    pub array: Box<Array>,
}

///
/// Type derived for non-terminal InstDeclarationOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstDeclarationOpt0 {
    pub inst_parameter: Box<InstParameter>,
}

///
/// Type derived for non-terminal InstDeclarationOpt1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstDeclarationOpt1 {
    pub l_paren: Box<LParen>,
    pub inst_declaration_opt2: Option<Box<InstDeclarationOpt2>>,
    pub r_paren: Box<RParen>,
}

///
/// Type derived for non-terminal InstDeclarationOpt2
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstDeclarationOpt2 {
    pub inst_port_list: Box<InstPortList>,
}

///
/// Type derived for non-terminal InstParameter
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstParameter {
    pub hash: Box<Hash>,
    pub l_paren: Box<LParen>,
    pub inst_parameter_opt: Option<Box<InstParameterOpt>>,
    pub r_paren: Box<RParen>,
}

///
/// Type derived for non-terminal InstParameterGroup
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstParameterGroup {
    pub inst_parameter_group_list: Vec<InstParameterGroupList>,
    pub inst_parameter_group_group: Box<InstParameterGroupGroup>,
}

///
/// Type derived for non-terminal InstParameterGroupGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum InstParameterGroupGroup {
    LBraceInstParameterListRBrace(InstParameterGroupGroupLBraceInstParameterListRBrace),
    InstParameterItem(InstParameterGroupGroupInstParameterItem),
}

///
/// Type derived for non-terminal InstParameterGroupList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstParameterGroupList {
    pub attribute: Box<Attribute>,
}

///
/// Type derived for non-terminal InstParameterItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstParameterItem {
    pub identifier: Box<Identifier>,
    pub inst_parameter_item_opt: Option<Box<InstParameterItemOpt>>,
}

///
/// Type derived for non-terminal InstParameterItemOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstParameterItemOpt {
    pub colon: Box<Colon>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal InstParameterList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstParameterList {
    pub inst_parameter_group: Box<InstParameterGroup>,
    pub inst_parameter_list_list: Vec<InstParameterListList>,
    pub inst_parameter_list_opt: Option<Box<InstParameterListOpt>>,
}

///
/// Type derived for non-terminal InstParameterListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstParameterListList {
    pub comma: Box<Comma>,
    pub inst_parameter_group: Box<InstParameterGroup>,
}

///
/// Type derived for non-terminal InstParameterListOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstParameterListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal InstParameterOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstParameterOpt {
    pub inst_parameter_list: Box<InstParameterList>,
}

///
/// Type derived for non-terminal InstPortGroup
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstPortGroup {
    pub inst_port_group_list: Vec<InstPortGroupList>,
    pub inst_port_group_group: Box<InstPortGroupGroup>,
}

///
/// Type derived for non-terminal InstPortGroupGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum InstPortGroupGroup {
    LBraceInstPortListRBrace(InstPortGroupGroupLBraceInstPortListRBrace),
    InstPortItem(InstPortGroupGroupInstPortItem),
}

///
/// Type derived for non-terminal InstPortGroupList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstPortGroupList {
    pub attribute: Box<Attribute>,
}

///
/// Type derived for non-terminal InstPortItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstPortItem {
    pub identifier: Box<Identifier>,
    pub inst_port_item_opt: Option<Box<InstPortItemOpt>>,
}

///
/// Type derived for non-terminal InstPortItemOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstPortItemOpt {
    pub colon: Box<Colon>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal InstPortList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstPortList {
    pub inst_port_group: Box<InstPortGroup>,
    pub inst_port_list_list: Vec<InstPortListList>,
    pub inst_port_list_opt: Option<Box<InstPortListOpt>>,
}

///
/// Type derived for non-terminal InstPortListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstPortListList {
    pub comma: Box<Comma>,
    pub inst_port_group: Box<InstPortGroup>,
}

///
/// Type derived for non-terminal InstPortListOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstPortListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal InstTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstTerm {
    pub inst_term: crate::veryl_token::Token, /* (?-u:\b)inst(?-u:\b) */
}

///
/// Type derived for non-terminal InstToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstToken {
    pub inst_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal IntegralNumber
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum IntegralNumber {
    Based(IntegralNumberBased),
    BaseLess(IntegralNumberBaseLess),
    AllBit(IntegralNumberAllBit),
}

///
/// Type derived for non-terminal Interface
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Interface {
    pub interface_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal InterfaceDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceDeclaration {
    pub interface: Box<Interface>,
    pub identifier: Box<Identifier>,
    pub interface_declaration_opt: Option<Box<InterfaceDeclarationOpt>>,
    pub l_brace: Box<LBrace>,
    pub interface_declaration_list: Vec<InterfaceDeclarationList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal InterfaceDeclarationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceDeclarationList {
    pub interface_group: Box<InterfaceGroup>,
}

///
/// Type derived for non-terminal InterfaceDeclarationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceDeclarationOpt {
    pub with_parameter: Box<WithParameter>,
}

///
/// Type derived for non-terminal InterfaceForDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceForDeclaration {
    pub r#for: Box<For>,
    pub identifier: Box<Identifier>,
    pub r#in: Box<In>,
    pub range: Box<Range>,
    pub interface_for_declaration_opt: Option<Box<InterfaceForDeclarationOpt>>,
    pub interface_named_block: Box<InterfaceNamedBlock>,
}

///
/// Type derived for non-terminal InterfaceForDeclarationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceForDeclarationOpt {
    pub step: Box<Step>,
    pub assignment_operator: Box<AssignmentOperator>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal InterfaceGroup
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceGroup {
    pub interface_group_list: Vec<InterfaceGroupList>,
    pub interface_group_group: Box<InterfaceGroupGroup>,
}

///
/// Type derived for non-terminal InterfaceGroupGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum InterfaceGroupGroup {
    LBraceInterfaceGroupGroupListRBrace(InterfaceGroupGroupLBraceInterfaceGroupGroupListRBrace),
    InterfaceItem(InterfaceGroupGroupInterfaceItem),
}

///
/// Type derived for non-terminal InterfaceGroupGroupList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceGroupGroupList {
    pub interface_group: Box<InterfaceGroup>,
}

///
/// Type derived for non-terminal InterfaceGroupList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceGroupList {
    pub attribute: Box<Attribute>,
}

///
/// Type derived for non-terminal InterfaceIfDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceIfDeclaration {
    pub r#if: Box<If>,
    pub expression: Box<Expression>,
    pub interface_named_block: Box<InterfaceNamedBlock>,
    pub interface_if_declaration_list: Vec<InterfaceIfDeclarationList>,
    pub interface_if_declaration_opt: Option<Box<InterfaceIfDeclarationOpt>>,
}

///
/// Type derived for non-terminal InterfaceIfDeclarationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceIfDeclarationList {
    pub r#else: Box<Else>,
    pub r#if: Box<If>,
    pub expression: Box<Expression>,
    pub interface_optional_named_block: Box<InterfaceOptionalNamedBlock>,
}

///
/// Type derived for non-terminal InterfaceIfDeclarationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceIfDeclarationOpt {
    pub r#else: Box<Else>,
    pub interface_optional_named_block: Box<InterfaceOptionalNamedBlock>,
}

///
/// Type derived for non-terminal InterfaceItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum InterfaceItem {
    VarDeclaration(InterfaceItemVarDeclaration),
    LocalparamDeclaration(InterfaceItemLocalparamDeclaration),
    ModportDeclaration(InterfaceItemModportDeclaration),
    InterfaceIfDeclaration(InterfaceItemInterfaceIfDeclaration),
    InterfaceForDeclaration(InterfaceItemInterfaceForDeclaration),
    EnumDeclaration(InterfaceItemEnumDeclaration),
    StructDeclaration(InterfaceItemStructDeclaration),
    InterfaceNamedBlock(InterfaceItemInterfaceNamedBlock),
    FunctionDeclaration(InterfaceItemFunctionDeclaration),
    ImportDeclaration(InterfaceItemImportDeclaration),
    InitialDeclaration(InterfaceItemInitialDeclaration),
    FinalDeclaration(InterfaceItemFinalDeclaration),
}

///
/// Type derived for non-terminal InterfaceNamedBlock
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceNamedBlock {
    pub colon: Box<Colon>,
    pub identifier: Box<Identifier>,
    pub l_brace: Box<LBrace>,
    pub interface_named_block_list: Vec<InterfaceNamedBlockList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal InterfaceNamedBlockList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceNamedBlockList {
    pub interface_group: Box<InterfaceGroup>,
}

///
/// Type derived for non-terminal InterfaceOptionalNamedBlock
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceOptionalNamedBlock {
    pub interface_optional_named_block_opt: Option<Box<InterfaceOptionalNamedBlockOpt>>,
    pub l_brace: Box<LBrace>,
    pub interface_optional_named_block_list: Vec<InterfaceOptionalNamedBlockList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal InterfaceOptionalNamedBlockList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceOptionalNamedBlockList {
    pub interface_group: Box<InterfaceGroup>,
}

///
/// Type derived for non-terminal InterfaceOptionalNamedBlockOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceOptionalNamedBlockOpt {
    pub colon: Box<Colon>,
    pub identifier: Box<Identifier>,
}

///
/// Type derived for non-terminal InterfaceTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceTerm {
    pub interface_term: crate::veryl_token::Token, /* (?-u:\b)interface(?-u:\b) */
}

///
/// Type derived for non-terminal InterfaceToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceToken {
    pub interface_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal LAngle
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LAngle {
    pub l_angle_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal LAngleTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LAngleTerm {
    pub l_angle_term: crate::veryl_token::Token, /* < */
}

///
/// Type derived for non-terminal LAngleToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LAngleToken {
    pub l_angle_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal LBrace
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LBrace {
    pub l_brace_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal LBraceTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LBraceTerm {
    pub l_brace_term: crate::veryl_token::Token, /* { */
}

///
/// Type derived for non-terminal LBraceToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LBraceToken {
    pub l_brace_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal LBracket
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LBracket {
    pub l_bracket_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal LBracketTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LBracketTerm {
    pub l_bracket_term: crate::veryl_token::Token, /* [ */
}

///
/// Type derived for non-terminal LBracketToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LBracketToken {
    pub l_bracket_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal LParen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LParen {
    pub l_paren_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal LParenTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LParenTerm {
    pub l_paren_term: crate::veryl_token::Token, /* ( */
}

///
/// Type derived for non-terminal LParenToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LParenToken {
    pub l_paren_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Localparam
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Localparam {
    pub localparam_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal LocalparamDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LocalparamDeclaration {
    pub localparam: Box<Localparam>,
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub localparam_declaration_group: Box<LocalparamDeclarationGroup>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal LocalparamDeclarationGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum LocalparamDeclarationGroup {
    ArrayTypeEquExpression(LocalparamDeclarationGroupArrayTypeEquExpression),
    TypeEquTypeExpression(LocalparamDeclarationGroupTypeEquTypeExpression),
}

///
/// Type derived for non-terminal LocalparamTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LocalparamTerm {
    pub localparam_term: crate::veryl_token::Token, /* (?-u:\b)localparam(?-u:\b) */
}

///
/// Type derived for non-terminal LocalparamToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LocalparamToken {
    pub localparam_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Logic
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Logic {
    pub logic_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal LogicTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicTerm {
    pub logic_term: crate::veryl_token::Token, /* (?-u:\b)logic(?-u:\b) */
}

///
/// Type derived for non-terminal LogicToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicToken {
    pub logic_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Lsb
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Lsb {
    pub lsb_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal LsbTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LsbTerm {
    pub lsb_term: crate::veryl_token::Token, /* (?-u:\b)lsb(?-u:\b) */
}

///
/// Type derived for non-terminal LsbToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LsbToken {
    pub lsb_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal MinusColon
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MinusColon {
    pub minus_colon_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal MinusColonTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MinusColonTerm {
    pub minus_colon_term: crate::veryl_token::Token, /* -: */
}

///
/// Type derived for non-terminal MinusColonToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MinusColonToken {
    pub minus_colon_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal MinusGT
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MinusGT {
    pub minus_g_t_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal MinusGTTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MinusGTTerm {
    pub minus_g_t_term: crate::veryl_token::Token, /* -> */
}

///
/// Type derived for non-terminal MinusGTToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MinusGTToken {
    pub minus_g_t_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Modport
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Modport {
    pub modport_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ModportDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModportDeclaration {
    pub modport: Box<Modport>,
    pub identifier: Box<Identifier>,
    pub l_brace: Box<LBrace>,
    pub modport_list: Box<ModportList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal ModportGroup
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModportGroup {
    pub modport_group_list: Vec<ModportGroupList>,
    pub modport_group_group: Box<ModportGroupGroup>,
}

///
/// Type derived for non-terminal ModportGroupGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ModportGroupGroup {
    LBraceModportListRBrace(ModportGroupGroupLBraceModportListRBrace),
    ModportItem(ModportGroupGroupModportItem),
}

///
/// Type derived for non-terminal ModportGroupList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModportGroupList {
    pub attribute: Box<Attribute>,
}

///
/// Type derived for non-terminal ModportItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModportItem {
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub direction: Box<Direction>,
}

///
/// Type derived for non-terminal ModportList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModportList {
    pub modport_group: Box<ModportGroup>,
    pub modport_list_list: Vec<ModportListList>,
    pub modport_list_opt: Option<Box<ModportListOpt>>,
}

///
/// Type derived for non-terminal ModportListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModportListList {
    pub comma: Box<Comma>,
    pub modport_group: Box<ModportGroup>,
}

///
/// Type derived for non-terminal ModportListOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModportListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal ModportTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModportTerm {
    pub modport_term: crate::veryl_token::Token, /* (?-u:\b)modport(?-u:\b) */
}

///
/// Type derived for non-terminal ModportToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModportToken {
    pub modport_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Module
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Module {
    pub module_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ModuleDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleDeclaration {
    pub module: Box<Module>,
    pub identifier: Box<Identifier>,
    pub module_declaration_opt: Option<Box<ModuleDeclarationOpt>>,
    pub module_declaration_opt0: Option<Box<ModuleDeclarationOpt0>>,
    pub l_brace: Box<LBrace>,
    pub module_declaration_list: Vec<ModuleDeclarationList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal ModuleDeclarationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleDeclarationList {
    pub module_group: Box<ModuleGroup>,
}

///
/// Type derived for non-terminal ModuleDeclarationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleDeclarationOpt {
    pub with_parameter: Box<WithParameter>,
}

///
/// Type derived for non-terminal ModuleDeclarationOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleDeclarationOpt0 {
    pub port_declaration: Box<PortDeclaration>,
}

///
/// Type derived for non-terminal ModuleForDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleForDeclaration {
    pub r#for: Box<For>,
    pub identifier: Box<Identifier>,
    pub r#in: Box<In>,
    pub range: Box<Range>,
    pub module_for_declaration_opt: Option<Box<ModuleForDeclarationOpt>>,
    pub module_named_block: Box<ModuleNamedBlock>,
}

///
/// Type derived for non-terminal ModuleForDeclarationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleForDeclarationOpt {
    pub step: Box<Step>,
    pub assignment_operator: Box<AssignmentOperator>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal ModuleGroup
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleGroup {
    pub module_group_list: Vec<ModuleGroupList>,
    pub module_group_group: Box<ModuleGroupGroup>,
}

///
/// Type derived for non-terminal ModuleGroupGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ModuleGroupGroup {
    LBraceModuleGroupGroupListRBrace(ModuleGroupGroupLBraceModuleGroupGroupListRBrace),
    ModuleItem(ModuleGroupGroupModuleItem),
}

///
/// Type derived for non-terminal ModuleGroupGroupList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleGroupGroupList {
    pub module_group: Box<ModuleGroup>,
}

///
/// Type derived for non-terminal ModuleGroupList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleGroupList {
    pub attribute: Box<Attribute>,
}

///
/// Type derived for non-terminal ModuleIfDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleIfDeclaration {
    pub r#if: Box<If>,
    pub expression: Box<Expression>,
    pub module_named_block: Box<ModuleNamedBlock>,
    pub module_if_declaration_list: Vec<ModuleIfDeclarationList>,
    pub module_if_declaration_opt: Option<Box<ModuleIfDeclarationOpt>>,
}

///
/// Type derived for non-terminal ModuleIfDeclarationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleIfDeclarationList {
    pub r#else: Box<Else>,
    pub r#if: Box<If>,
    pub expression: Box<Expression>,
    pub module_optional_named_block: Box<ModuleOptionalNamedBlock>,
}

///
/// Type derived for non-terminal ModuleIfDeclarationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleIfDeclarationOpt {
    pub r#else: Box<Else>,
    pub module_optional_named_block: Box<ModuleOptionalNamedBlock>,
}

///
/// Type derived for non-terminal ModuleItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ModuleItem {
    VarDeclaration(ModuleItemVarDeclaration),
    InstDeclaration(ModuleItemInstDeclaration),
    LocalparamDeclaration(ModuleItemLocalparamDeclaration),
    AlwaysFfDeclaration(ModuleItemAlwaysFfDeclaration),
    AlwaysCombDeclaration(ModuleItemAlwaysCombDeclaration),
    AssignDeclaration(ModuleItemAssignDeclaration),
    FunctionDeclaration(ModuleItemFunctionDeclaration),
    ModuleIfDeclaration(ModuleItemModuleIfDeclaration),
    ModuleForDeclaration(ModuleItemModuleForDeclaration),
    EnumDeclaration(ModuleItemEnumDeclaration),
    StructDeclaration(ModuleItemStructDeclaration),
    ModuleNamedBlock(ModuleItemModuleNamedBlock),
    ImportDeclaration(ModuleItemImportDeclaration),
    InitialDeclaration(ModuleItemInitialDeclaration),
    FinalDeclaration(ModuleItemFinalDeclaration),
}

///
/// Type derived for non-terminal ModuleNamedBlock
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleNamedBlock {
    pub colon: Box<Colon>,
    pub identifier: Box<Identifier>,
    pub l_brace: Box<LBrace>,
    pub module_named_block_list: Vec<ModuleNamedBlockList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal ModuleNamedBlockList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleNamedBlockList {
    pub module_group: Box<ModuleGroup>,
}

///
/// Type derived for non-terminal ModuleOptionalNamedBlock
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleOptionalNamedBlock {
    pub module_optional_named_block_opt: Option<Box<ModuleOptionalNamedBlockOpt>>,
    pub l_brace: Box<LBrace>,
    pub module_optional_named_block_list: Vec<ModuleOptionalNamedBlockList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal ModuleOptionalNamedBlockList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleOptionalNamedBlockList {
    pub module_group: Box<ModuleGroup>,
}

///
/// Type derived for non-terminal ModuleOptionalNamedBlockOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleOptionalNamedBlockOpt {
    pub colon: Box<Colon>,
    pub identifier: Box<Identifier>,
}

///
/// Type derived for non-terminal ModuleTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleTerm {
    pub module_term: crate::veryl_token::Token, /* (?-u:\b)module(?-u:\b) */
}

///
/// Type derived for non-terminal ModuleToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleToken {
    pub module_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Msb
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Msb {
    pub msb_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal MsbTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MsbTerm {
    pub msb_term: crate::veryl_token::Token, /* (?-u:\b)msb(?-u:\b) */
}

///
/// Type derived for non-terminal MsbToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MsbToken {
    pub msb_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Negedge
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Negedge {
    pub negedge_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal NegedgeTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NegedgeTerm {
    pub negedge_term: crate::veryl_token::Token, /* (?-u:\b)negedge(?-u:\b) */
}

///
/// Type derived for non-terminal NegedgeToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NegedgeToken {
    pub negedge_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Number
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Number {
    IntegralNumber(NumberIntegralNumber),
    RealNumber(NumberRealNumber),
}

///
/// Type derived for non-terminal Operator01
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator01 {
    pub operator01_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal Operator01Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator01Term {
    pub operator01_term: crate::veryl_token::Token, /* \|\| */
}

///
/// Type derived for non-terminal Operator01Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator01Token {
    pub operator01_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Operator02
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator02 {
    pub operator02_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal Operator02Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator02Term {
    pub operator02_term: crate::veryl_token::Token, /* && */
}

///
/// Type derived for non-terminal Operator02Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator02Token {
    pub operator02_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Operator03
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator03 {
    pub operator03_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal Operator03Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator03Term {
    pub operator03_term: crate::veryl_token::Token, /* \| */
}

///
/// Type derived for non-terminal Operator03Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator03Token {
    pub operator03_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Operator04
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator04 {
    pub operator04_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal Operator04Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator04Term {
    pub operator04_term: crate::veryl_token::Token, /* \^~|\^|~\^ */
}

///
/// Type derived for non-terminal Operator04Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator04Token {
    pub operator04_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Operator05
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator05 {
    pub operator05_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal Operator05Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator05Term {
    pub operator05_term: crate::veryl_token::Token, /* & */
}

///
/// Type derived for non-terminal Operator05Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator05Token {
    pub operator05_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Operator06
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator06 {
    pub operator06_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal Operator06Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator06Term {
    pub operator06_term: crate::veryl_token::Token, /* ===|==\?|!==|!=\?|==|!= */
}

///
/// Type derived for non-terminal Operator06Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator06Token {
    pub operator06_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Operator07
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator07 {
    pub operator07_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal Operator07Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator07Term {
    pub operator07_term: crate::veryl_token::Token, /* <=|>=|<:|>: */
}

///
/// Type derived for non-terminal Operator07Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator07Token {
    pub operator07_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Operator08
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator08 {
    pub operator08_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal Operator08Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator08Term {
    pub operator08_term: crate::veryl_token::Token, /* <<<|>>>|<<|>> */
}

///
/// Type derived for non-terminal Operator08Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator08Token {
    pub operator08_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Operator09
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator09 {
    pub operator09_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal Operator09Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator09Term {
    pub operator09_term: crate::veryl_token::Token, /* \+|- */
}

///
/// Type derived for non-terminal Operator09Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator09Token {
    pub operator09_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Operator10
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator10 {
    pub operator10_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal Operator10Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator10Term {
    pub operator10_term: crate::veryl_token::Token, /* /|% */
}

///
/// Type derived for non-terminal Operator10Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator10Token {
    pub operator10_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Operator11
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator11 {
    pub operator11_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal Operator11Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator11Term {
    pub operator11_term: crate::veryl_token::Token, /* \*\* */
}

///
/// Type derived for non-terminal Operator11Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator11Token {
    pub operator11_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Output
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Output {
    pub output_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal OutputTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OutputTerm {
    pub output_term: crate::veryl_token::Token, /* (?-u:\b)output(?-u:\b) */
}

///
/// Type derived for non-terminal OutputToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OutputToken {
    pub output_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Outside
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Outside {
    pub outside_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal OutsideExpression
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OutsideExpression {
    pub outside: Box<Outside>,
    pub expression: Box<Expression>,
    pub l_brace: Box<LBrace>,
    pub range_list: Box<RangeList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal OutsideTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OutsideTerm {
    pub outside_term: crate::veryl_token::Token, /* (?-u:\b)outside(?-u:\b) */
}

///
/// Type derived for non-terminal OutsideToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OutsideToken {
    pub outside_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Package
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Package {
    pub package_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal PackageDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PackageDeclaration {
    pub package: Box<Package>,
    pub identifier: Box<Identifier>,
    pub l_brace: Box<LBrace>,
    pub package_declaration_list: Vec<PackageDeclarationList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal PackageDeclarationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PackageDeclarationList {
    pub package_group: Box<PackageGroup>,
}

///
/// Type derived for non-terminal PackageGroup
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PackageGroup {
    pub package_group_list: Vec<PackageGroupList>,
    pub package_group_group: Box<PackageGroupGroup>,
}

///
/// Type derived for non-terminal PackageGroupGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum PackageGroupGroup {
    LBracePackageGroupGroupListRBrace(PackageGroupGroupLBracePackageGroupGroupListRBrace),
    PackageItem(PackageGroupGroupPackageItem),
}

///
/// Type derived for non-terminal PackageGroupGroupList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PackageGroupGroupList {
    pub package_group: Box<PackageGroup>,
}

///
/// Type derived for non-terminal PackageGroupList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PackageGroupList {
    pub attribute: Box<Attribute>,
}

///
/// Type derived for non-terminal PackageItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum PackageItem {
    VarDeclaration(PackageItemVarDeclaration),
    LocalparamDeclaration(PackageItemLocalparamDeclaration),
    EnumDeclaration(PackageItemEnumDeclaration),
    StructDeclaration(PackageItemStructDeclaration),
    FunctionDeclaration(PackageItemFunctionDeclaration),
    ImportDeclaration(PackageItemImportDeclaration),
    ExportDeclaration(PackageItemExportDeclaration),
    InitialDeclaration(PackageItemInitialDeclaration),
    FinalDeclaration(PackageItemFinalDeclaration),
}

///
/// Type derived for non-terminal PackageTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PackageTerm {
    pub package_term: crate::veryl_token::Token, /* (?-u:\b)package(?-u:\b) */
}

///
/// Type derived for non-terminal PackageToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PackageToken {
    pub package_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Parameter
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Parameter {
    pub parameter_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ParameterTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ParameterTerm {
    pub parameter_term: crate::veryl_token::Token, /* (?-u:\b)parameter(?-u:\b) */
}

///
/// Type derived for non-terminal ParameterToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ParameterToken {
    pub parameter_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal PlusColon
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PlusColon {
    pub plus_colon_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal PlusColonTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PlusColonTerm {
    pub plus_colon_term: crate::veryl_token::Token, /* +: */
}

///
/// Type derived for non-terminal PlusColonToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PlusColonToken {
    pub plus_colon_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal PortDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PortDeclaration {
    pub l_paren: Box<LParen>,
    pub port_declaration_opt: Option<Box<PortDeclarationOpt>>,
    pub r_paren: Box<RParen>,
}

///
/// Type derived for non-terminal PortDeclarationGroup
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PortDeclarationGroup {
    pub port_declaration_group_list: Vec<PortDeclarationGroupList>,
    pub port_declaration_group_group: Box<PortDeclarationGroupGroup>,
}

///
/// Type derived for non-terminal PortDeclarationGroupGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum PortDeclarationGroupGroup {
    LBracePortDeclarationListRBrace(PortDeclarationGroupGroupLBracePortDeclarationListRBrace),
    PortDeclarationItem(PortDeclarationGroupGroupPortDeclarationItem),
}

///
/// Type derived for non-terminal PortDeclarationGroupList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PortDeclarationGroupList {
    pub attribute: Box<Attribute>,
}

///
/// Type derived for non-terminal PortDeclarationItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PortDeclarationItem {
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub port_declaration_item_group: Box<PortDeclarationItemGroup>,
}

///
/// Type derived for non-terminal PortDeclarationItemGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum PortDeclarationItemGroup {
    DirectionArrayType(PortDeclarationItemGroupDirectionArrayType),
    InterfacePortDeclarationItemOpt(PortDeclarationItemGroupInterfacePortDeclarationItemOpt),
}

///
/// Type derived for non-terminal PortDeclarationItemOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PortDeclarationItemOpt {
    pub array: Box<Array>,
}

///
/// Type derived for non-terminal PortDeclarationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PortDeclarationList {
    pub port_declaration_group: Box<PortDeclarationGroup>,
    pub port_declaration_list_list: Vec<PortDeclarationListList>,
    pub port_declaration_list_opt: Option<Box<PortDeclarationListOpt>>,
}

///
/// Type derived for non-terminal PortDeclarationListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PortDeclarationListList {
    pub comma: Box<Comma>,
    pub port_declaration_group: Box<PortDeclarationGroup>,
}

///
/// Type derived for non-terminal PortDeclarationListOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PortDeclarationListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal PortDeclarationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PortDeclarationOpt {
    pub port_declaration_list: Box<PortDeclarationList>,
}

///
/// Type derived for non-terminal Posedge
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Posedge {
    pub posedge_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal PosedgeTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PosedgeTerm {
    pub posedge_term: crate::veryl_token::Token, /* (?-u:\b)posedge(?-u:\b) */
}

///
/// Type derived for non-terminal PosedgeToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PosedgeToken {
    pub posedge_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal RAngle
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RAngle {
    pub r_angle_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal RAngleTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RAngleTerm {
    pub r_angle_term: crate::veryl_token::Token, /* > */
}

///
/// Type derived for non-terminal RAngleToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RAngleToken {
    pub r_angle_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal RBrace
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RBrace {
    pub r_brace_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal RBraceTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RBraceTerm {
    pub r_brace_term: crate::veryl_token::Token, /* } */
}

///
/// Type derived for non-terminal RBraceToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RBraceToken {
    pub r_brace_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal RBracket
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RBracket {
    pub r_bracket_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal RBracketTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RBracketTerm {
    pub r_bracket_term: crate::veryl_token::Token, /* ] */
}

///
/// Type derived for non-terminal RBracketToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RBracketToken {
    pub r_bracket_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal RParen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RParen {
    pub r_paren_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal RParenTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RParenTerm {
    pub r_paren_term: crate::veryl_token::Token, /* ) */
}

///
/// Type derived for non-terminal RParenToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RParenToken {
    pub r_paren_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Range
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Range {
    pub expression: Box<Expression>,
    pub range_opt: Option<Box<RangeOpt>>,
}

///
/// Type derived for non-terminal RangeItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RangeItem {
    pub range: Box<Range>,
}

///
/// Type derived for non-terminal RangeList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RangeList {
    pub range_item: Box<RangeItem>,
    pub range_list_list: Vec<RangeListList>,
    pub range_list_opt: Option<Box<RangeListOpt>>,
}

///
/// Type derived for non-terminal RangeListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RangeListList {
    pub comma: Box<Comma>,
    pub range_item: Box<RangeItem>,
}

///
/// Type derived for non-terminal RangeListOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RangeListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal RangeOperator
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum RangeOperator {
    DotDot(RangeOperatorDotDot),
    DotDotEqu(RangeOperatorDotDotEqu),
}

///
/// Type derived for non-terminal RangeOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RangeOpt {
    pub range_operator: Box<RangeOperator>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal RealNumber
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum RealNumber {
    FixedPoint(RealNumberFixedPoint),
    Exponent(RealNumberExponent),
}

///
/// Type derived for non-terminal Ref
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Ref {
    pub ref_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal RefTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RefTerm {
    pub ref_term: crate::veryl_token::Token, /* (?-u:\b)ref(?-u:\b) */
}

///
/// Type derived for non-terminal RefToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RefToken {
    pub ref_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Repeat
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Repeat {
    pub repeat_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal RepeatTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RepeatTerm {
    pub repeat_term: crate::veryl_token::Token, /* (?-u:\b)repeat(?-u:\b) */
}

///
/// Type derived for non-terminal RepeatToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RepeatToken {
    pub repeat_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Return
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Return {
    pub return_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ReturnStatement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ReturnStatement {
    pub r#return: Box<Return>,
    pub expression: Box<Expression>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal ReturnTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ReturnTerm {
    pub return_term: crate::veryl_token::Token, /* (?-u:\b)return(?-u:\b) */
}

///
/// Type derived for non-terminal ReturnToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ReturnToken {
    pub return_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal ScalarType
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScalarType {
    pub scalar_type_list: Vec<ScalarTypeList>,
    pub scalar_type_group: Box<ScalarTypeGroup>,
}

///
/// Type derived for non-terminal ScalarTypeGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ScalarTypeGroup {
    VariableType(ScalarTypeGroupVariableType),
    FixedType(ScalarTypeGroupFixedType),
}

///
/// Type derived for non-terminal ScalarTypeList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScalarTypeList {
    pub type_modifier: Box<TypeModifier>,
}

///
/// Type derived for non-terminal ScopedIdentifier
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScopedIdentifier {
    pub identifier: Box<Identifier>,
    pub scoped_identifier_list: Vec<ScopedIdentifierList>,
}

///
/// Type derived for non-terminal ScopedIdentifierList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScopedIdentifierList {
    pub colon_colon: Box<ColonColon>,
    pub identifier: Box<Identifier>,
}

///
/// Type derived for non-terminal Select
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Select {
    pub l_bracket: Box<LBracket>,
    pub expression: Box<Expression>,
    pub select_opt: Option<Box<SelectOpt>>,
    pub r_bracket: Box<RBracket>,
}

///
/// Type derived for non-terminal SelectOperator
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum SelectOperator {
    Colon(SelectOperatorColon),
    PlusColon(SelectOperatorPlusColon),
    MinusColon(SelectOperatorMinusColon),
    Step(SelectOperatorStep),
}

///
/// Type derived for non-terminal SelectOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SelectOpt {
    pub select_operator: Box<SelectOperator>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal Semicolon
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Semicolon {
    pub semicolon_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal SemicolonTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SemicolonTerm {
    pub semicolon_term: crate::veryl_token::Token, /* ; */
}

///
/// Type derived for non-terminal SemicolonToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SemicolonToken {
    pub semicolon_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Signed
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Signed {
    pub signed_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal SignedTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SignedTerm {
    pub signed_term: crate::veryl_token::Token, /* (?-u:\b)signed(?-u:\b) */
}

///
/// Type derived for non-terminal SignedToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SignedToken {
    pub signed_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Star
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Star {
    pub star_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal StarTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StarTerm {
    pub star_term: crate::veryl_token::Token, /* * */
}

///
/// Type derived for non-terminal StarToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StarToken {
    pub star_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Start
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Start {
    pub start_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal StartToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StartToken {
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Statement
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Statement {
    IdentifierStatement(StatementIdentifierStatement),
    IfStatement(StatementIfStatement),
    IfResetStatement(StatementIfResetStatement),
    ReturnStatement(StatementReturnStatement),
    ForStatement(StatementForStatement),
    CaseStatement(StatementCaseStatement),
}

///
/// Type derived for non-terminal Step
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Step {
    pub step_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal StepTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StepTerm {
    pub step_term: crate::veryl_token::Token, /* (?-u:\b)step(?-u:\b) */
}

///
/// Type derived for non-terminal StepToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StepToken {
    pub step_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Strin
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Strin {
    pub string_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal StringLiteral
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StringLiteral {
    pub string_literal_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal StringLiteralTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StringLiteralTerm {
    pub string_literal_term: crate::veryl_token::Token, /* \u{0022}(?:\\[\u{0022}\\/bfnrt]|u[0-9a-fA-F]{4}|[^\u{0022}\\\u0000-\u001F])*\u{0022} */
}

///
/// Type derived for non-terminal StringLiteralToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StringLiteralToken {
    pub string_literal_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal StringTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StringTerm {
    pub string_term: crate::veryl_token::Token, /* (?-u:\b)string(?-u:\b) */
}

///
/// Type derived for non-terminal StringToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StringToken {
    pub string_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Struct
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Struct {
    pub struct_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal StructDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StructDeclaration {
    pub r#struct: Box<Struct>,
    pub identifier: Box<Identifier>,
    pub l_brace: Box<LBrace>,
    pub struct_list: Box<StructList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal StructGroup
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StructGroup {
    pub struct_group_list: Vec<StructGroupList>,
    pub struct_group_group: Box<StructGroupGroup>,
}

///
/// Type derived for non-terminal StructGroupGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum StructGroupGroup {
    LBraceStructListRBrace(StructGroupGroupLBraceStructListRBrace),
    StructItem(StructGroupGroupStructItem),
}

///
/// Type derived for non-terminal StructGroupList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StructGroupList {
    pub attribute: Box<Attribute>,
}

///
/// Type derived for non-terminal StructItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StructItem {
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub scalar_type: Box<ScalarType>,
}

///
/// Type derived for non-terminal StructList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StructList {
    pub struct_group: Box<StructGroup>,
    pub struct_list_list: Vec<StructListList>,
    pub struct_list_opt: Option<Box<StructListOpt>>,
}

///
/// Type derived for non-terminal StructListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StructListList {
    pub comma: Box<Comma>,
    pub struct_group: Box<StructGroup>,
}

///
/// Type derived for non-terminal StructListOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StructListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal StructTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StructTerm {
    pub struct_term: crate::veryl_token::Token, /* (?-u:\b)struct(?-u:\b) */
}

///
/// Type derived for non-terminal StructToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StructToken {
    pub struct_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal SyncHigh
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SyncHigh {
    pub sync_high_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal SyncHighTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SyncHighTerm {
    pub sync_high_term: crate::veryl_token::Token, /* (?-u:\b)sync_high(?-u:\b) */
}

///
/// Type derived for non-terminal SyncHighToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SyncHighToken {
    pub sync_high_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal SyncLow
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SyncLow {
    pub sync_low_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal SyncLowTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SyncLowTerm {
    pub sync_low_term: crate::veryl_token::Token, /* (?-u:\b)sync_low(?-u:\b) */
}

///
/// Type derived for non-terminal SyncLowToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SyncLowToken {
    pub sync_low_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Tri
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Tri {
    pub tri_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal TriTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TriTerm {
    pub tri_term: crate::veryl_token::Token, /* (?-u:\b)tri(?-u:\b) */
}

///
/// Type derived for non-terminal TriToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TriToken {
    pub tri_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Type
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Type {
    pub type_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal TypeExpression
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum TypeExpression {
    ScalarType(TypeExpressionScalarType),
    TypeLParenExpressionRParen(TypeExpressionTypeLParenExpressionRParen),
}

///
/// Type derived for non-terminal TypeModifier
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum TypeModifier {
    Tri(TypeModifierTri),
    Signed(TypeModifierSigned),
}

///
/// Type derived for non-terminal TypeTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypeTerm {
    pub type_term: crate::veryl_token::Token, /* (?-u:\b)type(?-u:\b) */
}

///
/// Type derived for non-terminal TypeToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypeToken {
    pub type_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal U32
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct U32 {
    pub u32_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal U32Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct U32Term {
    pub u32_term: crate::veryl_token::Token, /* (?-u:\b)u32(?-u:\b) */
}

///
/// Type derived for non-terminal U32Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct U32Token {
    pub u32_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal U64
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct U64 {
    pub u64_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal U64Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct U64Term {
    pub u64_term: crate::veryl_token::Token, /* (?-u:\b)u64(?-u:\b) */
}

///
/// Type derived for non-terminal U64Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct U64Token {
    pub u64_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal UnaryOperator
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct UnaryOperator {
    pub unary_operator_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal UnaryOperatorTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct UnaryOperatorTerm {
    pub unary_operator_term: crate::veryl_token::Token, /* ~&|~\||!|~ */
}

///
/// Type derived for non-terminal UnaryOperatorToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct UnaryOperatorToken {
    pub unary_operator_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Var
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Var {
    pub var_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal VarDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct VarDeclaration {
    pub var: Box<Var>,
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub array_type: Box<ArrayType>,
    pub var_declaration_opt: Option<Box<VarDeclarationOpt>>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal VarDeclarationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct VarDeclarationOpt {
    pub equ: Box<Equ>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal VarTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct VarTerm {
    pub var_term: crate::veryl_token::Token, /* (?-u:\b)var(?-u:\b) */
}

///
/// Type derived for non-terminal VarToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct VarToken {
    pub var_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal VariableType
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct VariableType {
    pub variable_type_group: Box<VariableTypeGroup>,
    pub variable_type_opt: Option<Box<VariableTypeOpt>>,
}

///
/// Type derived for non-terminal VariableTypeGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum VariableTypeGroup {
    Logic(VariableTypeGroupLogic),
    Bit(VariableTypeGroupBit),
    ScopedIdentifier(VariableTypeGroupScopedIdentifier),
}

///
/// Type derived for non-terminal VariableTypeOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct VariableTypeOpt {
    pub width: Box<Width>,
}

///
/// Type derived for non-terminal Veryl
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Veryl {
    pub start: Box<Start>,
    pub veryl_list: Vec<VerylList>,
}

///
/// Type derived for non-terminal VerylList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct VerylList {
    pub description_group: Box<DescriptionGroup>,
}

///
/// Type derived for non-terminal Width
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Width {
    pub l_angle: Box<LAngle>,
    pub expression: Box<Expression>,
    pub width_list: Vec<WidthList>,
    pub r_angle: Box<RAngle>,
}

///
/// Type derived for non-terminal WidthList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct WidthList {
    pub comma: Box<Comma>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal WithParameter
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct WithParameter {
    pub hash: Box<Hash>,
    pub l_paren: Box<LParen>,
    pub with_parameter_opt: Option<Box<WithParameterOpt>>,
    pub r_paren: Box<RParen>,
}

///
/// Type derived for non-terminal WithParameterGroup
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct WithParameterGroup {
    pub with_parameter_group_list: Vec<WithParameterGroupList>,
    pub with_parameter_group_group: Box<WithParameterGroupGroup>,
}

///
/// Type derived for non-terminal WithParameterGroupGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum WithParameterGroupGroup {
    LBraceWithParameterListRBrace(WithParameterGroupGroupLBraceWithParameterListRBrace),
    WithParameterItem(WithParameterGroupGroupWithParameterItem),
}

///
/// Type derived for non-terminal WithParameterGroupList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct WithParameterGroupList {
    pub attribute: Box<Attribute>,
}

///
/// Type derived for non-terminal WithParameterItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct WithParameterItem {
    pub with_parameter_item_group: Box<WithParameterItemGroup>,
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub with_parameter_item_group0: Box<WithParameterItemGroup0>,
}

///
/// Type derived for non-terminal WithParameterItemGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum WithParameterItemGroup {
    Parameter(WithParameterItemGroupParameter),
    Localparam(WithParameterItemGroupLocalparam),
}

///
/// Type derived for non-terminal WithParameterItemGroup0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum WithParameterItemGroup0 {
    ArrayTypeEquExpression(WithParameterItemGroup0ArrayTypeEquExpression),
    TypeEquTypeExpression(WithParameterItemGroup0TypeEquTypeExpression),
}

///
/// Type derived for non-terminal WithParameterList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct WithParameterList {
    pub with_parameter_group: Box<WithParameterGroup>,
    pub with_parameter_list_list: Vec<WithParameterListList>,
    pub with_parameter_list_opt: Option<Box<WithParameterListOpt>>,
}

///
/// Type derived for non-terminal WithParameterListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct WithParameterListList {
    pub comma: Box<Comma>,
    pub with_parameter_group: Box<WithParameterGroup>,
}

///
/// Type derived for non-terminal WithParameterListOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct WithParameterListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal WithParameterOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct WithParameterOpt {
    pub with_parameter_list: Box<WithParameterList>,
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType {
    AllBit(AllBit),
    AllBitTerm(AllBitTerm),
    AllBitToken(AllBitToken),
    AlwaysComb(AlwaysComb),
    AlwaysCombDeclaration(AlwaysCombDeclaration),
    AlwaysCombDeclarationList(Vec<AlwaysCombDeclarationList>),
    AlwaysCombTerm(AlwaysCombTerm),
    AlwaysCombToken(AlwaysCombToken),
    AlwaysFf(AlwaysFf),
    AlwaysFfClock(AlwaysFfClock),
    AlwaysFfClockOpt(Option<Box<AlwaysFfClockOpt>>),
    AlwaysFfClockOptGroup(AlwaysFfClockOptGroup),
    AlwaysFfDeclaration(AlwaysFfDeclaration),
    AlwaysFfDeclarationList(Vec<AlwaysFfDeclarationList>),
    AlwaysFfDeclarationOpt(Option<Box<AlwaysFfDeclarationOpt>>),
    AlwaysFfReset(AlwaysFfReset),
    AlwaysFfResetOpt(Option<Box<AlwaysFfResetOpt>>),
    AlwaysFfResetOptGroup(AlwaysFfResetOptGroup),
    AlwaysFfTerm(AlwaysFfTerm),
    AlwaysFfToken(AlwaysFfToken),
    ArgumentItem(ArgumentItem),
    ArgumentList(ArgumentList),
    ArgumentListList(Vec<ArgumentListList>),
    ArgumentListOpt(Option<Box<ArgumentListOpt>>),
    Array(Array),
    ArrayList(Vec<ArrayList>),
    ArrayType(ArrayType),
    ArrayTypeOpt(Option<Box<ArrayTypeOpt>>),
    As(As),
    AsTerm(AsTerm),
    AsToken(AsToken),
    Assign(Assign),
    AssignDeclaration(AssignDeclaration),
    AssignTerm(AssignTerm),
    AssignToken(AssignToken),
    Assignment(Assignment),
    AssignmentGroup(AssignmentGroup),
    AssignmentOperator(AssignmentOperator),
    AssignmentOperatorTerm(AssignmentOperatorTerm),
    AssignmentOperatorToken(AssignmentOperatorToken),
    AsyncHigh(AsyncHigh),
    AsyncHighTerm(AsyncHighTerm),
    AsyncHighToken(AsyncHighToken),
    AsyncLow(AsyncLow),
    AsyncLowTerm(AsyncLowTerm),
    AsyncLowToken(AsyncLowToken),
    Attribute(Attribute),
    AttributeItem(AttributeItem),
    AttributeList(AttributeList),
    AttributeListList(Vec<AttributeListList>),
    AttributeListOpt(Option<Box<AttributeListOpt>>),
    AttributeOpt(Option<Box<AttributeOpt>>),
    BaseLess(BaseLess),
    BaseLessTerm(BaseLessTerm),
    BaseLessToken(BaseLessToken),
    Based(Based),
    BasedTerm(BasedTerm),
    BasedToken(BasedToken),
    Bit(Bit),
    BitTerm(BitTerm),
    BitToken(BitToken),
    Case(Case),
    CaseExpression(CaseExpression),
    CaseExpressionList(Vec<CaseExpressionList>),
    CaseExpressionOpt(Option<Box<CaseExpressionOpt>>),
    CaseItem(CaseItem),
    CaseItemGroup(CaseItemGroup),
    CaseItemGroup0(CaseItemGroup0),
    CaseItemGroup0List(Vec<CaseItemGroup0List>),
    CaseStatement(CaseStatement),
    CaseStatementList(Vec<CaseStatementList>),
    CaseTerm(CaseTerm),
    CaseToken(CaseToken),
    Colon(Colon),
    ColonColon(ColonColon),
    ColonColonTerm(ColonColonTerm),
    ColonColonToken(ColonColonToken),
    ColonTerm(ColonTerm),
    ColonToken(ColonToken),
    Comma(Comma),
    CommaTerm(CommaTerm),
    CommaToken(CommaToken),
    Comments(Comments),
    CommentsOpt(Option<Box<CommentsOpt>>),
    CommentsTerm(CommentsTerm),
    ConcatenationItem(ConcatenationItem),
    ConcatenationItemOpt(Option<Box<ConcatenationItemOpt>>),
    ConcatenationList(ConcatenationList),
    ConcatenationListList(Vec<ConcatenationListList>),
    ConcatenationListOpt(Option<Box<ConcatenationListOpt>>),
    Defaul(Defaul),
    DefaultTerm(DefaultTerm),
    DefaultToken(DefaultToken),
    DescriptionGroup(DescriptionGroup),
    DescriptionGroupGroup(DescriptionGroupGroup),
    DescriptionGroupGroupList(Vec<DescriptionGroupGroupList>),
    DescriptionGroupList(Vec<DescriptionGroupList>),
    DescriptionItem(DescriptionItem),
    Direction(Direction),
    Dollar(Dollar),
    DollarTerm(DollarTerm),
    DollarToken(DollarToken),
    Dot(Dot),
    DotDot(DotDot),
    DotDotEqu(DotDotEqu),
    DotDotEquTerm(DotDotEquTerm),
    DotDotEquToken(DotDotEquToken),
    DotDotTerm(DotDotTerm),
    DotDotToken(DotDotToken),
    DotTerm(DotTerm),
    DotToken(DotToken),
    Else(Else),
    ElseTerm(ElseTerm),
    ElseToken(ElseToken),
    Enum(Enum),
    EnumDeclaration(EnumDeclaration),
    EnumGroup(EnumGroup),
    EnumGroupGroup(EnumGroupGroup),
    EnumGroupList(Vec<EnumGroupList>),
    EnumItem(EnumItem),
    EnumItemOpt(Option<Box<EnumItemOpt>>),
    EnumList(EnumList),
    EnumListList(Vec<EnumListList>),
    EnumListOpt(Option<Box<EnumListOpt>>),
    EnumTerm(EnumTerm),
    EnumToken(EnumToken),
    Equ(Equ),
    EquTerm(EquTerm),
    EquToken(EquToken),
    Exponent(Exponent),
    ExponentTerm(ExponentTerm),
    ExponentToken(ExponentToken),
    Export(Export),
    ExportDeclaration(ExportDeclaration),
    ExportDeclarationGroup(ExportDeclarationGroup),
    ExportDeclarationGroup0(ExportDeclarationGroup0),
    ExportTerm(ExportTerm),
    ExportToken(ExportToken),
    Expression(Expression),
    Expression01(Expression01),
    Expression01List(Vec<Expression01List>),
    Expression02(Expression02),
    Expression02List(Vec<Expression02List>),
    Expression03(Expression03),
    Expression03List(Vec<Expression03List>),
    Expression04(Expression04),
    Expression04List(Vec<Expression04List>),
    Expression05(Expression05),
    Expression05List(Vec<Expression05List>),
    Expression06(Expression06),
    Expression06List(Vec<Expression06List>),
    Expression07(Expression07),
    Expression07List(Vec<Expression07List>),
    Expression08(Expression08),
    Expression08List(Vec<Expression08List>),
    Expression09(Expression09),
    Expression09List(Vec<Expression09List>),
    Expression09ListGroup(Expression09ListGroup),
    Expression10(Expression10),
    Expression10List(Vec<Expression10List>),
    Expression11(Expression11),
    Expression11List(Vec<Expression11List>),
    Expression12(Expression12),
    Expression12List(Vec<Expression12List>),
    Expression12ListGroup(Expression12ListGroup),
    ExpressionIdentifier(ExpressionIdentifier),
    ExpressionIdentifierGroup(ExpressionIdentifierGroup),
    ExpressionIdentifierGroupList(Vec<ExpressionIdentifierGroupList>),
    ExpressionIdentifierGroupList0(Vec<ExpressionIdentifierGroupList0>),
    ExpressionIdentifierGroupList1(Vec<ExpressionIdentifierGroupList1>),
    ExpressionIdentifierGroupList2(Vec<ExpressionIdentifierGroupList2>),
    ExpressionIdentifierGroupList2List(Vec<ExpressionIdentifierGroupList2List>),
    ExpressionIdentifierOpt(Option<Box<ExpressionIdentifierOpt>>),
    ExpressionList(Vec<ExpressionList>),
    F32(F32),
    F32Term(F32Term),
    F32Token(F32Token),
    F64(F64),
    F64Term(F64Term),
    F64Token(F64Token),
    Factor(Factor),
    FactorGroup(FactorGroup),
    FactorOpt(Option<Box<FactorOpt>>),
    Final(Final),
    FinalDeclaration(FinalDeclaration),
    FinalDeclarationList(Vec<FinalDeclarationList>),
    FinalTerm(FinalTerm),
    FinalToken(FinalToken),
    FixedPoint(FixedPoint),
    FixedPointTerm(FixedPointTerm),
    FixedPointToken(FixedPointToken),
    FixedType(FixedType),
    For(For),
    ForStatement(ForStatement),
    ForStatementList(Vec<ForStatementList>),
    ForStatementOpt(Option<Box<ForStatementOpt>>),
    ForTerm(ForTerm),
    ForToken(ForToken),
    Function(Function),
    FunctionCall(FunctionCall),
    FunctionCallOpt(Option<Box<FunctionCallOpt>>),
    FunctionDeclaration(FunctionDeclaration),
    FunctionDeclarationList(Vec<FunctionDeclarationList>),
    FunctionDeclarationOpt(Option<Box<FunctionDeclarationOpt>>),
    FunctionDeclarationOpt0(Option<Box<FunctionDeclarationOpt0>>),
    FunctionItem(FunctionItem),
    FunctionTerm(FunctionTerm),
    FunctionToken(FunctionToken),
    Hash(Hash),
    HashTerm(HashTerm),
    HashToken(HashToken),
    HierarchicalIdentifier(HierarchicalIdentifier),
    HierarchicalIdentifierList(Vec<HierarchicalIdentifierList>),
    HierarchicalIdentifierList0(Vec<HierarchicalIdentifierList0>),
    HierarchicalIdentifierList0List(Vec<HierarchicalIdentifierList0List>),
    I32(I32),
    I32Term(I32Term),
    I32Token(I32Token),
    I64(I64),
    I64Term(I64Term),
    I64Token(I64Token),
    Identifier(Identifier),
    IdentifierStatement(IdentifierStatement),
    IdentifierStatementGroup(IdentifierStatementGroup),
    IdentifierTerm(IdentifierTerm),
    IdentifierToken(IdentifierToken),
    If(If),
    IfExpression(IfExpression),
    IfExpressionList(Vec<IfExpressionList>),
    IfReset(IfReset),
    IfResetStatement(IfResetStatement),
    IfResetStatementList(Vec<IfResetStatementList>),
    IfResetStatementList0(Vec<IfResetStatementList0>),
    IfResetStatementList0List(Vec<IfResetStatementList0List>),
    IfResetStatementOpt(Option<Box<IfResetStatementOpt>>),
    IfResetStatementOptList(Vec<IfResetStatementOptList>),
    IfResetTerm(IfResetTerm),
    IfResetToken(IfResetToken),
    IfStatement(IfStatement),
    IfStatementList(Vec<IfStatementList>),
    IfStatementList0(Vec<IfStatementList0>),
    IfStatementList0List(Vec<IfStatementList0List>),
    IfStatementOpt(Option<Box<IfStatementOpt>>),
    IfStatementOptList(Vec<IfStatementOptList>),
    IfTerm(IfTerm),
    IfToken(IfToken),
    Import(Import),
    ImportDeclaration(ImportDeclaration),
    ImportDeclarationGroup(ImportDeclarationGroup),
    ImportTerm(ImportTerm),
    ImportToken(ImportToken),
    In(In),
    InTerm(InTerm),
    InToken(InToken),
    Initial(Initial),
    InitialDeclaration(InitialDeclaration),
    InitialDeclarationList(Vec<InitialDeclarationList>),
    InitialItem(InitialItem),
    InitialTerm(InitialTerm),
    InitialToken(InitialToken),
    Inout(Inout),
    InoutTerm(InoutTerm),
    InoutToken(InoutToken),
    Input(Input),
    InputTerm(InputTerm),
    InputToken(InputToken),
    Inside(Inside),
    InsideExpression(InsideExpression),
    InsideTerm(InsideTerm),
    InsideToken(InsideToken),
    Inst(Inst),
    InstDeclaration(InstDeclaration),
    InstDeclarationOpt(Option<Box<InstDeclarationOpt>>),
    InstDeclarationOpt0(Option<Box<InstDeclarationOpt0>>),
    InstDeclarationOpt1(Option<Box<InstDeclarationOpt1>>),
    InstDeclarationOpt2(Option<Box<InstDeclarationOpt2>>),
    InstParameter(InstParameter),
    InstParameterGroup(InstParameterGroup),
    InstParameterGroupGroup(InstParameterGroupGroup),
    InstParameterGroupList(Vec<InstParameterGroupList>),
    InstParameterItem(InstParameterItem),
    InstParameterItemOpt(Option<Box<InstParameterItemOpt>>),
    InstParameterList(InstParameterList),
    InstParameterListList(Vec<InstParameterListList>),
    InstParameterListOpt(Option<Box<InstParameterListOpt>>),
    InstParameterOpt(Option<Box<InstParameterOpt>>),
    InstPortGroup(InstPortGroup),
    InstPortGroupGroup(InstPortGroupGroup),
    InstPortGroupList(Vec<InstPortGroupList>),
    InstPortItem(InstPortItem),
    InstPortItemOpt(Option<Box<InstPortItemOpt>>),
    InstPortList(InstPortList),
    InstPortListList(Vec<InstPortListList>),
    InstPortListOpt(Option<Box<InstPortListOpt>>),
    InstTerm(InstTerm),
    InstToken(InstToken),
    IntegralNumber(IntegralNumber),
    Interface(Interface),
    InterfaceDeclaration(InterfaceDeclaration),
    InterfaceDeclarationList(Vec<InterfaceDeclarationList>),
    InterfaceDeclarationOpt(Option<Box<InterfaceDeclarationOpt>>),
    InterfaceForDeclaration(InterfaceForDeclaration),
    InterfaceForDeclarationOpt(Option<Box<InterfaceForDeclarationOpt>>),
    InterfaceGroup(InterfaceGroup),
    InterfaceGroupGroup(InterfaceGroupGroup),
    InterfaceGroupGroupList(Vec<InterfaceGroupGroupList>),
    InterfaceGroupList(Vec<InterfaceGroupList>),
    InterfaceIfDeclaration(InterfaceIfDeclaration),
    InterfaceIfDeclarationList(Vec<InterfaceIfDeclarationList>),
    InterfaceIfDeclarationOpt(Option<Box<InterfaceIfDeclarationOpt>>),
    InterfaceItem(InterfaceItem),
    InterfaceNamedBlock(InterfaceNamedBlock),
    InterfaceNamedBlockList(Vec<InterfaceNamedBlockList>),
    InterfaceOptionalNamedBlock(InterfaceOptionalNamedBlock),
    InterfaceOptionalNamedBlockList(Vec<InterfaceOptionalNamedBlockList>),
    InterfaceOptionalNamedBlockOpt(Option<Box<InterfaceOptionalNamedBlockOpt>>),
    InterfaceTerm(InterfaceTerm),
    InterfaceToken(InterfaceToken),
    LAngle(LAngle),
    LAngleTerm(LAngleTerm),
    LAngleToken(LAngleToken),
    LBrace(LBrace),
    LBraceTerm(LBraceTerm),
    LBraceToken(LBraceToken),
    LBracket(LBracket),
    LBracketTerm(LBracketTerm),
    LBracketToken(LBracketToken),
    LParen(LParen),
    LParenTerm(LParenTerm),
    LParenToken(LParenToken),
    Localparam(Localparam),
    LocalparamDeclaration(LocalparamDeclaration),
    LocalparamDeclarationGroup(LocalparamDeclarationGroup),
    LocalparamTerm(LocalparamTerm),
    LocalparamToken(LocalparamToken),
    Logic(Logic),
    LogicTerm(LogicTerm),
    LogicToken(LogicToken),
    Lsb(Lsb),
    LsbTerm(LsbTerm),
    LsbToken(LsbToken),
    MinusColon(MinusColon),
    MinusColonTerm(MinusColonTerm),
    MinusColonToken(MinusColonToken),
    MinusGT(MinusGT),
    MinusGTTerm(MinusGTTerm),
    MinusGTToken(MinusGTToken),
    Modport(Modport),
    ModportDeclaration(ModportDeclaration),
    ModportGroup(ModportGroup),
    ModportGroupGroup(ModportGroupGroup),
    ModportGroupList(Vec<ModportGroupList>),
    ModportItem(ModportItem),
    ModportList(ModportList),
    ModportListList(Vec<ModportListList>),
    ModportListOpt(Option<Box<ModportListOpt>>),
    ModportTerm(ModportTerm),
    ModportToken(ModportToken),
    Module(Module),
    ModuleDeclaration(ModuleDeclaration),
    ModuleDeclarationList(Vec<ModuleDeclarationList>),
    ModuleDeclarationOpt(Option<Box<ModuleDeclarationOpt>>),
    ModuleDeclarationOpt0(Option<Box<ModuleDeclarationOpt0>>),
    ModuleForDeclaration(ModuleForDeclaration),
    ModuleForDeclarationOpt(Option<Box<ModuleForDeclarationOpt>>),
    ModuleGroup(ModuleGroup),
    ModuleGroupGroup(ModuleGroupGroup),
    ModuleGroupGroupList(Vec<ModuleGroupGroupList>),
    ModuleGroupList(Vec<ModuleGroupList>),
    ModuleIfDeclaration(ModuleIfDeclaration),
    ModuleIfDeclarationList(Vec<ModuleIfDeclarationList>),
    ModuleIfDeclarationOpt(Option<Box<ModuleIfDeclarationOpt>>),
    ModuleItem(ModuleItem),
    ModuleNamedBlock(ModuleNamedBlock),
    ModuleNamedBlockList(Vec<ModuleNamedBlockList>),
    ModuleOptionalNamedBlock(ModuleOptionalNamedBlock),
    ModuleOptionalNamedBlockList(Vec<ModuleOptionalNamedBlockList>),
    ModuleOptionalNamedBlockOpt(Option<Box<ModuleOptionalNamedBlockOpt>>),
    ModuleTerm(ModuleTerm),
    ModuleToken(ModuleToken),
    Msb(Msb),
    MsbTerm(MsbTerm),
    MsbToken(MsbToken),
    Negedge(Negedge),
    NegedgeTerm(NegedgeTerm),
    NegedgeToken(NegedgeToken),
    Number(Number),
    Operator01(Operator01),
    Operator01Term(Operator01Term),
    Operator01Token(Operator01Token),
    Operator02(Operator02),
    Operator02Term(Operator02Term),
    Operator02Token(Operator02Token),
    Operator03(Operator03),
    Operator03Term(Operator03Term),
    Operator03Token(Operator03Token),
    Operator04(Operator04),
    Operator04Term(Operator04Term),
    Operator04Token(Operator04Token),
    Operator05(Operator05),
    Operator05Term(Operator05Term),
    Operator05Token(Operator05Token),
    Operator06(Operator06),
    Operator06Term(Operator06Term),
    Operator06Token(Operator06Token),
    Operator07(Operator07),
    Operator07Term(Operator07Term),
    Operator07Token(Operator07Token),
    Operator08(Operator08),
    Operator08Term(Operator08Term),
    Operator08Token(Operator08Token),
    Operator09(Operator09),
    Operator09Term(Operator09Term),
    Operator09Token(Operator09Token),
    Operator10(Operator10),
    Operator10Term(Operator10Term),
    Operator10Token(Operator10Token),
    Operator11(Operator11),
    Operator11Term(Operator11Term),
    Operator11Token(Operator11Token),
    Output(Output),
    OutputTerm(OutputTerm),
    OutputToken(OutputToken),
    Outside(Outside),
    OutsideExpression(OutsideExpression),
    OutsideTerm(OutsideTerm),
    OutsideToken(OutsideToken),
    Package(Package),
    PackageDeclaration(PackageDeclaration),
    PackageDeclarationList(Vec<PackageDeclarationList>),
    PackageGroup(PackageGroup),
    PackageGroupGroup(PackageGroupGroup),
    PackageGroupGroupList(Vec<PackageGroupGroupList>),
    PackageGroupList(Vec<PackageGroupList>),
    PackageItem(PackageItem),
    PackageTerm(PackageTerm),
    PackageToken(PackageToken),
    Parameter(Parameter),
    ParameterTerm(ParameterTerm),
    ParameterToken(ParameterToken),
    PlusColon(PlusColon),
    PlusColonTerm(PlusColonTerm),
    PlusColonToken(PlusColonToken),
    PortDeclaration(PortDeclaration),
    PortDeclarationGroup(PortDeclarationGroup),
    PortDeclarationGroupGroup(PortDeclarationGroupGroup),
    PortDeclarationGroupList(Vec<PortDeclarationGroupList>),
    PortDeclarationItem(PortDeclarationItem),
    PortDeclarationItemGroup(PortDeclarationItemGroup),
    PortDeclarationItemOpt(Option<Box<PortDeclarationItemOpt>>),
    PortDeclarationList(PortDeclarationList),
    PortDeclarationListList(Vec<PortDeclarationListList>),
    PortDeclarationListOpt(Option<Box<PortDeclarationListOpt>>),
    PortDeclarationOpt(Option<Box<PortDeclarationOpt>>),
    Posedge(Posedge),
    PosedgeTerm(PosedgeTerm),
    PosedgeToken(PosedgeToken),
    RAngle(RAngle),
    RAngleTerm(RAngleTerm),
    RAngleToken(RAngleToken),
    RBrace(RBrace),
    RBraceTerm(RBraceTerm),
    RBraceToken(RBraceToken),
    RBracket(RBracket),
    RBracketTerm(RBracketTerm),
    RBracketToken(RBracketToken),
    RParen(RParen),
    RParenTerm(RParenTerm),
    RParenToken(RParenToken),
    Range(Range),
    RangeItem(RangeItem),
    RangeList(RangeList),
    RangeListList(Vec<RangeListList>),
    RangeListOpt(Option<Box<RangeListOpt>>),
    RangeOperator(RangeOperator),
    RangeOpt(Option<Box<RangeOpt>>),
    RealNumber(RealNumber),
    Ref(Ref),
    RefTerm(RefTerm),
    RefToken(RefToken),
    Repeat(Repeat),
    RepeatTerm(RepeatTerm),
    RepeatToken(RepeatToken),
    Return(Return),
    ReturnStatement(ReturnStatement),
    ReturnTerm(ReturnTerm),
    ReturnToken(ReturnToken),
    ScalarType(ScalarType),
    ScalarTypeGroup(ScalarTypeGroup),
    ScalarTypeList(Vec<ScalarTypeList>),
    ScopedIdentifier(ScopedIdentifier),
    ScopedIdentifierList(Vec<ScopedIdentifierList>),
    Select(Select),
    SelectOperator(SelectOperator),
    SelectOpt(Option<Box<SelectOpt>>),
    Semicolon(Semicolon),
    SemicolonTerm(SemicolonTerm),
    SemicolonToken(SemicolonToken),
    Signed(Signed),
    SignedTerm(SignedTerm),
    SignedToken(SignedToken),
    Star(Star),
    StarTerm(StarTerm),
    StarToken(StarToken),
    Start(Start),
    StartToken(StartToken),
    Statement(Statement),
    Step(Step),
    StepTerm(StepTerm),
    StepToken(StepToken),
    Strin(Strin),
    StringLiteral(StringLiteral),
    StringLiteralTerm(StringLiteralTerm),
    StringLiteralToken(StringLiteralToken),
    StringTerm(StringTerm),
    StringToken(StringToken),
    Struct(Struct),
    StructDeclaration(StructDeclaration),
    StructGroup(StructGroup),
    StructGroupGroup(StructGroupGroup),
    StructGroupList(Vec<StructGroupList>),
    StructItem(StructItem),
    StructList(StructList),
    StructListList(Vec<StructListList>),
    StructListOpt(Option<Box<StructListOpt>>),
    StructTerm(StructTerm),
    StructToken(StructToken),
    SyncHigh(SyncHigh),
    SyncHighTerm(SyncHighTerm),
    SyncHighToken(SyncHighToken),
    SyncLow(SyncLow),
    SyncLowTerm(SyncLowTerm),
    SyncLowToken(SyncLowToken),
    Tri(Tri),
    TriTerm(TriTerm),
    TriToken(TriToken),
    Type(Type),
    TypeExpression(TypeExpression),
    TypeModifier(TypeModifier),
    TypeTerm(TypeTerm),
    TypeToken(TypeToken),
    U32(U32),
    U32Term(U32Term),
    U32Token(U32Token),
    U64(U64),
    U64Term(U64Term),
    U64Token(U64Token),
    UnaryOperator(UnaryOperator),
    UnaryOperatorTerm(UnaryOperatorTerm),
    UnaryOperatorToken(UnaryOperatorToken),
    Var(Var),
    VarDeclaration(VarDeclaration),
    VarDeclarationOpt(Option<Box<VarDeclarationOpt>>),
    VarTerm(VarTerm),
    VarToken(VarToken),
    VariableType(VariableType),
    VariableTypeGroup(VariableTypeGroup),
    VariableTypeOpt(Option<Box<VariableTypeOpt>>),
    Veryl(Veryl),
    VerylList(Vec<VerylList>),
    Width(Width),
    WidthList(Vec<WidthList>),
    WithParameter(WithParameter),
    WithParameterGroup(WithParameterGroup),
    WithParameterGroupGroup(WithParameterGroupGroup),
    WithParameterGroupList(Vec<WithParameterGroupList>),
    WithParameterItem(WithParameterItem),
    WithParameterItemGroup(WithParameterItemGroup),
    WithParameterItemGroup0(WithParameterItemGroup0),
    WithParameterList(WithParameterList),
    WithParameterListList(Vec<WithParameterListList>),
    WithParameterListOpt(Option<Box<WithParameterListOpt>>),
    WithParameterOpt(Option<Box<WithParameterOpt>>),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct VerylGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn VerylGrammarTrait,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType>,
    // Just to hold the lifetime generated by parol
    phantom: PhantomData<&'t str>,
}

///
/// The `VerylGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> VerylGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn VerylGrammarTrait) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
            phantom: PhantomData::default(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType> {
        let item = self.item_stack.pop();
        if let Some(ref item) = item {
            trace!("pop     {}: {:?}", context, item);
        }
        item
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// CommentsTerm: "(?:(?:(?://.*(?:\r\n|\r|\n|$))|(?:(?ms)/\u{2a}.*?\u{2a}/))\s*)+" : Token;
    ///
    #[parol_runtime::function_name::named]
    fn comments_term(&mut self, comments_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments_term = comments_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let comments_term_built = CommentsTerm { comments_term };
        // Calling user action here
        self.user_grammar.comments_term(&comments_term_built)?;
        self.push(ASTType::CommentsTerm(comments_term_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// StringLiteralTerm: "\u{0022}(?:\\[\u{0022}\\/bfnrt]|u[0-9a-fA-F]{4}|[^\u{0022}\\\u0000-\u001F])*\u{0022}" : Token;
    ///
    #[parol_runtime::function_name::named]
    fn string_literal_term(&mut self, string_literal_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string_literal_term = string_literal_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let string_literal_term_built = StringLiteralTerm {
            string_literal_term,
        };
        // Calling user action here
        self.user_grammar
            .string_literal_term(&string_literal_term_built)?;
        self.push(
            ASTType::StringLiteralTerm(string_literal_term_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// ExponentTerm: /[0-9]+(?:_[0-9]+)*\.[0-9]+(?:_[0-9]+)*[eE][+-]?[0-9]+(?:_[0-9]+)*/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn exponent_term(&mut self, exponent_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let exponent_term = exponent_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let exponent_term_built = ExponentTerm { exponent_term };
        // Calling user action here
        self.user_grammar.exponent_term(&exponent_term_built)?;
        self.push(ASTType::ExponentTerm(exponent_term_built), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// FixedPointTerm: /[0-9]+(?:_[0-9]+)*\.[0-9]+(?:_[0-9]+)*/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn fixed_point_term(&mut self, fixed_point_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let fixed_point_term = fixed_point_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let fixed_point_term_built = FixedPointTerm { fixed_point_term };
        // Calling user action here
        self.user_grammar
            .fixed_point_term(&fixed_point_term_built)?;
        self.push(ASTType::FixedPointTerm(fixed_point_term_built), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// BasedTerm: /(?:[0-9]+(?:_[0-9]+)*)?'[bodh][0-9a-fA-FxzXZ]+(?:_[0-9a-fA-FxzXZ]+)*/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn based_term(&mut self, based_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let based_term = based_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let based_term_built = BasedTerm { based_term };
        // Calling user action here
        self.user_grammar.based_term(&based_term_built)?;
        self.push(ASTType::BasedTerm(based_term_built), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// AllBitTerm: /(?:[0-9]+(?:_[0-9]+)*)?'[01xzXZ]/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn all_bit_term(&mut self, all_bit_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let all_bit_term = all_bit_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let all_bit_term_built = AllBitTerm { all_bit_term };
        // Calling user action here
        self.user_grammar.all_bit_term(&all_bit_term_built)?;
        self.push(ASTType::AllBitTerm(all_bit_term_built), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// BaseLessTerm: /[0-9]+(?:_[0-9]+)*/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn base_less_term(&mut self, base_less_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let base_less_term = base_less_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let base_less_term_built = BaseLessTerm { base_less_term };
        // Calling user action here
        self.user_grammar.base_less_term(&base_less_term_built)?;
        self.push(ASTType::BaseLessTerm(base_less_term_built), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// MinusColonTerm: '-:' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn minus_colon_term(&mut self, minus_colon_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus_colon_term = minus_colon_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let minus_colon_term_built = MinusColonTerm { minus_colon_term };
        // Calling user action here
        self.user_grammar
            .minus_colon_term(&minus_colon_term_built)?;
        self.push(ASTType::MinusColonTerm(minus_colon_term_built), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// MinusGTTerm: '->' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn minus_g_t_term(&mut self, minus_g_t_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus_g_t_term = minus_g_t_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let minus_g_t_term_built = MinusGTTerm { minus_g_t_term };
        // Calling user action here
        self.user_grammar.minus_g_t_term(&minus_g_t_term_built)?;
        self.push(ASTType::MinusGTTerm(minus_g_t_term_built), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// PlusColonTerm: '+:' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn plus_colon_term(&mut self, plus_colon_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus_colon_term = plus_colon_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let plus_colon_term_built = PlusColonTerm { plus_colon_term };
        // Calling user action here
        self.user_grammar.plus_colon_term(&plus_colon_term_built)?;
        self.push(ASTType::PlusColonTerm(plus_colon_term_built), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// AssignmentOperatorTerm: "\+=|-=|\*=|/=|%=|&=|\|=|\^=|<<=|>>=|<<<=|>>>=" : Token;
    ///
    #[parol_runtime::function_name::named]
    fn assignment_operator_term(
        &mut self,
        assignment_operator_term: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assignment_operator_term = assignment_operator_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let assignment_operator_term_built = AssignmentOperatorTerm {
            assignment_operator_term,
        };
        // Calling user action here
        self.user_grammar
            .assignment_operator_term(&assignment_operator_term_built)?;
        self.push(
            ASTType::AssignmentOperatorTerm(assignment_operator_term_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// Operator11Term: "\*\*" : Token;
    ///
    #[parol_runtime::function_name::named]
    fn operator11_term(&mut self, operator11_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator11_term = operator11_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let operator11_term_built = Operator11Term { operator11_term };
        // Calling user action here
        self.user_grammar.operator11_term(&operator11_term_built)?;
        self.push(ASTType::Operator11Term(operator11_term_built), context);
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// Operator10Term: "/|%" : Token;
    ///
    #[parol_runtime::function_name::named]
    fn operator10_term(&mut self, operator10_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator10_term = operator10_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let operator10_term_built = Operator10Term { operator10_term };
        // Calling user action here
        self.user_grammar.operator10_term(&operator10_term_built)?;
        self.push(ASTType::Operator10Term(operator10_term_built), context);
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// Operator09Term: "\+|-" : Token;
    ///
    #[parol_runtime::function_name::named]
    fn operator09_term(&mut self, operator09_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator09_term = operator09_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let operator09_term_built = Operator09Term { operator09_term };
        // Calling user action here
        self.user_grammar.operator09_term(&operator09_term_built)?;
        self.push(ASTType::Operator09Term(operator09_term_built), context);
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// Operator08Term: "<<<|>>>|<<|>>" : Token;
    ///
    #[parol_runtime::function_name::named]
    fn operator08_term(&mut self, operator08_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator08_term = operator08_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let operator08_term_built = Operator08Term { operator08_term };
        // Calling user action here
        self.user_grammar.operator08_term(&operator08_term_built)?;
        self.push(ASTType::Operator08Term(operator08_term_built), context);
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// Operator07Term: "<=|>=|<:|>:" : Token;
    ///
    #[parol_runtime::function_name::named]
    fn operator07_term(&mut self, operator07_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator07_term = operator07_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let operator07_term_built = Operator07Term { operator07_term };
        // Calling user action here
        self.user_grammar.operator07_term(&operator07_term_built)?;
        self.push(ASTType::Operator07Term(operator07_term_built), context);
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// Operator06Term: "===|==\?|!==|!=\?|==|!=" : Token;
    ///
    #[parol_runtime::function_name::named]
    fn operator06_term(&mut self, operator06_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator06_term = operator06_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let operator06_term_built = Operator06Term { operator06_term };
        // Calling user action here
        self.user_grammar.operator06_term(&operator06_term_built)?;
        self.push(ASTType::Operator06Term(operator06_term_built), context);
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// Operator02Term: "&&" : Token;
    ///
    #[parol_runtime::function_name::named]
    fn operator02_term(&mut self, operator02_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator02_term = operator02_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let operator02_term_built = Operator02Term { operator02_term };
        // Calling user action here
        self.user_grammar.operator02_term(&operator02_term_built)?;
        self.push(ASTType::Operator02Term(operator02_term_built), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// Operator01Term: "\|\|" : Token;
    ///
    #[parol_runtime::function_name::named]
    fn operator01_term(&mut self, operator01_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator01_term = operator01_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let operator01_term_built = Operator01Term { operator01_term };
        // Calling user action here
        self.user_grammar.operator01_term(&operator01_term_built)?;
        self.push(ASTType::Operator01Term(operator01_term_built), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// Operator05Term: "&" : Token;
    ///
    #[parol_runtime::function_name::named]
    fn operator05_term(&mut self, operator05_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator05_term = operator05_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let operator05_term_built = Operator05Term { operator05_term };
        // Calling user action here
        self.user_grammar.operator05_term(&operator05_term_built)?;
        self.push(ASTType::Operator05Term(operator05_term_built), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// Operator04Term: "\^~|\^|~\^" : Token;
    ///
    #[parol_runtime::function_name::named]
    fn operator04_term(&mut self, operator04_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator04_term = operator04_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let operator04_term_built = Operator04Term { operator04_term };
        // Calling user action here
        self.user_grammar.operator04_term(&operator04_term_built)?;
        self.push(ASTType::Operator04Term(operator04_term_built), context);
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// Operator03Term: "\|" : Token;
    ///
    #[parol_runtime::function_name::named]
    fn operator03_term(&mut self, operator03_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator03_term = operator03_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let operator03_term_built = Operator03Term { operator03_term };
        // Calling user action here
        self.user_grammar.operator03_term(&operator03_term_built)?;
        self.push(ASTType::Operator03Term(operator03_term_built), context);
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// UnaryOperatorTerm: "~&|~\||!|~" : Token;
    ///
    #[parol_runtime::function_name::named]
    fn unary_operator_term(&mut self, unary_operator_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unary_operator_term = unary_operator_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let unary_operator_term_built = UnaryOperatorTerm {
            unary_operator_term,
        };
        // Calling user action here
        self.user_grammar
            .unary_operator_term(&unary_operator_term_built)?;
        self.push(
            ASTType::UnaryOperatorTerm(unary_operator_term_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// ColonColonTerm: '::' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn colon_colon_term(&mut self, colon_colon_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon_colon_term = colon_colon_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let colon_colon_term_built = ColonColonTerm { colon_colon_term };
        // Calling user action here
        self.user_grammar
            .colon_colon_term(&colon_colon_term_built)?;
        self.push(ASTType::ColonColonTerm(colon_colon_term_built), context);
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// ColonTerm: ':' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn colon_term(&mut self, colon_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon_term = colon_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let colon_term_built = ColonTerm { colon_term };
        // Calling user action here
        self.user_grammar.colon_term(&colon_term_built)?;
        self.push(ASTType::ColonTerm(colon_term_built), context);
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// CommaTerm: ',' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn comma_term(&mut self, comma_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma_term = comma_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let comma_term_built = CommaTerm { comma_term };
        // Calling user action here
        self.user_grammar.comma_term(&comma_term_built)?;
        self.push(ASTType::CommaTerm(comma_term_built), context);
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// DollarTerm: '$' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn dollar_term(&mut self, dollar_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dollar_term = dollar_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let dollar_term_built = DollarTerm { dollar_term };
        // Calling user action here
        self.user_grammar.dollar_term(&dollar_term_built)?;
        self.push(ASTType::DollarTerm(dollar_term_built), context);
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// DotDotEquTerm: '..=' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn dot_dot_equ_term(&mut self, dot_dot_equ_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_dot_equ_term = dot_dot_equ_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let dot_dot_equ_term_built = DotDotEquTerm { dot_dot_equ_term };
        // Calling user action here
        self.user_grammar
            .dot_dot_equ_term(&dot_dot_equ_term_built)?;
        self.push(ASTType::DotDotEquTerm(dot_dot_equ_term_built), context);
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// DotDotTerm: '..' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn dot_dot_term(&mut self, dot_dot_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_dot_term = dot_dot_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let dot_dot_term_built = DotDotTerm { dot_dot_term };
        // Calling user action here
        self.user_grammar.dot_dot_term(&dot_dot_term_built)?;
        self.push(ASTType::DotDotTerm(dot_dot_term_built), context);
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// DotTerm: '.' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn dot_term(&mut self, dot_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_term = dot_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let dot_term_built = DotTerm { dot_term };
        // Calling user action here
        self.user_grammar.dot_term(&dot_term_built)?;
        self.push(ASTType::DotTerm(dot_term_built), context);
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// EquTerm: '=' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn equ_term(&mut self, equ_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equ_term = equ_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let equ_term_built = EquTerm { equ_term };
        // Calling user action here
        self.user_grammar.equ_term(&equ_term_built)?;
        self.push(ASTType::EquTerm(equ_term_built), context);
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// HashTerm: '#' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn hash_term(&mut self, hash_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hash_term = hash_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let hash_term_built = HashTerm { hash_term };
        // Calling user action here
        self.user_grammar.hash_term(&hash_term_built)?;
        self.push(ASTType::HashTerm(hash_term_built), context);
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// LAngleTerm: '<' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn l_angle_term(&mut self, l_angle_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_angle_term = l_angle_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let l_angle_term_built = LAngleTerm { l_angle_term };
        // Calling user action here
        self.user_grammar.l_angle_term(&l_angle_term_built)?;
        self.push(ASTType::LAngleTerm(l_angle_term_built), context);
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// LBraceTerm: '{' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn l_brace_term(&mut self, l_brace_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_brace_term = l_brace_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let l_brace_term_built = LBraceTerm { l_brace_term };
        // Calling user action here
        self.user_grammar.l_brace_term(&l_brace_term_built)?;
        self.push(ASTType::LBraceTerm(l_brace_term_built), context);
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// LBracketTerm: '[' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn l_bracket_term(&mut self, l_bracket_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_bracket_term = l_bracket_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let l_bracket_term_built = LBracketTerm { l_bracket_term };
        // Calling user action here
        self.user_grammar.l_bracket_term(&l_bracket_term_built)?;
        self.push(ASTType::LBracketTerm(l_bracket_term_built), context);
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// LParenTerm: '(' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn l_paren_term(&mut self, l_paren_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_paren_term = l_paren_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let l_paren_term_built = LParenTerm { l_paren_term };
        // Calling user action here
        self.user_grammar.l_paren_term(&l_paren_term_built)?;
        self.push(ASTType::LParenTerm(l_paren_term_built), context);
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// RAngleTerm: '>' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn r_angle_term(&mut self, r_angle_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_angle_term = r_angle_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let r_angle_term_built = RAngleTerm { r_angle_term };
        // Calling user action here
        self.user_grammar.r_angle_term(&r_angle_term_built)?;
        self.push(ASTType::RAngleTerm(r_angle_term_built), context);
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// RBraceTerm: '}' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn r_brace_term(&mut self, r_brace_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace_term = r_brace_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let r_brace_term_built = RBraceTerm { r_brace_term };
        // Calling user action here
        self.user_grammar.r_brace_term(&r_brace_term_built)?;
        self.push(ASTType::RBraceTerm(r_brace_term_built), context);
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// RBracketTerm: ']' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn r_bracket_term(&mut self, r_bracket_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_bracket_term = r_bracket_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let r_bracket_term_built = RBracketTerm { r_bracket_term };
        // Calling user action here
        self.user_grammar.r_bracket_term(&r_bracket_term_built)?;
        self.push(ASTType::RBracketTerm(r_bracket_term_built), context);
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// RParenTerm: ')' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn r_paren_term(&mut self, r_paren_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren_term = r_paren_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let r_paren_term_built = RParenTerm { r_paren_term };
        // Calling user action here
        self.user_grammar.r_paren_term(&r_paren_term_built)?;
        self.push(ASTType::RParenTerm(r_paren_term_built), context);
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// SemicolonTerm: ';' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn semicolon_term(&mut self, semicolon_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon_term = semicolon_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let semicolon_term_built = SemicolonTerm { semicolon_term };
        // Calling user action here
        self.user_grammar.semicolon_term(&semicolon_term_built)?;
        self.push(ASTType::SemicolonTerm(semicolon_term_built), context);
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// StarTerm: '*' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn star_term(&mut self, star_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let star_term = star_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let star_term_built = StarTerm { star_term };
        // Calling user action here
        self.user_grammar.star_term(&star_term_built)?;
        self.push(ASTType::StarTerm(star_term_built), context);
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// AlwaysCombTerm: /(?-u:\b)always_comb(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn always_comb_term(&mut self, always_comb_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_comb_term = always_comb_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let always_comb_term_built = AlwaysCombTerm { always_comb_term };
        // Calling user action here
        self.user_grammar
            .always_comb_term(&always_comb_term_built)?;
        self.push(ASTType::AlwaysCombTerm(always_comb_term_built), context);
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// AlwaysFfTerm: /(?-u:\b)always_ff(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_term(&mut self, always_ff_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_ff_term = always_ff_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let always_ff_term_built = AlwaysFfTerm { always_ff_term };
        // Calling user action here
        self.user_grammar.always_ff_term(&always_ff_term_built)?;
        self.push(ASTType::AlwaysFfTerm(always_ff_term_built), context);
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// AssignTerm: /(?-u:\b)assign(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn assign_term(&mut self, assign_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assign_term = assign_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let assign_term_built = AssignTerm { assign_term };
        // Calling user action here
        self.user_grammar.assign_term(&assign_term_built)?;
        self.push(ASTType::AssignTerm(assign_term_built), context);
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// AsyncHighTerm: /(?-u:\b)async_high(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn async_high_term(&mut self, async_high_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let async_high_term = async_high_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let async_high_term_built = AsyncHighTerm { async_high_term };
        // Calling user action here
        self.user_grammar.async_high_term(&async_high_term_built)?;
        self.push(ASTType::AsyncHighTerm(async_high_term_built), context);
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// AsyncLowTerm: /(?-u:\b)async_low(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn async_low_term(&mut self, async_low_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let async_low_term = async_low_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let async_low_term_built = AsyncLowTerm { async_low_term };
        // Calling user action here
        self.user_grammar.async_low_term(&async_low_term_built)?;
        self.push(ASTType::AsyncLowTerm(async_low_term_built), context);
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// AsTerm: /(?-u:\b)as(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn as_term(&mut self, as_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let as_term = as_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let as_term_built = AsTerm { as_term };
        // Calling user action here
        self.user_grammar.as_term(&as_term_built)?;
        self.push(ASTType::AsTerm(as_term_built), context);
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// BitTerm: /(?-u:\b)bit(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn bit_term(&mut self, bit_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bit_term = bit_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let bit_term_built = BitTerm { bit_term };
        // Calling user action here
        self.user_grammar.bit_term(&bit_term_built)?;
        self.push(ASTType::BitTerm(bit_term_built), context);
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// CaseTerm: /(?-u:\b)case(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn case_term(&mut self, case_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let case_term = case_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let case_term_built = CaseTerm { case_term };
        // Calling user action here
        self.user_grammar.case_term(&case_term_built)?;
        self.push(ASTType::CaseTerm(case_term_built), context);
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// DefaultTerm: /(?-u:\b)default(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn default_term(&mut self, default_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let default_term = default_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let default_term_built = DefaultTerm { default_term };
        // Calling user action here
        self.user_grammar.default_term(&default_term_built)?;
        self.push(ASTType::DefaultTerm(default_term_built), context);
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// ElseTerm: /(?-u:\b)else(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn else_term(&mut self, else_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let else_term = else_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let else_term_built = ElseTerm { else_term };
        // Calling user action here
        self.user_grammar.else_term(&else_term_built)?;
        self.push(ASTType::ElseTerm(else_term_built), context);
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// EnumTerm: /(?-u:\b)enum(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn enum_term(&mut self, enum_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enum_term = enum_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let enum_term_built = EnumTerm { enum_term };
        // Calling user action here
        self.user_grammar.enum_term(&enum_term_built)?;
        self.push(ASTType::EnumTerm(enum_term_built), context);
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// ExportTerm: /(?-u:\b)export(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn export_term(&mut self, export_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let export_term = export_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let export_term_built = ExportTerm { export_term };
        // Calling user action here
        self.user_grammar.export_term(&export_term_built)?;
        self.push(ASTType::ExportTerm(export_term_built), context);
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// F32Term: /(?-u:\b)f32(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn f32_term(&mut self, f32_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f32_term = f32_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let f32_term_built = F32Term { f32_term };
        // Calling user action here
        self.user_grammar.f32_term(&f32_term_built)?;
        self.push(ASTType::F32Term(f32_term_built), context);
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// F64Term: /(?-u:\b)f64(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn f64_term(&mut self, f64_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f64_term = f64_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let f64_term_built = F64Term { f64_term };
        // Calling user action here
        self.user_grammar.f64_term(&f64_term_built)?;
        self.push(ASTType::F64Term(f64_term_built), context);
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// FinalTerm: /(?-u:\b)final(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn final_term(&mut self, final_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let final_term = final_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let final_term_built = FinalTerm { final_term };
        // Calling user action here
        self.user_grammar.final_term(&final_term_built)?;
        self.push(ASTType::FinalTerm(final_term_built), context);
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// ForTerm: /(?-u:\b)for(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn for_term(&mut self, for_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let for_term = for_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let for_term_built = ForTerm { for_term };
        // Calling user action here
        self.user_grammar.for_term(&for_term_built)?;
        self.push(ASTType::ForTerm(for_term_built), context);
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// FunctionTerm: /(?-u:\b)function(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn function_term(&mut self, function_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_term = function_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let function_term_built = FunctionTerm { function_term };
        // Calling user action here
        self.user_grammar.function_term(&function_term_built)?;
        self.push(ASTType::FunctionTerm(function_term_built), context);
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// I32Term: /(?-u:\b)i32(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn i32_term(&mut self, i32_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i32_term = i32_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let i32_term_built = I32Term { i32_term };
        // Calling user action here
        self.user_grammar.i32_term(&i32_term_built)?;
        self.push(ASTType::I32Term(i32_term_built), context);
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// I64Term: /(?-u:\b)i64(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn i64_term(&mut self, i64_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i64_term = i64_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let i64_term_built = I64Term { i64_term };
        // Calling user action here
        self.user_grammar.i64_term(&i64_term_built)?;
        self.push(ASTType::I64Term(i64_term_built), context);
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// IfResetTerm: /(?-u:\b)if_reset(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn if_reset_term(&mut self, if_reset_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_reset_term = if_reset_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let if_reset_term_built = IfResetTerm { if_reset_term };
        // Calling user action here
        self.user_grammar.if_reset_term(&if_reset_term_built)?;
        self.push(ASTType::IfResetTerm(if_reset_term_built), context);
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// IfTerm: /(?-u:\b)if(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn if_term(&mut self, if_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_term = if_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let if_term_built = IfTerm { if_term };
        // Calling user action here
        self.user_grammar.if_term(&if_term_built)?;
        self.push(ASTType::IfTerm(if_term_built), context);
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// ImportTerm: /(?-u:\b)import(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn import_term(&mut self, import_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let import_term = import_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let import_term_built = ImportTerm { import_term };
        // Calling user action here
        self.user_grammar.import_term(&import_term_built)?;
        self.push(ASTType::ImportTerm(import_term_built), context);
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// InitialTerm: /(?-u:\b)initial(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn initial_term(&mut self, initial_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let initial_term = initial_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let initial_term_built = InitialTerm { initial_term };
        // Calling user action here
        self.user_grammar.initial_term(&initial_term_built)?;
        self.push(ASTType::InitialTerm(initial_term_built), context);
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// InoutTerm: /(?-u:\b)inout(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn inout_term(&mut self, inout_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inout_term = inout_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let inout_term_built = InoutTerm { inout_term };
        // Calling user action here
        self.user_grammar.inout_term(&inout_term_built)?;
        self.push(ASTType::InoutTerm(inout_term_built), context);
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// InputTerm: /(?-u:\b)input(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn input_term(&mut self, input_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let input_term = input_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let input_term_built = InputTerm { input_term };
        // Calling user action here
        self.user_grammar.input_term(&input_term_built)?;
        self.push(ASTType::InputTerm(input_term_built), context);
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// InsideTerm: /(?-u:\b)inside(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn inside_term(&mut self, inside_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inside_term = inside_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let inside_term_built = InsideTerm { inside_term };
        // Calling user action here
        self.user_grammar.inside_term(&inside_term_built)?;
        self.push(ASTType::InsideTerm(inside_term_built), context);
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// InstTerm: /(?-u:\b)inst(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn inst_term(&mut self, inst_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_term = inst_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let inst_term_built = InstTerm { inst_term };
        // Calling user action here
        self.user_grammar.inst_term(&inst_term_built)?;
        self.push(ASTType::InstTerm(inst_term_built), context);
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// InterfaceTerm: /(?-u:\b)interface(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn interface_term(&mut self, interface_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_term = interface_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let interface_term_built = InterfaceTerm { interface_term };
        // Calling user action here
        self.user_grammar.interface_term(&interface_term_built)?;
        self.push(ASTType::InterfaceTerm(interface_term_built), context);
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// InTerm: /(?-u:\b)in(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn in_term(&mut self, in_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let in_term = in_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let in_term_built = InTerm { in_term };
        // Calling user action here
        self.user_grammar.in_term(&in_term_built)?;
        self.push(ASTType::InTerm(in_term_built), context);
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// LocalparamTerm: /(?-u:\b)localparam(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn localparam_term(&mut self, localparam_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let localparam_term = localparam_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let localparam_term_built = LocalparamTerm { localparam_term };
        // Calling user action here
        self.user_grammar.localparam_term(&localparam_term_built)?;
        self.push(ASTType::LocalparamTerm(localparam_term_built), context);
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// LogicTerm: /(?-u:\b)logic(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn logic_term(&mut self, logic_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logic_term = logic_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let logic_term_built = LogicTerm { logic_term };
        // Calling user action here
        self.user_grammar.logic_term(&logic_term_built)?;
        self.push(ASTType::LogicTerm(logic_term_built), context);
        Ok(())
    }

    /// Semantic action for production 73:
    ///
    /// LsbTerm: /(?-u:\b)lsb(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn lsb_term(&mut self, lsb_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let lsb_term = lsb_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let lsb_term_built = LsbTerm { lsb_term };
        // Calling user action here
        self.user_grammar.lsb_term(&lsb_term_built)?;
        self.push(ASTType::LsbTerm(lsb_term_built), context);
        Ok(())
    }

    /// Semantic action for production 74:
    ///
    /// ModportTerm: /(?-u:\b)modport(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn modport_term(&mut self, modport_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport_term = modport_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let modport_term_built = ModportTerm { modport_term };
        // Calling user action here
        self.user_grammar.modport_term(&modport_term_built)?;
        self.push(ASTType::ModportTerm(modport_term_built), context);
        Ok(())
    }

    /// Semantic action for production 75:
    ///
    /// ModuleTerm: /(?-u:\b)module(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn module_term(&mut self, module_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_term = module_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let module_term_built = ModuleTerm { module_term };
        // Calling user action here
        self.user_grammar.module_term(&module_term_built)?;
        self.push(ASTType::ModuleTerm(module_term_built), context);
        Ok(())
    }

    /// Semantic action for production 76:
    ///
    /// MsbTerm: /(?-u:\b)msb(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn msb_term(&mut self, msb_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let msb_term = msb_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let msb_term_built = MsbTerm { msb_term };
        // Calling user action here
        self.user_grammar.msb_term(&msb_term_built)?;
        self.push(ASTType::MsbTerm(msb_term_built), context);
        Ok(())
    }

    /// Semantic action for production 77:
    ///
    /// NegedgeTerm: /(?-u:\b)negedge(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn negedge_term(&mut self, negedge_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let negedge_term = negedge_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let negedge_term_built = NegedgeTerm { negedge_term };
        // Calling user action here
        self.user_grammar.negedge_term(&negedge_term_built)?;
        self.push(ASTType::NegedgeTerm(negedge_term_built), context);
        Ok(())
    }

    /// Semantic action for production 78:
    ///
    /// OutputTerm: /(?-u:\b)output(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn output_term(&mut self, output_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let output_term = output_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let output_term_built = OutputTerm { output_term };
        // Calling user action here
        self.user_grammar.output_term(&output_term_built)?;
        self.push(ASTType::OutputTerm(output_term_built), context);
        Ok(())
    }

    /// Semantic action for production 79:
    ///
    /// OutsideTerm: /(?-u:\b)outside(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn outside_term(&mut self, outside_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let outside_term = outside_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let outside_term_built = OutsideTerm { outside_term };
        // Calling user action here
        self.user_grammar.outside_term(&outside_term_built)?;
        self.push(ASTType::OutsideTerm(outside_term_built), context);
        Ok(())
    }

    /// Semantic action for production 80:
    ///
    /// PackageTerm: /(?-u:\b)package(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn package_term(&mut self, package_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let package_term = package_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let package_term_built = PackageTerm { package_term };
        // Calling user action here
        self.user_grammar.package_term(&package_term_built)?;
        self.push(ASTType::PackageTerm(package_term_built), context);
        Ok(())
    }

    /// Semantic action for production 81:
    ///
    /// ParameterTerm: /(?-u:\b)parameter(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn parameter_term(&mut self, parameter_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let parameter_term = parameter_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let parameter_term_built = ParameterTerm { parameter_term };
        // Calling user action here
        self.user_grammar.parameter_term(&parameter_term_built)?;
        self.push(ASTType::ParameterTerm(parameter_term_built), context);
        Ok(())
    }

    /// Semantic action for production 82:
    ///
    /// PosedgeTerm: /(?-u:\b)posedge(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn posedge_term(&mut self, posedge_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let posedge_term = posedge_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let posedge_term_built = PosedgeTerm { posedge_term };
        // Calling user action here
        self.user_grammar.posedge_term(&posedge_term_built)?;
        self.push(ASTType::PosedgeTerm(posedge_term_built), context);
        Ok(())
    }

    /// Semantic action for production 83:
    ///
    /// RefTerm: /(?-u:\b)ref(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn ref_term(&mut self, ref_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ref_term = ref_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let ref_term_built = RefTerm { ref_term };
        // Calling user action here
        self.user_grammar.ref_term(&ref_term_built)?;
        self.push(ASTType::RefTerm(ref_term_built), context);
        Ok(())
    }

    /// Semantic action for production 84:
    ///
    /// RepeatTerm: /(?-u:\b)repeat(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn repeat_term(&mut self, repeat_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let repeat_term = repeat_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let repeat_term_built = RepeatTerm { repeat_term };
        // Calling user action here
        self.user_grammar.repeat_term(&repeat_term_built)?;
        self.push(ASTType::RepeatTerm(repeat_term_built), context);
        Ok(())
    }

    /// Semantic action for production 85:
    ///
    /// ReturnTerm: /(?-u:\b)return(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn return_term(&mut self, return_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let return_term = return_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let return_term_built = ReturnTerm { return_term };
        // Calling user action here
        self.user_grammar.return_term(&return_term_built)?;
        self.push(ASTType::ReturnTerm(return_term_built), context);
        Ok(())
    }

    /// Semantic action for production 86:
    ///
    /// SignedTerm: /(?-u:\b)signed(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn signed_term(&mut self, signed_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let signed_term = signed_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let signed_term_built = SignedTerm { signed_term };
        // Calling user action here
        self.user_grammar.signed_term(&signed_term_built)?;
        self.push(ASTType::SignedTerm(signed_term_built), context);
        Ok(())
    }

    /// Semantic action for production 87:
    ///
    /// StepTerm: /(?-u:\b)step(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn step_term(&mut self, step_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let step_term = step_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let step_term_built = StepTerm { step_term };
        // Calling user action here
        self.user_grammar.step_term(&step_term_built)?;
        self.push(ASTType::StepTerm(step_term_built), context);
        Ok(())
    }

    /// Semantic action for production 88:
    ///
    /// StringTerm: /(?-u:\b)string(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn string_term(&mut self, string_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string_term = string_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let string_term_built = StringTerm { string_term };
        // Calling user action here
        self.user_grammar.string_term(&string_term_built)?;
        self.push(ASTType::StringTerm(string_term_built), context);
        Ok(())
    }

    /// Semantic action for production 89:
    ///
    /// StructTerm: /(?-u:\b)struct(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn struct_term(&mut self, struct_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let struct_term = struct_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let struct_term_built = StructTerm { struct_term };
        // Calling user action here
        self.user_grammar.struct_term(&struct_term_built)?;
        self.push(ASTType::StructTerm(struct_term_built), context);
        Ok(())
    }

    /// Semantic action for production 90:
    ///
    /// SyncHighTerm: /(?-u:\b)sync_high(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn sync_high_term(&mut self, sync_high_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let sync_high_term = sync_high_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let sync_high_term_built = SyncHighTerm { sync_high_term };
        // Calling user action here
        self.user_grammar.sync_high_term(&sync_high_term_built)?;
        self.push(ASTType::SyncHighTerm(sync_high_term_built), context);
        Ok(())
    }

    /// Semantic action for production 91:
    ///
    /// SyncLowTerm: /(?-u:\b)sync_low(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn sync_low_term(&mut self, sync_low_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let sync_low_term = sync_low_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let sync_low_term_built = SyncLowTerm { sync_low_term };
        // Calling user action here
        self.user_grammar.sync_low_term(&sync_low_term_built)?;
        self.push(ASTType::SyncLowTerm(sync_low_term_built), context);
        Ok(())
    }

    /// Semantic action for production 92:
    ///
    /// TriTerm: /(?-u:\b)tri(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn tri_term(&mut self, tri_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tri_term = tri_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let tri_term_built = TriTerm { tri_term };
        // Calling user action here
        self.user_grammar.tri_term(&tri_term_built)?;
        self.push(ASTType::TriTerm(tri_term_built), context);
        Ok(())
    }

    /// Semantic action for production 93:
    ///
    /// TypeTerm: /(?-u:\b)type(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn type_term(&mut self, type_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_term = type_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let type_term_built = TypeTerm { type_term };
        // Calling user action here
        self.user_grammar.type_term(&type_term_built)?;
        self.push(ASTType::TypeTerm(type_term_built), context);
        Ok(())
    }

    /// Semantic action for production 94:
    ///
    /// U32Term: /(?-u:\b)u32(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn u32_term(&mut self, u32_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u32_term = u32_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let u32_term_built = U32Term { u32_term };
        // Calling user action here
        self.user_grammar.u32_term(&u32_term_built)?;
        self.push(ASTType::U32Term(u32_term_built), context);
        Ok(())
    }

    /// Semantic action for production 95:
    ///
    /// U64Term: /(?-u:\b)u64(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn u64_term(&mut self, u64_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u64_term = u64_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let u64_term_built = U64Term { u64_term };
        // Calling user action here
        self.user_grammar.u64_term(&u64_term_built)?;
        self.push(ASTType::U64Term(u64_term_built), context);
        Ok(())
    }

    /// Semantic action for production 96:
    ///
    /// VarTerm: /(?-u:\b)var(?-u:\b)/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn var_term(&mut self, var_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let var_term = var_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let var_term_built = VarTerm { var_term };
        // Calling user action here
        self.user_grammar.var_term(&var_term_built)?;
        self.push(ASTType::VarTerm(var_term_built), context);
        Ok(())
    }

    /// Semantic action for production 97:
    ///
    /// IdentifierTerm: /[a-zA-Z_][0-9a-zA-Z_]*/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn identifier_term(&mut self, identifier_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier_term = identifier_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let identifier_term_built = IdentifierTerm { identifier_term };
        // Calling user action here
        self.user_grammar.identifier_term(&identifier_term_built)?;
        self.push(ASTType::IdentifierTerm(identifier_term_built), context);
        Ok(())
    }

    /// Semantic action for production 98:
    ///
    /// Comments: CommentsOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn comments(&mut self, _comments_opt: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments_opt = pop_item!(self, comments_opt, CommentsOpt, context);
        let comments_built = Comments { comments_opt };
        // Calling user action here
        self.user_grammar.comments(&comments_built)?;
        self.push(ASTType::Comments(comments_built), context);
        Ok(())
    }

    /// Semantic action for production 99:
    ///
    /// CommentsOpt /* Option<T>::Some */: CommentsTerm;
    ///
    #[parol_runtime::function_name::named]
    fn comments_opt_0(&mut self, _comments_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments_term = pop_item!(self, comments_term, CommentsTerm, context);
        let comments_opt_0_built = CommentsOpt {
            comments_term: Box::new(comments_term),
        };
        self.push(
            ASTType::CommentsOpt(Some(Box::new(comments_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 100:
    ///
    /// CommentsOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn comments_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::CommentsOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 101:
    ///
    /// StartToken: Comments;
    ///
    #[parol_runtime::function_name::named]
    fn start_token(&mut self, _comments: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let start_token_built = StartToken {
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.start_token(&start_token_built)?;
        self.push(ASTType::StartToken(start_token_built), context);
        Ok(())
    }

    /// Semantic action for production 102:
    ///
    /// StringLiteralToken: StringLiteralTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn string_literal_token(
        &mut self,
        _string_literal_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let string_literal_term = pop_item!(self, string_literal_term, StringLiteralTerm, context);
        let string_literal_token_built = StringLiteralToken {
            string_literal_term: (&string_literal_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .string_literal_token(&string_literal_token_built)?;
        self.push(
            ASTType::StringLiteralToken(string_literal_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 103:
    ///
    /// ExponentToken: ExponentTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn exponent_token(
        &mut self,
        _exponent_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let exponent_term = pop_item!(self, exponent_term, ExponentTerm, context);
        let exponent_token_built = ExponentToken {
            exponent_term: (&exponent_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.exponent_token(&exponent_token_built)?;
        self.push(ASTType::ExponentToken(exponent_token_built), context);
        Ok(())
    }

    /// Semantic action for production 104:
    ///
    /// FixedPointToken: FixedPointTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn fixed_point_token(
        &mut self,
        _fixed_point_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let fixed_point_term = pop_item!(self, fixed_point_term, FixedPointTerm, context);
        let fixed_point_token_built = FixedPointToken {
            fixed_point_term: (&fixed_point_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .fixed_point_token(&fixed_point_token_built)?;
        self.push(ASTType::FixedPointToken(fixed_point_token_built), context);
        Ok(())
    }

    /// Semantic action for production 105:
    ///
    /// BasedToken: BasedTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn based_token(
        &mut self,
        _based_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let based_term = pop_item!(self, based_term, BasedTerm, context);
        let based_token_built = BasedToken {
            based_term: (&based_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.based_token(&based_token_built)?;
        self.push(ASTType::BasedToken(based_token_built), context);
        Ok(())
    }

    /// Semantic action for production 106:
    ///
    /// BaseLessToken: BaseLessTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn base_less_token(
        &mut self,
        _base_less_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let base_less_term = pop_item!(self, base_less_term, BaseLessTerm, context);
        let base_less_token_built = BaseLessToken {
            base_less_term: (&base_less_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.base_less_token(&base_less_token_built)?;
        self.push(ASTType::BaseLessToken(base_less_token_built), context);
        Ok(())
    }

    /// Semantic action for production 107:
    ///
    /// AllBitToken: AllBitTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn all_bit_token(
        &mut self,
        _all_bit_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let all_bit_term = pop_item!(self, all_bit_term, AllBitTerm, context);
        let all_bit_token_built = AllBitToken {
            all_bit_term: (&all_bit_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.all_bit_token(&all_bit_token_built)?;
        self.push(ASTType::AllBitToken(all_bit_token_built), context);
        Ok(())
    }

    /// Semantic action for production 108:
    ///
    /// AssignmentOperatorToken: AssignmentOperatorTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn assignment_operator_token(
        &mut self,
        _assignment_operator_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let assignment_operator_term = pop_item!(
            self,
            assignment_operator_term,
            AssignmentOperatorTerm,
            context
        );
        let assignment_operator_token_built = AssignmentOperatorToken {
            assignment_operator_term: (&assignment_operator_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .assignment_operator_token(&assignment_operator_token_built)?;
        self.push(
            ASTType::AssignmentOperatorToken(assignment_operator_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 109:
    ///
    /// Operator01Token: Operator01Term : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn operator01_token(
        &mut self,
        _operator01_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let operator01_term = pop_item!(self, operator01_term, Operator01Term, context);
        let operator01_token_built = Operator01Token {
            operator01_term: (&operator01_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .operator01_token(&operator01_token_built)?;
        self.push(ASTType::Operator01Token(operator01_token_built), context);
        Ok(())
    }

    /// Semantic action for production 110:
    ///
    /// Operator02Token: Operator02Term : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn operator02_token(
        &mut self,
        _operator02_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let operator02_term = pop_item!(self, operator02_term, Operator02Term, context);
        let operator02_token_built = Operator02Token {
            operator02_term: (&operator02_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .operator02_token(&operator02_token_built)?;
        self.push(ASTType::Operator02Token(operator02_token_built), context);
        Ok(())
    }

    /// Semantic action for production 111:
    ///
    /// Operator03Token: Operator03Term : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn operator03_token(
        &mut self,
        _operator03_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let operator03_term = pop_item!(self, operator03_term, Operator03Term, context);
        let operator03_token_built = Operator03Token {
            operator03_term: (&operator03_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .operator03_token(&operator03_token_built)?;
        self.push(ASTType::Operator03Token(operator03_token_built), context);
        Ok(())
    }

    /// Semantic action for production 112:
    ///
    /// Operator04Token: Operator04Term : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn operator04_token(
        &mut self,
        _operator04_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let operator04_term = pop_item!(self, operator04_term, Operator04Term, context);
        let operator04_token_built = Operator04Token {
            operator04_term: (&operator04_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .operator04_token(&operator04_token_built)?;
        self.push(ASTType::Operator04Token(operator04_token_built), context);
        Ok(())
    }

    /// Semantic action for production 113:
    ///
    /// Operator05Token: Operator05Term : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn operator05_token(
        &mut self,
        _operator05_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let operator05_term = pop_item!(self, operator05_term, Operator05Term, context);
        let operator05_token_built = Operator05Token {
            operator05_term: (&operator05_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .operator05_token(&operator05_token_built)?;
        self.push(ASTType::Operator05Token(operator05_token_built), context);
        Ok(())
    }

    /// Semantic action for production 114:
    ///
    /// Operator06Token: Operator06Term : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn operator06_token(
        &mut self,
        _operator06_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let operator06_term = pop_item!(self, operator06_term, Operator06Term, context);
        let operator06_token_built = Operator06Token {
            operator06_term: (&operator06_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .operator06_token(&operator06_token_built)?;
        self.push(ASTType::Operator06Token(operator06_token_built), context);
        Ok(())
    }

    /// Semantic action for production 115:
    ///
    /// Operator07Token: Operator07Term : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn operator07_token(
        &mut self,
        _operator07_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let operator07_term = pop_item!(self, operator07_term, Operator07Term, context);
        let operator07_token_built = Operator07Token {
            operator07_term: (&operator07_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .operator07_token(&operator07_token_built)?;
        self.push(ASTType::Operator07Token(operator07_token_built), context);
        Ok(())
    }

    /// Semantic action for production 116:
    ///
    /// Operator08Token: Operator08Term : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn operator08_token(
        &mut self,
        _operator08_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let operator08_term = pop_item!(self, operator08_term, Operator08Term, context);
        let operator08_token_built = Operator08Token {
            operator08_term: (&operator08_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .operator08_token(&operator08_token_built)?;
        self.push(ASTType::Operator08Token(operator08_token_built), context);
        Ok(())
    }

    /// Semantic action for production 117:
    ///
    /// Operator09Token: Operator09Term : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn operator09_token(
        &mut self,
        _operator09_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let operator09_term = pop_item!(self, operator09_term, Operator09Term, context);
        let operator09_token_built = Operator09Token {
            operator09_term: (&operator09_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .operator09_token(&operator09_token_built)?;
        self.push(ASTType::Operator09Token(operator09_token_built), context);
        Ok(())
    }

    /// Semantic action for production 118:
    ///
    /// Operator10Token: Operator10Term : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn operator10_token(
        &mut self,
        _operator10_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let operator10_term = pop_item!(self, operator10_term, Operator10Term, context);
        let operator10_token_built = Operator10Token {
            operator10_term: (&operator10_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .operator10_token(&operator10_token_built)?;
        self.push(ASTType::Operator10Token(operator10_token_built), context);
        Ok(())
    }

    /// Semantic action for production 119:
    ///
    /// Operator11Token: Operator11Term : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn operator11_token(
        &mut self,
        _operator11_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let operator11_term = pop_item!(self, operator11_term, Operator11Term, context);
        let operator11_token_built = Operator11Token {
            operator11_term: (&operator11_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .operator11_token(&operator11_token_built)?;
        self.push(ASTType::Operator11Token(operator11_token_built), context);
        Ok(())
    }

    /// Semantic action for production 120:
    ///
    /// UnaryOperatorToken: UnaryOperatorTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn unary_operator_token(
        &mut self,
        _unary_operator_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let unary_operator_term = pop_item!(self, unary_operator_term, UnaryOperatorTerm, context);
        let unary_operator_token_built = UnaryOperatorToken {
            unary_operator_term: (&unary_operator_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .unary_operator_token(&unary_operator_token_built)?;
        self.push(
            ASTType::UnaryOperatorToken(unary_operator_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 121:
    ///
    /// ColonToken: ColonTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn colon_token(
        &mut self,
        _colon_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let colon_term = pop_item!(self, colon_term, ColonTerm, context);
        let colon_token_built = ColonToken {
            colon_term: (&colon_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.colon_token(&colon_token_built)?;
        self.push(ASTType::ColonToken(colon_token_built), context);
        Ok(())
    }

    /// Semantic action for production 122:
    ///
    /// ColonColonToken: ColonColonTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn colon_colon_token(
        &mut self,
        _colon_colon_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let colon_colon_term = pop_item!(self, colon_colon_term, ColonColonTerm, context);
        let colon_colon_token_built = ColonColonToken {
            colon_colon_term: (&colon_colon_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .colon_colon_token(&colon_colon_token_built)?;
        self.push(ASTType::ColonColonToken(colon_colon_token_built), context);
        Ok(())
    }

    /// Semantic action for production 123:
    ///
    /// CommaToken: CommaTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn comma_token(
        &mut self,
        _comma_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let comma_term = pop_item!(self, comma_term, CommaTerm, context);
        let comma_token_built = CommaToken {
            comma_term: (&comma_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.comma_token(&comma_token_built)?;
        self.push(ASTType::CommaToken(comma_token_built), context);
        Ok(())
    }

    /// Semantic action for production 124:
    ///
    /// DollarToken: DollarTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn dollar_token(
        &mut self,
        _dollar_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let dollar_term = pop_item!(self, dollar_term, DollarTerm, context);
        let dollar_token_built = DollarToken {
            dollar_term: (&dollar_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.dollar_token(&dollar_token_built)?;
        self.push(ASTType::DollarToken(dollar_token_built), context);
        Ok(())
    }

    /// Semantic action for production 125:
    ///
    /// DotDotToken: DotDotTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn dot_dot_token(
        &mut self,
        _dot_dot_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let dot_dot_term = pop_item!(self, dot_dot_term, DotDotTerm, context);
        let dot_dot_token_built = DotDotToken {
            dot_dot_term: (&dot_dot_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.dot_dot_token(&dot_dot_token_built)?;
        self.push(ASTType::DotDotToken(dot_dot_token_built), context);
        Ok(())
    }

    /// Semantic action for production 126:
    ///
    /// DotDotEquToken: DotDotEquTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn dot_dot_equ_token(
        &mut self,
        _dot_dot_equ_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let dot_dot_equ_term = pop_item!(self, dot_dot_equ_term, DotDotEquTerm, context);
        let dot_dot_equ_token_built = DotDotEquToken {
            dot_dot_equ_term: (&dot_dot_equ_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .dot_dot_equ_token(&dot_dot_equ_token_built)?;
        self.push(ASTType::DotDotEquToken(dot_dot_equ_token_built), context);
        Ok(())
    }

    /// Semantic action for production 127:
    ///
    /// DotToken: DotTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn dot_token(
        &mut self,
        _dot_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let dot_term = pop_item!(self, dot_term, DotTerm, context);
        let dot_token_built = DotToken {
            dot_term: (&dot_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.dot_token(&dot_token_built)?;
        self.push(ASTType::DotToken(dot_token_built), context);
        Ok(())
    }

    /// Semantic action for production 128:
    ///
    /// EquToken: EquTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn equ_token(
        &mut self,
        _equ_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let equ_term = pop_item!(self, equ_term, EquTerm, context);
        let equ_token_built = EquToken {
            equ_term: (&equ_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.equ_token(&equ_token_built)?;
        self.push(ASTType::EquToken(equ_token_built), context);
        Ok(())
    }

    /// Semantic action for production 129:
    ///
    /// HashToken: HashTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn hash_token(
        &mut self,
        _hash_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let hash_term = pop_item!(self, hash_term, HashTerm, context);
        let hash_token_built = HashToken {
            hash_term: (&hash_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.hash_token(&hash_token_built)?;
        self.push(ASTType::HashToken(hash_token_built), context);
        Ok(())
    }

    /// Semantic action for production 130:
    ///
    /// LAngleToken: LAngleTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn l_angle_token(
        &mut self,
        _l_angle_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let l_angle_term = pop_item!(self, l_angle_term, LAngleTerm, context);
        let l_angle_token_built = LAngleToken {
            l_angle_term: (&l_angle_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.l_angle_token(&l_angle_token_built)?;
        self.push(ASTType::LAngleToken(l_angle_token_built), context);
        Ok(())
    }

    /// Semantic action for production 131:
    ///
    /// LBraceToken: LBraceTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn l_brace_token(
        &mut self,
        _l_brace_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let l_brace_term = pop_item!(self, l_brace_term, LBraceTerm, context);
        let l_brace_token_built = LBraceToken {
            l_brace_term: (&l_brace_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.l_brace_token(&l_brace_token_built)?;
        self.push(ASTType::LBraceToken(l_brace_token_built), context);
        Ok(())
    }

    /// Semantic action for production 132:
    ///
    /// LBracketToken: LBracketTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn l_bracket_token(
        &mut self,
        _l_bracket_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let l_bracket_term = pop_item!(self, l_bracket_term, LBracketTerm, context);
        let l_bracket_token_built = LBracketToken {
            l_bracket_term: (&l_bracket_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.l_bracket_token(&l_bracket_token_built)?;
        self.push(ASTType::LBracketToken(l_bracket_token_built), context);
        Ok(())
    }

    /// Semantic action for production 133:
    ///
    /// LParenToken: LParenTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn l_paren_token(
        &mut self,
        _l_paren_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let l_paren_term = pop_item!(self, l_paren_term, LParenTerm, context);
        let l_paren_token_built = LParenToken {
            l_paren_term: (&l_paren_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.l_paren_token(&l_paren_token_built)?;
        self.push(ASTType::LParenToken(l_paren_token_built), context);
        Ok(())
    }

    /// Semantic action for production 134:
    ///
    /// MinusColonToken: MinusColonTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn minus_colon_token(
        &mut self,
        _minus_colon_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let minus_colon_term = pop_item!(self, minus_colon_term, MinusColonTerm, context);
        let minus_colon_token_built = MinusColonToken {
            minus_colon_term: (&minus_colon_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .minus_colon_token(&minus_colon_token_built)?;
        self.push(ASTType::MinusColonToken(minus_colon_token_built), context);
        Ok(())
    }

    /// Semantic action for production 135:
    ///
    /// MinusGTToken: MinusGTTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn minus_g_t_token(
        &mut self,
        _minus_g_t_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let minus_g_t_term = pop_item!(self, minus_g_t_term, MinusGTTerm, context);
        let minus_g_t_token_built = MinusGTToken {
            minus_g_t_term: (&minus_g_t_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.minus_g_t_token(&minus_g_t_token_built)?;
        self.push(ASTType::MinusGTToken(minus_g_t_token_built), context);
        Ok(())
    }

    /// Semantic action for production 136:
    ///
    /// PlusColonToken: PlusColonTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn plus_colon_token(
        &mut self,
        _plus_colon_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let plus_colon_term = pop_item!(self, plus_colon_term, PlusColonTerm, context);
        let plus_colon_token_built = PlusColonToken {
            plus_colon_term: (&plus_colon_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .plus_colon_token(&plus_colon_token_built)?;
        self.push(ASTType::PlusColonToken(plus_colon_token_built), context);
        Ok(())
    }

    /// Semantic action for production 137:
    ///
    /// RAngleToken: RAngleTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn r_angle_token(
        &mut self,
        _r_angle_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let r_angle_term = pop_item!(self, r_angle_term, RAngleTerm, context);
        let r_angle_token_built = RAngleToken {
            r_angle_term: (&r_angle_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.r_angle_token(&r_angle_token_built)?;
        self.push(ASTType::RAngleToken(r_angle_token_built), context);
        Ok(())
    }

    /// Semantic action for production 138:
    ///
    /// RBraceToken: RBraceTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn r_brace_token(
        &mut self,
        _r_brace_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let r_brace_term = pop_item!(self, r_brace_term, RBraceTerm, context);
        let r_brace_token_built = RBraceToken {
            r_brace_term: (&r_brace_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.r_brace_token(&r_brace_token_built)?;
        self.push(ASTType::RBraceToken(r_brace_token_built), context);
        Ok(())
    }

    /// Semantic action for production 139:
    ///
    /// RBracketToken: RBracketTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn r_bracket_token(
        &mut self,
        _r_bracket_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let r_bracket_term = pop_item!(self, r_bracket_term, RBracketTerm, context);
        let r_bracket_token_built = RBracketToken {
            r_bracket_term: (&r_bracket_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.r_bracket_token(&r_bracket_token_built)?;
        self.push(ASTType::RBracketToken(r_bracket_token_built), context);
        Ok(())
    }

    /// Semantic action for production 140:
    ///
    /// RParenToken: RParenTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn r_paren_token(
        &mut self,
        _r_paren_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let r_paren_term = pop_item!(self, r_paren_term, RParenTerm, context);
        let r_paren_token_built = RParenToken {
            r_paren_term: (&r_paren_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.r_paren_token(&r_paren_token_built)?;
        self.push(ASTType::RParenToken(r_paren_token_built), context);
        Ok(())
    }

    /// Semantic action for production 141:
    ///
    /// SemicolonToken: SemicolonTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn semicolon_token(
        &mut self,
        _semicolon_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let semicolon_term = pop_item!(self, semicolon_term, SemicolonTerm, context);
        let semicolon_token_built = SemicolonToken {
            semicolon_term: (&semicolon_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.semicolon_token(&semicolon_token_built)?;
        self.push(ASTType::SemicolonToken(semicolon_token_built), context);
        Ok(())
    }

    /// Semantic action for production 142:
    ///
    /// StarToken: StarTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn star_token(
        &mut self,
        _star_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let star_term = pop_item!(self, star_term, StarTerm, context);
        let star_token_built = StarToken {
            star_term: (&star_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.star_token(&star_token_built)?;
        self.push(ASTType::StarToken(star_token_built), context);
        Ok(())
    }

    /// Semantic action for production 143:
    ///
    /// AlwaysCombToken: AlwaysCombTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn always_comb_token(
        &mut self,
        _always_comb_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let always_comb_term = pop_item!(self, always_comb_term, AlwaysCombTerm, context);
        let always_comb_token_built = AlwaysCombToken {
            always_comb_term: (&always_comb_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .always_comb_token(&always_comb_token_built)?;
        self.push(ASTType::AlwaysCombToken(always_comb_token_built), context);
        Ok(())
    }

    /// Semantic action for production 144:
    ///
    /// AlwaysFfToken: AlwaysFfTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_token(
        &mut self,
        _always_ff_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let always_ff_term = pop_item!(self, always_ff_term, AlwaysFfTerm, context);
        let always_ff_token_built = AlwaysFfToken {
            always_ff_term: (&always_ff_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.always_ff_token(&always_ff_token_built)?;
        self.push(ASTType::AlwaysFfToken(always_ff_token_built), context);
        Ok(())
    }

    /// Semantic action for production 145:
    ///
    /// AsToken: AsTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn as_token(
        &mut self,
        _as_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let as_term = pop_item!(self, as_term, AsTerm, context);
        let as_token_built = AsToken {
            as_term: (&as_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.as_token(&as_token_built)?;
        self.push(ASTType::AsToken(as_token_built), context);
        Ok(())
    }

    /// Semantic action for production 146:
    ///
    /// AssignToken: AssignTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn assign_token(
        &mut self,
        _assign_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let assign_term = pop_item!(self, assign_term, AssignTerm, context);
        let assign_token_built = AssignToken {
            assign_term: (&assign_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.assign_token(&assign_token_built)?;
        self.push(ASTType::AssignToken(assign_token_built), context);
        Ok(())
    }

    /// Semantic action for production 147:
    ///
    /// AsyncHighToken: AsyncHighTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn async_high_token(
        &mut self,
        _async_high_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let async_high_term = pop_item!(self, async_high_term, AsyncHighTerm, context);
        let async_high_token_built = AsyncHighToken {
            async_high_term: (&async_high_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .async_high_token(&async_high_token_built)?;
        self.push(ASTType::AsyncHighToken(async_high_token_built), context);
        Ok(())
    }

    /// Semantic action for production 148:
    ///
    /// AsyncLowToken: AsyncLowTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn async_low_token(
        &mut self,
        _async_low_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let async_low_term = pop_item!(self, async_low_term, AsyncLowTerm, context);
        let async_low_token_built = AsyncLowToken {
            async_low_term: (&async_low_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.async_low_token(&async_low_token_built)?;
        self.push(ASTType::AsyncLowToken(async_low_token_built), context);
        Ok(())
    }

    /// Semantic action for production 149:
    ///
    /// BitToken: BitTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn bit_token(
        &mut self,
        _bit_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let bit_term = pop_item!(self, bit_term, BitTerm, context);
        let bit_token_built = BitToken {
            bit_term: (&bit_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.bit_token(&bit_token_built)?;
        self.push(ASTType::BitToken(bit_token_built), context);
        Ok(())
    }

    /// Semantic action for production 150:
    ///
    /// CaseToken: CaseTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn case_token(
        &mut self,
        _case_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let case_term = pop_item!(self, case_term, CaseTerm, context);
        let case_token_built = CaseToken {
            case_term: (&case_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.case_token(&case_token_built)?;
        self.push(ASTType::CaseToken(case_token_built), context);
        Ok(())
    }

    /// Semantic action for production 151:
    ///
    /// DefaultToken: DefaultTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn default_token(
        &mut self,
        _default_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let default_term = pop_item!(self, default_term, DefaultTerm, context);
        let default_token_built = DefaultToken {
            default_term: (&default_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.default_token(&default_token_built)?;
        self.push(ASTType::DefaultToken(default_token_built), context);
        Ok(())
    }

    /// Semantic action for production 152:
    ///
    /// ElseToken: ElseTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn else_token(
        &mut self,
        _else_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let else_term = pop_item!(self, else_term, ElseTerm, context);
        let else_token_built = ElseToken {
            else_term: (&else_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.else_token(&else_token_built)?;
        self.push(ASTType::ElseToken(else_token_built), context);
        Ok(())
    }

    /// Semantic action for production 153:
    ///
    /// EnumToken: EnumTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn enum_token(
        &mut self,
        _enum_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let enum_term = pop_item!(self, enum_term, EnumTerm, context);
        let enum_token_built = EnumToken {
            enum_term: (&enum_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.enum_token(&enum_token_built)?;
        self.push(ASTType::EnumToken(enum_token_built), context);
        Ok(())
    }

    /// Semantic action for production 154:
    ///
    /// ExportToken: ExportTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn export_token(
        &mut self,
        _export_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let export_term = pop_item!(self, export_term, ExportTerm, context);
        let export_token_built = ExportToken {
            export_term: (&export_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.export_token(&export_token_built)?;
        self.push(ASTType::ExportToken(export_token_built), context);
        Ok(())
    }

    /// Semantic action for production 155:
    ///
    /// F32Token: F32Term : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn f32_token(
        &mut self,
        _f32_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let f32_term = pop_item!(self, f32_term, F32Term, context);
        let f32_token_built = F32Token {
            f32_term: (&f32_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.f32_token(&f32_token_built)?;
        self.push(ASTType::F32Token(f32_token_built), context);
        Ok(())
    }

    /// Semantic action for production 156:
    ///
    /// F64Token: F64Term : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn f64_token(
        &mut self,
        _f64_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let f64_term = pop_item!(self, f64_term, F64Term, context);
        let f64_token_built = F64Token {
            f64_term: (&f64_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.f64_token(&f64_token_built)?;
        self.push(ASTType::F64Token(f64_token_built), context);
        Ok(())
    }

    /// Semantic action for production 157:
    ///
    /// FinalToken: FinalTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn final_token(
        &mut self,
        _final_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let final_term = pop_item!(self, final_term, FinalTerm, context);
        let final_token_built = FinalToken {
            final_term: (&final_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.final_token(&final_token_built)?;
        self.push(ASTType::FinalToken(final_token_built), context);
        Ok(())
    }

    /// Semantic action for production 158:
    ///
    /// ForToken: ForTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn for_token(
        &mut self,
        _for_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let for_term = pop_item!(self, for_term, ForTerm, context);
        let for_token_built = ForToken {
            for_term: (&for_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.for_token(&for_token_built)?;
        self.push(ASTType::ForToken(for_token_built), context);
        Ok(())
    }

    /// Semantic action for production 159:
    ///
    /// FunctionToken: FunctionTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn function_token(
        &mut self,
        _function_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let function_term = pop_item!(self, function_term, FunctionTerm, context);
        let function_token_built = FunctionToken {
            function_term: (&function_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.function_token(&function_token_built)?;
        self.push(ASTType::FunctionToken(function_token_built), context);
        Ok(())
    }

    /// Semantic action for production 160:
    ///
    /// I32Token: I32Term : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn i32_token(
        &mut self,
        _i32_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let i32_term = pop_item!(self, i32_term, I32Term, context);
        let i32_token_built = I32Token {
            i32_term: (&i32_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.i32_token(&i32_token_built)?;
        self.push(ASTType::I32Token(i32_token_built), context);
        Ok(())
    }

    /// Semantic action for production 161:
    ///
    /// I64Token: I64Term : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn i64_token(
        &mut self,
        _i64_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let i64_term = pop_item!(self, i64_term, I64Term, context);
        let i64_token_built = I64Token {
            i64_term: (&i64_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.i64_token(&i64_token_built)?;
        self.push(ASTType::I64Token(i64_token_built), context);
        Ok(())
    }

    /// Semantic action for production 162:
    ///
    /// IfResetToken: IfResetTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn if_reset_token(
        &mut self,
        _if_reset_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let if_reset_term = pop_item!(self, if_reset_term, IfResetTerm, context);
        let if_reset_token_built = IfResetToken {
            if_reset_term: (&if_reset_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.if_reset_token(&if_reset_token_built)?;
        self.push(ASTType::IfResetToken(if_reset_token_built), context);
        Ok(())
    }

    /// Semantic action for production 163:
    ///
    /// IfToken: IfTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn if_token(
        &mut self,
        _if_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let if_term = pop_item!(self, if_term, IfTerm, context);
        let if_token_built = IfToken {
            if_term: (&if_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.if_token(&if_token_built)?;
        self.push(ASTType::IfToken(if_token_built), context);
        Ok(())
    }

    /// Semantic action for production 164:
    ///
    /// ImportToken: ImportTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn import_token(
        &mut self,
        _import_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let import_term = pop_item!(self, import_term, ImportTerm, context);
        let import_token_built = ImportToken {
            import_term: (&import_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.import_token(&import_token_built)?;
        self.push(ASTType::ImportToken(import_token_built), context);
        Ok(())
    }

    /// Semantic action for production 165:
    ///
    /// InitialToken: InitialTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn initial_token(
        &mut self,
        _initial_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let initial_term = pop_item!(self, initial_term, InitialTerm, context);
        let initial_token_built = InitialToken {
            initial_term: (&initial_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.initial_token(&initial_token_built)?;
        self.push(ASTType::InitialToken(initial_token_built), context);
        Ok(())
    }

    /// Semantic action for production 166:
    ///
    /// InoutToken: InoutTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn inout_token(
        &mut self,
        _inout_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let inout_term = pop_item!(self, inout_term, InoutTerm, context);
        let inout_token_built = InoutToken {
            inout_term: (&inout_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.inout_token(&inout_token_built)?;
        self.push(ASTType::InoutToken(inout_token_built), context);
        Ok(())
    }

    /// Semantic action for production 167:
    ///
    /// InputToken: InputTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn input_token(
        &mut self,
        _input_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let input_term = pop_item!(self, input_term, InputTerm, context);
        let input_token_built = InputToken {
            input_term: (&input_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.input_token(&input_token_built)?;
        self.push(ASTType::InputToken(input_token_built), context);
        Ok(())
    }

    /// Semantic action for production 168:
    ///
    /// InsideToken: InsideTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn inside_token(
        &mut self,
        _inside_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let inside_term = pop_item!(self, inside_term, InsideTerm, context);
        let inside_token_built = InsideToken {
            inside_term: (&inside_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.inside_token(&inside_token_built)?;
        self.push(ASTType::InsideToken(inside_token_built), context);
        Ok(())
    }

    /// Semantic action for production 169:
    ///
    /// InstToken: InstTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn inst_token(
        &mut self,
        _inst_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let inst_term = pop_item!(self, inst_term, InstTerm, context);
        let inst_token_built = InstToken {
            inst_term: (&inst_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.inst_token(&inst_token_built)?;
        self.push(ASTType::InstToken(inst_token_built), context);
        Ok(())
    }

    /// Semantic action for production 170:
    ///
    /// InterfaceToken: InterfaceTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn interface_token(
        &mut self,
        _interface_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let interface_term = pop_item!(self, interface_term, InterfaceTerm, context);
        let interface_token_built = InterfaceToken {
            interface_term: (&interface_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.interface_token(&interface_token_built)?;
        self.push(ASTType::InterfaceToken(interface_token_built), context);
        Ok(())
    }

    /// Semantic action for production 171:
    ///
    /// InToken: InTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn in_token(
        &mut self,
        _in_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let in_term = pop_item!(self, in_term, InTerm, context);
        let in_token_built = InToken {
            in_term: (&in_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.in_token(&in_token_built)?;
        self.push(ASTType::InToken(in_token_built), context);
        Ok(())
    }

    /// Semantic action for production 172:
    ///
    /// LocalparamToken: LocalparamTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn localparam_token(
        &mut self,
        _localparam_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let localparam_term = pop_item!(self, localparam_term, LocalparamTerm, context);
        let localparam_token_built = LocalparamToken {
            localparam_term: (&localparam_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .localparam_token(&localparam_token_built)?;
        self.push(ASTType::LocalparamToken(localparam_token_built), context);
        Ok(())
    }

    /// Semantic action for production 173:
    ///
    /// LogicToken: LogicTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn logic_token(
        &mut self,
        _logic_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let logic_term = pop_item!(self, logic_term, LogicTerm, context);
        let logic_token_built = LogicToken {
            logic_term: (&logic_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.logic_token(&logic_token_built)?;
        self.push(ASTType::LogicToken(logic_token_built), context);
        Ok(())
    }

    /// Semantic action for production 174:
    ///
    /// LsbToken: LsbTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn lsb_token(
        &mut self,
        _lsb_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let lsb_term = pop_item!(self, lsb_term, LsbTerm, context);
        let lsb_token_built = LsbToken {
            lsb_term: (&lsb_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.lsb_token(&lsb_token_built)?;
        self.push(ASTType::LsbToken(lsb_token_built), context);
        Ok(())
    }

    /// Semantic action for production 175:
    ///
    /// ModportToken: ModportTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn modport_token(
        &mut self,
        _modport_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let modport_term = pop_item!(self, modport_term, ModportTerm, context);
        let modport_token_built = ModportToken {
            modport_term: (&modport_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.modport_token(&modport_token_built)?;
        self.push(ASTType::ModportToken(modport_token_built), context);
        Ok(())
    }

    /// Semantic action for production 176:
    ///
    /// ModuleToken: ModuleTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn module_token(
        &mut self,
        _module_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let module_term = pop_item!(self, module_term, ModuleTerm, context);
        let module_token_built = ModuleToken {
            module_term: (&module_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.module_token(&module_token_built)?;
        self.push(ASTType::ModuleToken(module_token_built), context);
        Ok(())
    }

    /// Semantic action for production 177:
    ///
    /// MsbToken: MsbTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn msb_token(
        &mut self,
        _msb_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let msb_term = pop_item!(self, msb_term, MsbTerm, context);
        let msb_token_built = MsbToken {
            msb_term: (&msb_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.msb_token(&msb_token_built)?;
        self.push(ASTType::MsbToken(msb_token_built), context);
        Ok(())
    }

    /// Semantic action for production 178:
    ///
    /// NegedgeToken: NegedgeTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn negedge_token(
        &mut self,
        _negedge_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let negedge_term = pop_item!(self, negedge_term, NegedgeTerm, context);
        let negedge_token_built = NegedgeToken {
            negedge_term: (&negedge_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.negedge_token(&negedge_token_built)?;
        self.push(ASTType::NegedgeToken(negedge_token_built), context);
        Ok(())
    }

    /// Semantic action for production 179:
    ///
    /// OutputToken: OutputTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn output_token(
        &mut self,
        _output_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let output_term = pop_item!(self, output_term, OutputTerm, context);
        let output_token_built = OutputToken {
            output_term: (&output_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.output_token(&output_token_built)?;
        self.push(ASTType::OutputToken(output_token_built), context);
        Ok(())
    }

    /// Semantic action for production 180:
    ///
    /// OutsideToken: OutsideTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn outside_token(
        &mut self,
        _outside_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let outside_term = pop_item!(self, outside_term, OutsideTerm, context);
        let outside_token_built = OutsideToken {
            outside_term: (&outside_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.outside_token(&outside_token_built)?;
        self.push(ASTType::OutsideToken(outside_token_built), context);
        Ok(())
    }

    /// Semantic action for production 181:
    ///
    /// PackageToken: PackageTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn package_token(
        &mut self,
        _package_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let package_term = pop_item!(self, package_term, PackageTerm, context);
        let package_token_built = PackageToken {
            package_term: (&package_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.package_token(&package_token_built)?;
        self.push(ASTType::PackageToken(package_token_built), context);
        Ok(())
    }

    /// Semantic action for production 182:
    ///
    /// ParameterToken: ParameterTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn parameter_token(
        &mut self,
        _parameter_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let parameter_term = pop_item!(self, parameter_term, ParameterTerm, context);
        let parameter_token_built = ParameterToken {
            parameter_term: (&parameter_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.parameter_token(&parameter_token_built)?;
        self.push(ASTType::ParameterToken(parameter_token_built), context);
        Ok(())
    }

    /// Semantic action for production 183:
    ///
    /// PosedgeToken: PosedgeTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn posedge_token(
        &mut self,
        _posedge_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let posedge_term = pop_item!(self, posedge_term, PosedgeTerm, context);
        let posedge_token_built = PosedgeToken {
            posedge_term: (&posedge_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.posedge_token(&posedge_token_built)?;
        self.push(ASTType::PosedgeToken(posedge_token_built), context);
        Ok(())
    }

    /// Semantic action for production 184:
    ///
    /// RefToken: RefTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn ref_token(
        &mut self,
        _ref_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let ref_term = pop_item!(self, ref_term, RefTerm, context);
        let ref_token_built = RefToken {
            ref_term: (&ref_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.ref_token(&ref_token_built)?;
        self.push(ASTType::RefToken(ref_token_built), context);
        Ok(())
    }

    /// Semantic action for production 185:
    ///
    /// RepeatToken: RepeatTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn repeat_token(
        &mut self,
        _repeat_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let repeat_term = pop_item!(self, repeat_term, RepeatTerm, context);
        let repeat_token_built = RepeatToken {
            repeat_term: (&repeat_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.repeat_token(&repeat_token_built)?;
        self.push(ASTType::RepeatToken(repeat_token_built), context);
        Ok(())
    }

    /// Semantic action for production 186:
    ///
    /// ReturnToken: ReturnTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn return_token(
        &mut self,
        _return_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let return_term = pop_item!(self, return_term, ReturnTerm, context);
        let return_token_built = ReturnToken {
            return_term: (&return_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.return_token(&return_token_built)?;
        self.push(ASTType::ReturnToken(return_token_built), context);
        Ok(())
    }

    /// Semantic action for production 187:
    ///
    /// SignedToken: SignedTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn signed_token(
        &mut self,
        _signed_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let signed_term = pop_item!(self, signed_term, SignedTerm, context);
        let signed_token_built = SignedToken {
            signed_term: (&signed_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.signed_token(&signed_token_built)?;
        self.push(ASTType::SignedToken(signed_token_built), context);
        Ok(())
    }

    /// Semantic action for production 188:
    ///
    /// StepToken: StepTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn step_token(
        &mut self,
        _step_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let step_term = pop_item!(self, step_term, StepTerm, context);
        let step_token_built = StepToken {
            step_term: (&step_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.step_token(&step_token_built)?;
        self.push(ASTType::StepToken(step_token_built), context);
        Ok(())
    }

    /// Semantic action for production 189:
    ///
    /// StringToken: StringTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn string_token(
        &mut self,
        _string_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let string_term = pop_item!(self, string_term, StringTerm, context);
        let string_token_built = StringToken {
            string_term: (&string_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.string_token(&string_token_built)?;
        self.push(ASTType::StringToken(string_token_built), context);
        Ok(())
    }

    /// Semantic action for production 190:
    ///
    /// StructToken: StructTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn struct_token(
        &mut self,
        _struct_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let struct_term = pop_item!(self, struct_term, StructTerm, context);
        let struct_token_built = StructToken {
            struct_term: (&struct_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.struct_token(&struct_token_built)?;
        self.push(ASTType::StructToken(struct_token_built), context);
        Ok(())
    }

    /// Semantic action for production 191:
    ///
    /// SyncHighToken: SyncHighTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn sync_high_token(
        &mut self,
        _sync_high_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let sync_high_term = pop_item!(self, sync_high_term, SyncHighTerm, context);
        let sync_high_token_built = SyncHighToken {
            sync_high_term: (&sync_high_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.sync_high_token(&sync_high_token_built)?;
        self.push(ASTType::SyncHighToken(sync_high_token_built), context);
        Ok(())
    }

    /// Semantic action for production 192:
    ///
    /// SyncLowToken: SyncLowTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn sync_low_token(
        &mut self,
        _sync_low_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let sync_low_term = pop_item!(self, sync_low_term, SyncLowTerm, context);
        let sync_low_token_built = SyncLowToken {
            sync_low_term: (&sync_low_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.sync_low_token(&sync_low_token_built)?;
        self.push(ASTType::SyncLowToken(sync_low_token_built), context);
        Ok(())
    }

    /// Semantic action for production 193:
    ///
    /// TriToken: TriTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn tri_token(
        &mut self,
        _tri_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let tri_term = pop_item!(self, tri_term, TriTerm, context);
        let tri_token_built = TriToken {
            tri_term: (&tri_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.tri_token(&tri_token_built)?;
        self.push(ASTType::TriToken(tri_token_built), context);
        Ok(())
    }

    /// Semantic action for production 194:
    ///
    /// TypeToken: TypeTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn type_token(
        &mut self,
        _type_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let type_term = pop_item!(self, type_term, TypeTerm, context);
        let type_token_built = TypeToken {
            type_term: (&type_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.type_token(&type_token_built)?;
        self.push(ASTType::TypeToken(type_token_built), context);
        Ok(())
    }

    /// Semantic action for production 195:
    ///
    /// U32Token: U32Term : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn u32_token(
        &mut self,
        _u32_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let u32_term = pop_item!(self, u32_term, U32Term, context);
        let u32_token_built = U32Token {
            u32_term: (&u32_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.u32_token(&u32_token_built)?;
        self.push(ASTType::U32Token(u32_token_built), context);
        Ok(())
    }

    /// Semantic action for production 196:
    ///
    /// U64Token: U64Term : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn u64_token(
        &mut self,
        _u64_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let u64_term = pop_item!(self, u64_term, U64Term, context);
        let u64_token_built = U64Token {
            u64_term: (&u64_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.u64_token(&u64_token_built)?;
        self.push(ASTType::U64Token(u64_token_built), context);
        Ok(())
    }

    /// Semantic action for production 197:
    ///
    /// VarToken: VarTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn var_token(
        &mut self,
        _var_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let var_term = pop_item!(self, var_term, VarTerm, context);
        let var_token_built = VarToken {
            var_term: (&var_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.var_token(&var_token_built)?;
        self.push(ASTType::VarToken(var_token_built), context);
        Ok(())
    }

    /// Semantic action for production 198:
    ///
    /// IdentifierToken: IdentifierTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn identifier_token(
        &mut self,
        _identifier_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let identifier_term = pop_item!(self, identifier_term, IdentifierTerm, context);
        let identifier_token_built = IdentifierToken {
            identifier_term: (&identifier_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .identifier_token(&identifier_token_built)?;
        self.push(ASTType::IdentifierToken(identifier_token_built), context);
        Ok(())
    }

    /// Semantic action for production 199:
    ///
    /// Start: StartToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn start(&mut self, _start_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let start_token = pop_item!(self, start_token, StartToken, context);
        let start_built = Start {
            start_token: (&start_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.start(&start_built)?;
        self.push(ASTType::Start(start_built), context);
        Ok(())
    }

    /// Semantic action for production 200:
    ///
    /// StringLiteral: StringLiteralToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn string_literal(&mut self, _string_literal_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string_literal_token =
            pop_item!(self, string_literal_token, StringLiteralToken, context);
        let string_literal_built = StringLiteral {
            string_literal_token: (&string_literal_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.string_literal(&string_literal_built)?;
        self.push(ASTType::StringLiteral(string_literal_built), context);
        Ok(())
    }

    /// Semantic action for production 201:
    ///
    /// Exponent: ExponentToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn exponent(&mut self, _exponent_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let exponent_token = pop_item!(self, exponent_token, ExponentToken, context);
        let exponent_built = Exponent {
            exponent_token: (&exponent_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.exponent(&exponent_built)?;
        self.push(ASTType::Exponent(exponent_built), context);
        Ok(())
    }

    /// Semantic action for production 202:
    ///
    /// FixedPoint: FixedPointToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn fixed_point(&mut self, _fixed_point_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let fixed_point_token = pop_item!(self, fixed_point_token, FixedPointToken, context);
        let fixed_point_built = FixedPoint {
            fixed_point_token: (&fixed_point_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.fixed_point(&fixed_point_built)?;
        self.push(ASTType::FixedPoint(fixed_point_built), context);
        Ok(())
    }

    /// Semantic action for production 203:
    ///
    /// Based: BasedToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn based(&mut self, _based_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let based_token = pop_item!(self, based_token, BasedToken, context);
        let based_built = Based {
            based_token: (&based_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.based(&based_built)?;
        self.push(ASTType::Based(based_built), context);
        Ok(())
    }

    /// Semantic action for production 204:
    ///
    /// BaseLess: BaseLessToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn base_less(&mut self, _base_less_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let base_less_token = pop_item!(self, base_less_token, BaseLessToken, context);
        let base_less_built = BaseLess {
            base_less_token: (&base_less_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.base_less(&base_less_built)?;
        self.push(ASTType::BaseLess(base_less_built), context);
        Ok(())
    }

    /// Semantic action for production 205:
    ///
    /// AllBit: AllBitToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn all_bit(&mut self, _all_bit_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let all_bit_token = pop_item!(self, all_bit_token, AllBitToken, context);
        let all_bit_built = AllBit {
            all_bit_token: (&all_bit_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.all_bit(&all_bit_built)?;
        self.push(ASTType::AllBit(all_bit_built), context);
        Ok(())
    }

    /// Semantic action for production 206:
    ///
    /// AssignmentOperator: AssignmentOperatorToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn assignment_operator(
        &mut self,
        _assignment_operator_token: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assignment_operator_token = pop_item!(
            self,
            assignment_operator_token,
            AssignmentOperatorToken,
            context
        );
        let assignment_operator_built = AssignmentOperator {
            assignment_operator_token: (&assignment_operator_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar
            .assignment_operator(&assignment_operator_built)?;
        self.push(
            ASTType::AssignmentOperator(assignment_operator_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 207:
    ///
    /// Operator01: Operator01Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn operator01(&mut self, _operator01_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator01_token = pop_item!(self, operator01_token, Operator01Token, context);
        let operator01_built = Operator01 {
            operator01_token: (&operator01_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.operator01(&operator01_built)?;
        self.push(ASTType::Operator01(operator01_built), context);
        Ok(())
    }

    /// Semantic action for production 208:
    ///
    /// Operator02: Operator02Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn operator02(&mut self, _operator02_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator02_token = pop_item!(self, operator02_token, Operator02Token, context);
        let operator02_built = Operator02 {
            operator02_token: (&operator02_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.operator02(&operator02_built)?;
        self.push(ASTType::Operator02(operator02_built), context);
        Ok(())
    }

    /// Semantic action for production 209:
    ///
    /// Operator03: Operator03Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn operator03(&mut self, _operator03_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator03_token = pop_item!(self, operator03_token, Operator03Token, context);
        let operator03_built = Operator03 {
            operator03_token: (&operator03_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.operator03(&operator03_built)?;
        self.push(ASTType::Operator03(operator03_built), context);
        Ok(())
    }

    /// Semantic action for production 210:
    ///
    /// Operator04: Operator04Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn operator04(&mut self, _operator04_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator04_token = pop_item!(self, operator04_token, Operator04Token, context);
        let operator04_built = Operator04 {
            operator04_token: (&operator04_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.operator04(&operator04_built)?;
        self.push(ASTType::Operator04(operator04_built), context);
        Ok(())
    }

    /// Semantic action for production 211:
    ///
    /// Operator05: Operator05Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn operator05(&mut self, _operator05_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator05_token = pop_item!(self, operator05_token, Operator05Token, context);
        let operator05_built = Operator05 {
            operator05_token: (&operator05_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.operator05(&operator05_built)?;
        self.push(ASTType::Operator05(operator05_built), context);
        Ok(())
    }

    /// Semantic action for production 212:
    ///
    /// Operator06: Operator06Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn operator06(&mut self, _operator06_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator06_token = pop_item!(self, operator06_token, Operator06Token, context);
        let operator06_built = Operator06 {
            operator06_token: (&operator06_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.operator06(&operator06_built)?;
        self.push(ASTType::Operator06(operator06_built), context);
        Ok(())
    }

    /// Semantic action for production 213:
    ///
    /// Operator07: Operator07Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn operator07(&mut self, _operator07_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator07_token = pop_item!(self, operator07_token, Operator07Token, context);
        let operator07_built = Operator07 {
            operator07_token: (&operator07_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.operator07(&operator07_built)?;
        self.push(ASTType::Operator07(operator07_built), context);
        Ok(())
    }

    /// Semantic action for production 214:
    ///
    /// Operator08: Operator08Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn operator08(&mut self, _operator08_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator08_token = pop_item!(self, operator08_token, Operator08Token, context);
        let operator08_built = Operator08 {
            operator08_token: (&operator08_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.operator08(&operator08_built)?;
        self.push(ASTType::Operator08(operator08_built), context);
        Ok(())
    }

    /// Semantic action for production 215:
    ///
    /// Operator09: Operator09Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn operator09(&mut self, _operator09_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator09_token = pop_item!(self, operator09_token, Operator09Token, context);
        let operator09_built = Operator09 {
            operator09_token: (&operator09_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.operator09(&operator09_built)?;
        self.push(ASTType::Operator09(operator09_built), context);
        Ok(())
    }

    /// Semantic action for production 216:
    ///
    /// Operator10: Operator10Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn operator10(&mut self, _operator10_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator10_token = pop_item!(self, operator10_token, Operator10Token, context);
        let operator10_built = Operator10 {
            operator10_token: (&operator10_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.operator10(&operator10_built)?;
        self.push(ASTType::Operator10(operator10_built), context);
        Ok(())
    }

    /// Semantic action for production 217:
    ///
    /// Operator11: Operator11Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn operator11(&mut self, _operator11_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator11_token = pop_item!(self, operator11_token, Operator11Token, context);
        let operator11_built = Operator11 {
            operator11_token: (&operator11_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.operator11(&operator11_built)?;
        self.push(ASTType::Operator11(operator11_built), context);
        Ok(())
    }

    /// Semantic action for production 218:
    ///
    /// UnaryOperator: UnaryOperatorToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn unary_operator(&mut self, _unary_operator_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unary_operator_token =
            pop_item!(self, unary_operator_token, UnaryOperatorToken, context);
        let unary_operator_built = UnaryOperator {
            unary_operator_token: (&unary_operator_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.unary_operator(&unary_operator_built)?;
        self.push(ASTType::UnaryOperator(unary_operator_built), context);
        Ok(())
    }

    /// Semantic action for production 219:
    ///
    /// Colon: ColonToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn colon(&mut self, _colon_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon_token = pop_item!(self, colon_token, ColonToken, context);
        let colon_built = Colon {
            colon_token: (&colon_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.colon(&colon_built)?;
        self.push(ASTType::Colon(colon_built), context);
        Ok(())
    }

    /// Semantic action for production 220:
    ///
    /// ColonColon: ColonColonToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn colon_colon(&mut self, _colon_colon_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon_colon_token = pop_item!(self, colon_colon_token, ColonColonToken, context);
        let colon_colon_built = ColonColon {
            colon_colon_token: (&colon_colon_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.colon_colon(&colon_colon_built)?;
        self.push(ASTType::ColonColon(colon_colon_built), context);
        Ok(())
    }

    /// Semantic action for production 221:
    ///
    /// Comma: CommaToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn comma(&mut self, _comma_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma_token = pop_item!(self, comma_token, CommaToken, context);
        let comma_built = Comma {
            comma_token: (&comma_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.comma(&comma_built)?;
        self.push(ASTType::Comma(comma_built), context);
        Ok(())
    }

    /// Semantic action for production 222:
    ///
    /// Dollar: DollarToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn dollar(&mut self, _dollar_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dollar_token = pop_item!(self, dollar_token, DollarToken, context);
        let dollar_built = Dollar {
            dollar_token: (&dollar_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.dollar(&dollar_built)?;
        self.push(ASTType::Dollar(dollar_built), context);
        Ok(())
    }

    /// Semantic action for production 223:
    ///
    /// DotDot: DotDotToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn dot_dot(&mut self, _dot_dot_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_dot_token = pop_item!(self, dot_dot_token, DotDotToken, context);
        let dot_dot_built = DotDot {
            dot_dot_token: (&dot_dot_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.dot_dot(&dot_dot_built)?;
        self.push(ASTType::DotDot(dot_dot_built), context);
        Ok(())
    }

    /// Semantic action for production 224:
    ///
    /// DotDotEqu: DotDotEquToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn dot_dot_equ(&mut self, _dot_dot_equ_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_dot_equ_token = pop_item!(self, dot_dot_equ_token, DotDotEquToken, context);
        let dot_dot_equ_built = DotDotEqu {
            dot_dot_equ_token: (&dot_dot_equ_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.dot_dot_equ(&dot_dot_equ_built)?;
        self.push(ASTType::DotDotEqu(dot_dot_equ_built), context);
        Ok(())
    }

    /// Semantic action for production 225:
    ///
    /// Dot: DotToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn dot(&mut self, _dot_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_token = pop_item!(self, dot_token, DotToken, context);
        let dot_built = Dot {
            dot_token: (&dot_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.dot(&dot_built)?;
        self.push(ASTType::Dot(dot_built), context);
        Ok(())
    }

    /// Semantic action for production 226:
    ///
    /// Equ: EquToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn equ(&mut self, _equ_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equ_token = pop_item!(self, equ_token, EquToken, context);
        let equ_built = Equ {
            equ_token: (&equ_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.equ(&equ_built)?;
        self.push(ASTType::Equ(equ_built), context);
        Ok(())
    }

    /// Semantic action for production 227:
    ///
    /// Hash: HashToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn hash(&mut self, _hash_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hash_token = pop_item!(self, hash_token, HashToken, context);
        let hash_built = Hash {
            hash_token: (&hash_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.hash(&hash_built)?;
        self.push(ASTType::Hash(hash_built), context);
        Ok(())
    }

    /// Semantic action for production 228:
    ///
    /// LAngle: LAngleToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn l_angle(&mut self, _l_angle_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_angle_token = pop_item!(self, l_angle_token, LAngleToken, context);
        let l_angle_built = LAngle {
            l_angle_token: (&l_angle_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.l_angle(&l_angle_built)?;
        self.push(ASTType::LAngle(l_angle_built), context);
        Ok(())
    }

    /// Semantic action for production 229:
    ///
    /// LBrace: LBraceToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn l_brace(&mut self, _l_brace_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_brace_token = pop_item!(self, l_brace_token, LBraceToken, context);
        let l_brace_built = LBrace {
            l_brace_token: (&l_brace_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.l_brace(&l_brace_built)?;
        self.push(ASTType::LBrace(l_brace_built), context);
        Ok(())
    }

    /// Semantic action for production 230:
    ///
    /// LBracket: LBracketToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn l_bracket(&mut self, _l_bracket_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_bracket_token = pop_item!(self, l_bracket_token, LBracketToken, context);
        let l_bracket_built = LBracket {
            l_bracket_token: (&l_bracket_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.l_bracket(&l_bracket_built)?;
        self.push(ASTType::LBracket(l_bracket_built), context);
        Ok(())
    }

    /// Semantic action for production 231:
    ///
    /// LParen: LParenToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn l_paren(&mut self, _l_paren_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_paren_token = pop_item!(self, l_paren_token, LParenToken, context);
        let l_paren_built = LParen {
            l_paren_token: (&l_paren_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.l_paren(&l_paren_built)?;
        self.push(ASTType::LParen(l_paren_built), context);
        Ok(())
    }

    /// Semantic action for production 232:
    ///
    /// MinusColon: MinusColonToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn minus_colon(&mut self, _minus_colon_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus_colon_token = pop_item!(self, minus_colon_token, MinusColonToken, context);
        let minus_colon_built = MinusColon {
            minus_colon_token: (&minus_colon_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.minus_colon(&minus_colon_built)?;
        self.push(ASTType::MinusColon(minus_colon_built), context);
        Ok(())
    }

    /// Semantic action for production 233:
    ///
    /// MinusGT: MinusGTToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn minus_g_t(&mut self, _minus_g_t_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus_g_t_token = pop_item!(self, minus_g_t_token, MinusGTToken, context);
        let minus_g_t_built = MinusGT {
            minus_g_t_token: (&minus_g_t_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.minus_g_t(&minus_g_t_built)?;
        self.push(ASTType::MinusGT(minus_g_t_built), context);
        Ok(())
    }

    /// Semantic action for production 234:
    ///
    /// PlusColon: PlusColonToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn plus_colon(&mut self, _plus_colon_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus_colon_token = pop_item!(self, plus_colon_token, PlusColonToken, context);
        let plus_colon_built = PlusColon {
            plus_colon_token: (&plus_colon_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.plus_colon(&plus_colon_built)?;
        self.push(ASTType::PlusColon(plus_colon_built), context);
        Ok(())
    }

    /// Semantic action for production 235:
    ///
    /// RAngle: RAngleToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn r_angle(&mut self, _r_angle_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_angle_token = pop_item!(self, r_angle_token, RAngleToken, context);
        let r_angle_built = RAngle {
            r_angle_token: (&r_angle_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r_angle(&r_angle_built)?;
        self.push(ASTType::RAngle(r_angle_built), context);
        Ok(())
    }

    /// Semantic action for production 236:
    ///
    /// RBrace: RBraceToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn r_brace(&mut self, _r_brace_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace_token = pop_item!(self, r_brace_token, RBraceToken, context);
        let r_brace_built = RBrace {
            r_brace_token: (&r_brace_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r_brace(&r_brace_built)?;
        self.push(ASTType::RBrace(r_brace_built), context);
        Ok(())
    }

    /// Semantic action for production 237:
    ///
    /// RBracket: RBracketToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn r_bracket(&mut self, _r_bracket_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_bracket_token = pop_item!(self, r_bracket_token, RBracketToken, context);
        let r_bracket_built = RBracket {
            r_bracket_token: (&r_bracket_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r_bracket(&r_bracket_built)?;
        self.push(ASTType::RBracket(r_bracket_built), context);
        Ok(())
    }

    /// Semantic action for production 238:
    ///
    /// RParen: RParenToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn r_paren(&mut self, _r_paren_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren_token = pop_item!(self, r_paren_token, RParenToken, context);
        let r_paren_built = RParen {
            r_paren_token: (&r_paren_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r_paren(&r_paren_built)?;
        self.push(ASTType::RParen(r_paren_built), context);
        Ok(())
    }

    /// Semantic action for production 239:
    ///
    /// Semicolon: SemicolonToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn semicolon(&mut self, _semicolon_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon_token = pop_item!(self, semicolon_token, SemicolonToken, context);
        let semicolon_built = Semicolon {
            semicolon_token: (&semicolon_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.semicolon(&semicolon_built)?;
        self.push(ASTType::Semicolon(semicolon_built), context);
        Ok(())
    }

    /// Semantic action for production 240:
    ///
    /// Star: StarToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn star(&mut self, _star_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let star_token = pop_item!(self, star_token, StarToken, context);
        let star_built = Star {
            star_token: (&star_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.star(&star_built)?;
        self.push(ASTType::Star(star_built), context);
        Ok(())
    }

    /// Semantic action for production 241:
    ///
    /// AlwaysComb: AlwaysCombToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn always_comb(&mut self, _always_comb_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_comb_token = pop_item!(self, always_comb_token, AlwaysCombToken, context);
        let always_comb_built = AlwaysComb {
            always_comb_token: (&always_comb_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.always_comb(&always_comb_built)?;
        self.push(ASTType::AlwaysComb(always_comb_built), context);
        Ok(())
    }

    /// Semantic action for production 242:
    ///
    /// AlwaysFf: AlwaysFfToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff(&mut self, _always_ff_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_ff_token = pop_item!(self, always_ff_token, AlwaysFfToken, context);
        let always_ff_built = AlwaysFf {
            always_ff_token: (&always_ff_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.always_ff(&always_ff_built)?;
        self.push(ASTType::AlwaysFf(always_ff_built), context);
        Ok(())
    }

    /// Semantic action for production 243:
    ///
    /// As: AsToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn r#as(&mut self, _as_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let as_token = pop_item!(self, as_token, AsToken, context);
        let r#as_built = As {
            as_token: (&as_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r#as(&r#as_built)?;
        self.push(ASTType::As(r#as_built), context);
        Ok(())
    }

    /// Semantic action for production 244:
    ///
    /// Assign: AssignToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn assign(&mut self, _assign_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assign_token = pop_item!(self, assign_token, AssignToken, context);
        let assign_built = Assign {
            assign_token: (&assign_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.assign(&assign_built)?;
        self.push(ASTType::Assign(assign_built), context);
        Ok(())
    }

    /// Semantic action for production 245:
    ///
    /// AsyncHigh: AsyncHighToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn async_high(&mut self, _async_high_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let async_high_token = pop_item!(self, async_high_token, AsyncHighToken, context);
        let async_high_built = AsyncHigh {
            async_high_token: (&async_high_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.async_high(&async_high_built)?;
        self.push(ASTType::AsyncHigh(async_high_built), context);
        Ok(())
    }

    /// Semantic action for production 246:
    ///
    /// AsyncLow: AsyncLowToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn async_low(&mut self, _async_low_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let async_low_token = pop_item!(self, async_low_token, AsyncLowToken, context);
        let async_low_built = AsyncLow {
            async_low_token: (&async_low_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.async_low(&async_low_built)?;
        self.push(ASTType::AsyncLow(async_low_built), context);
        Ok(())
    }

    /// Semantic action for production 247:
    ///
    /// Bit: BitToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn bit(&mut self, _bit_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bit_token = pop_item!(self, bit_token, BitToken, context);
        let bit_built = Bit {
            bit_token: (&bit_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.bit(&bit_built)?;
        self.push(ASTType::Bit(bit_built), context);
        Ok(())
    }

    /// Semantic action for production 248:
    ///
    /// Case: CaseToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn case(&mut self, _case_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let case_token = pop_item!(self, case_token, CaseToken, context);
        let case_built = Case {
            case_token: (&case_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.case(&case_built)?;
        self.push(ASTType::Case(case_built), context);
        Ok(())
    }

    /// Semantic action for production 249:
    ///
    /// Defaul: DefaultToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn defaul(&mut self, _default_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let default_token = pop_item!(self, default_token, DefaultToken, context);
        let defaul_built = Defaul {
            default_token: (&default_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.defaul(&defaul_built)?;
        self.push(ASTType::Defaul(defaul_built), context);
        Ok(())
    }

    /// Semantic action for production 250:
    ///
    /// Else: ElseToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn r#else(&mut self, _else_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let else_token = pop_item!(self, else_token, ElseToken, context);
        let r#else_built = Else {
            else_token: (&else_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r#else(&r#else_built)?;
        self.push(ASTType::Else(r#else_built), context);
        Ok(())
    }

    /// Semantic action for production 251:
    ///
    /// Enum: EnumToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn r#enum(&mut self, _enum_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enum_token = pop_item!(self, enum_token, EnumToken, context);
        let r#enum_built = Enum {
            enum_token: (&enum_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r#enum(&r#enum_built)?;
        self.push(ASTType::Enum(r#enum_built), context);
        Ok(())
    }

    /// Semantic action for production 252:
    ///
    /// Export: ExportToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn export(&mut self, _export_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let export_token = pop_item!(self, export_token, ExportToken, context);
        let export_built = Export {
            export_token: (&export_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.export(&export_built)?;
        self.push(ASTType::Export(export_built), context);
        Ok(())
    }

    /// Semantic action for production 253:
    ///
    /// F32: F32Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn f32(&mut self, _f32_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f32_token = pop_item!(self, f32_token, F32Token, context);
        let f32_built = F32 {
            f32_token: (&f32_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.f32(&f32_built)?;
        self.push(ASTType::F32(f32_built), context);
        Ok(())
    }

    /// Semantic action for production 254:
    ///
    /// F64: F64Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn f64(&mut self, _f64_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f64_token = pop_item!(self, f64_token, F64Token, context);
        let f64_built = F64 {
            f64_token: (&f64_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.f64(&f64_built)?;
        self.push(ASTType::F64(f64_built), context);
        Ok(())
    }

    /// Semantic action for production 255:
    ///
    /// Final: FinalToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn r#final(&mut self, _final_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let final_token = pop_item!(self, final_token, FinalToken, context);
        let r#final_built = Final {
            final_token: (&final_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r#final(&r#final_built)?;
        self.push(ASTType::Final(r#final_built), context);
        Ok(())
    }

    /// Semantic action for production 256:
    ///
    /// For: ForToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn r#for(&mut self, _for_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let for_token = pop_item!(self, for_token, ForToken, context);
        let r#for_built = For {
            for_token: (&for_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r#for(&r#for_built)?;
        self.push(ASTType::For(r#for_built), context);
        Ok(())
    }

    /// Semantic action for production 257:
    ///
    /// Function: FunctionToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn function(&mut self, _function_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_token = pop_item!(self, function_token, FunctionToken, context);
        let function_built = Function {
            function_token: (&function_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.function(&function_built)?;
        self.push(ASTType::Function(function_built), context);
        Ok(())
    }

    /// Semantic action for production 258:
    ///
    /// I32: I32Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn i32(&mut self, _i32_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i32_token = pop_item!(self, i32_token, I32Token, context);
        let i32_built = I32 {
            i32_token: (&i32_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.i32(&i32_built)?;
        self.push(ASTType::I32(i32_built), context);
        Ok(())
    }

    /// Semantic action for production 259:
    ///
    /// I64: I64Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn i64(&mut self, _i64_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i64_token = pop_item!(self, i64_token, I64Token, context);
        let i64_built = I64 {
            i64_token: (&i64_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.i64(&i64_built)?;
        self.push(ASTType::I64(i64_built), context);
        Ok(())
    }

    /// Semantic action for production 260:
    ///
    /// If: IfToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn r#if(&mut self, _if_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_token = pop_item!(self, if_token, IfToken, context);
        let r#if_built = If {
            if_token: (&if_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r#if(&r#if_built)?;
        self.push(ASTType::If(r#if_built), context);
        Ok(())
    }

    /// Semantic action for production 261:
    ///
    /// IfReset: IfResetToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn if_reset(&mut self, _if_reset_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_reset_token = pop_item!(self, if_reset_token, IfResetToken, context);
        let if_reset_built = IfReset {
            if_reset_token: (&if_reset_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.if_reset(&if_reset_built)?;
        self.push(ASTType::IfReset(if_reset_built), context);
        Ok(())
    }

    /// Semantic action for production 262:
    ///
    /// Import: ImportToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn import(&mut self, _import_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let import_token = pop_item!(self, import_token, ImportToken, context);
        let import_built = Import {
            import_token: (&import_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.import(&import_built)?;
        self.push(ASTType::Import(import_built), context);
        Ok(())
    }

    /// Semantic action for production 263:
    ///
    /// In: InToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn r#in(&mut self, _in_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let in_token = pop_item!(self, in_token, InToken, context);
        let r#in_built = In {
            in_token: (&in_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r#in(&r#in_built)?;
        self.push(ASTType::In(r#in_built), context);
        Ok(())
    }

    /// Semantic action for production 264:
    ///
    /// Initial: InitialToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn initial(&mut self, _initial_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let initial_token = pop_item!(self, initial_token, InitialToken, context);
        let initial_built = Initial {
            initial_token: (&initial_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.initial(&initial_built)?;
        self.push(ASTType::Initial(initial_built), context);
        Ok(())
    }

    /// Semantic action for production 265:
    ///
    /// Inout: InoutToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn inout(&mut self, _inout_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inout_token = pop_item!(self, inout_token, InoutToken, context);
        let inout_built = Inout {
            inout_token: (&inout_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.inout(&inout_built)?;
        self.push(ASTType::Inout(inout_built), context);
        Ok(())
    }

    /// Semantic action for production 266:
    ///
    /// Input: InputToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn input(&mut self, _input_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let input_token = pop_item!(self, input_token, InputToken, context);
        let input_built = Input {
            input_token: (&input_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.input(&input_built)?;
        self.push(ASTType::Input(input_built), context);
        Ok(())
    }

    /// Semantic action for production 267:
    ///
    /// Inside: InsideToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn inside(&mut self, _inside_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inside_token = pop_item!(self, inside_token, InsideToken, context);
        let inside_built = Inside {
            inside_token: (&inside_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.inside(&inside_built)?;
        self.push(ASTType::Inside(inside_built), context);
        Ok(())
    }

    /// Semantic action for production 268:
    ///
    /// Inst: InstToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn inst(&mut self, _inst_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_token = pop_item!(self, inst_token, InstToken, context);
        let inst_built = Inst {
            inst_token: (&inst_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.inst(&inst_built)?;
        self.push(ASTType::Inst(inst_built), context);
        Ok(())
    }

    /// Semantic action for production 269:
    ///
    /// Interface: InterfaceToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn interface(&mut self, _interface_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_token = pop_item!(self, interface_token, InterfaceToken, context);
        let interface_built = Interface {
            interface_token: (&interface_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.interface(&interface_built)?;
        self.push(ASTType::Interface(interface_built), context);
        Ok(())
    }

    /// Semantic action for production 270:
    ///
    /// Localparam: LocalparamToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn localparam(&mut self, _localparam_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let localparam_token = pop_item!(self, localparam_token, LocalparamToken, context);
        let localparam_built = Localparam {
            localparam_token: (&localparam_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.localparam(&localparam_built)?;
        self.push(ASTType::Localparam(localparam_built), context);
        Ok(())
    }

    /// Semantic action for production 271:
    ///
    /// Logic: LogicToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn logic(&mut self, _logic_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logic_token = pop_item!(self, logic_token, LogicToken, context);
        let logic_built = Logic {
            logic_token: (&logic_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.logic(&logic_built)?;
        self.push(ASTType::Logic(logic_built), context);
        Ok(())
    }

    /// Semantic action for production 272:
    ///
    /// Lsb: LsbToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn lsb(&mut self, _lsb_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let lsb_token = pop_item!(self, lsb_token, LsbToken, context);
        let lsb_built = Lsb {
            lsb_token: (&lsb_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.lsb(&lsb_built)?;
        self.push(ASTType::Lsb(lsb_built), context);
        Ok(())
    }

    /// Semantic action for production 273:
    ///
    /// Modport: ModportToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn modport(&mut self, _modport_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport_token = pop_item!(self, modport_token, ModportToken, context);
        let modport_built = Modport {
            modport_token: (&modport_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.modport(&modport_built)?;
        self.push(ASTType::Modport(modport_built), context);
        Ok(())
    }

    /// Semantic action for production 274:
    ///
    /// Module: ModuleToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn module(&mut self, _module_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_token = pop_item!(self, module_token, ModuleToken, context);
        let module_built = Module {
            module_token: (&module_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.module(&module_built)?;
        self.push(ASTType::Module(module_built), context);
        Ok(())
    }

    /// Semantic action for production 275:
    ///
    /// Msb: MsbToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn msb(&mut self, _msb_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let msb_token = pop_item!(self, msb_token, MsbToken, context);
        let msb_built = Msb {
            msb_token: (&msb_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.msb(&msb_built)?;
        self.push(ASTType::Msb(msb_built), context);
        Ok(())
    }

    /// Semantic action for production 276:
    ///
    /// Negedge: NegedgeToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn negedge(&mut self, _negedge_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let negedge_token = pop_item!(self, negedge_token, NegedgeToken, context);
        let negedge_built = Negedge {
            negedge_token: (&negedge_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.negedge(&negedge_built)?;
        self.push(ASTType::Negedge(negedge_built), context);
        Ok(())
    }

    /// Semantic action for production 277:
    ///
    /// Output: OutputToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn output(&mut self, _output_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let output_token = pop_item!(self, output_token, OutputToken, context);
        let output_built = Output {
            output_token: (&output_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.output(&output_built)?;
        self.push(ASTType::Output(output_built), context);
        Ok(())
    }

    /// Semantic action for production 278:
    ///
    /// Outside: OutsideToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn outside(&mut self, _outside_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let outside_token = pop_item!(self, outside_token, OutsideToken, context);
        let outside_built = Outside {
            outside_token: (&outside_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.outside(&outside_built)?;
        self.push(ASTType::Outside(outside_built), context);
        Ok(())
    }

    /// Semantic action for production 279:
    ///
    /// Package: PackageToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn package(&mut self, _package_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let package_token = pop_item!(self, package_token, PackageToken, context);
        let package_built = Package {
            package_token: (&package_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.package(&package_built)?;
        self.push(ASTType::Package(package_built), context);
        Ok(())
    }

    /// Semantic action for production 280:
    ///
    /// Parameter: ParameterToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn parameter(&mut self, _parameter_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let parameter_token = pop_item!(self, parameter_token, ParameterToken, context);
        let parameter_built = Parameter {
            parameter_token: (&parameter_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.parameter(&parameter_built)?;
        self.push(ASTType::Parameter(parameter_built), context);
        Ok(())
    }

    /// Semantic action for production 281:
    ///
    /// Posedge: PosedgeToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn posedge(&mut self, _posedge_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let posedge_token = pop_item!(self, posedge_token, PosedgeToken, context);
        let posedge_built = Posedge {
            posedge_token: (&posedge_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.posedge(&posedge_built)?;
        self.push(ASTType::Posedge(posedge_built), context);
        Ok(())
    }

    /// Semantic action for production 282:
    ///
    /// Ref: RefToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn r#ref(&mut self, _ref_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ref_token = pop_item!(self, ref_token, RefToken, context);
        let r#ref_built = Ref {
            ref_token: (&ref_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r#ref(&r#ref_built)?;
        self.push(ASTType::Ref(r#ref_built), context);
        Ok(())
    }

    /// Semantic action for production 283:
    ///
    /// Repeat: RepeatToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn repeat(&mut self, _repeat_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let repeat_token = pop_item!(self, repeat_token, RepeatToken, context);
        let repeat_built = Repeat {
            repeat_token: (&repeat_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.repeat(&repeat_built)?;
        self.push(ASTType::Repeat(repeat_built), context);
        Ok(())
    }

    /// Semantic action for production 284:
    ///
    /// Return: ReturnToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn r#return(&mut self, _return_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let return_token = pop_item!(self, return_token, ReturnToken, context);
        let r#return_built = Return {
            return_token: (&return_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r#return(&r#return_built)?;
        self.push(ASTType::Return(r#return_built), context);
        Ok(())
    }

    /// Semantic action for production 285:
    ///
    /// Signed: SignedToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn signed(&mut self, _signed_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let signed_token = pop_item!(self, signed_token, SignedToken, context);
        let signed_built = Signed {
            signed_token: (&signed_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.signed(&signed_built)?;
        self.push(ASTType::Signed(signed_built), context);
        Ok(())
    }

    /// Semantic action for production 286:
    ///
    /// Step: StepToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn step(&mut self, _step_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let step_token = pop_item!(self, step_token, StepToken, context);
        let step_built = Step {
            step_token: (&step_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.step(&step_built)?;
        self.push(ASTType::Step(step_built), context);
        Ok(())
    }

    /// Semantic action for production 287:
    ///
    /// Strin: StringToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn strin(&mut self, _string_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string_token = pop_item!(self, string_token, StringToken, context);
        let strin_built = Strin {
            string_token: (&string_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.strin(&strin_built)?;
        self.push(ASTType::Strin(strin_built), context);
        Ok(())
    }

    /// Semantic action for production 288:
    ///
    /// Struct: StructToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn r#struct(&mut self, _struct_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let struct_token = pop_item!(self, struct_token, StructToken, context);
        let r#struct_built = Struct {
            struct_token: (&struct_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r#struct(&r#struct_built)?;
        self.push(ASTType::Struct(r#struct_built), context);
        Ok(())
    }

    /// Semantic action for production 289:
    ///
    /// SyncHigh: SyncHighToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn sync_high(&mut self, _sync_high_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let sync_high_token = pop_item!(self, sync_high_token, SyncHighToken, context);
        let sync_high_built = SyncHigh {
            sync_high_token: (&sync_high_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.sync_high(&sync_high_built)?;
        self.push(ASTType::SyncHigh(sync_high_built), context);
        Ok(())
    }

    /// Semantic action for production 290:
    ///
    /// SyncLow: SyncLowToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn sync_low(&mut self, _sync_low_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let sync_low_token = pop_item!(self, sync_low_token, SyncLowToken, context);
        let sync_low_built = SyncLow {
            sync_low_token: (&sync_low_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.sync_low(&sync_low_built)?;
        self.push(ASTType::SyncLow(sync_low_built), context);
        Ok(())
    }

    /// Semantic action for production 291:
    ///
    /// Tri: TriToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn tri(&mut self, _tri_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tri_token = pop_item!(self, tri_token, TriToken, context);
        let tri_built = Tri {
            tri_token: (&tri_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.tri(&tri_built)?;
        self.push(ASTType::Tri(tri_built), context);
        Ok(())
    }

    /// Semantic action for production 292:
    ///
    /// Type: TypeToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn r#type(&mut self, _type_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_token = pop_item!(self, type_token, TypeToken, context);
        let r#type_built = Type {
            type_token: (&type_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r#type(&r#type_built)?;
        self.push(ASTType::Type(r#type_built), context);
        Ok(())
    }

    /// Semantic action for production 293:
    ///
    /// U32: U32Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn u32(&mut self, _u32_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u32_token = pop_item!(self, u32_token, U32Token, context);
        let u32_built = U32 {
            u32_token: (&u32_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.u32(&u32_built)?;
        self.push(ASTType::U32(u32_built), context);
        Ok(())
    }

    /// Semantic action for production 294:
    ///
    /// U64: U64Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn u64(&mut self, _u64_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u64_token = pop_item!(self, u64_token, U64Token, context);
        let u64_built = U64 {
            u64_token: (&u64_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.u64(&u64_built)?;
        self.push(ASTType::U64(u64_built), context);
        Ok(())
    }

    /// Semantic action for production 295:
    ///
    /// Var: VarToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn var(&mut self, _var_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let var_token = pop_item!(self, var_token, VarToken, context);
        let var_built = Var {
            var_token: (&var_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.var(&var_built)?;
        self.push(ASTType::Var(var_built), context);
        Ok(())
    }

    /// Semantic action for production 296:
    ///
    /// Identifier: IdentifierToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn identifier(&mut self, _identifier_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier_token = pop_item!(self, identifier_token, IdentifierToken, context);
        let identifier_built = Identifier {
            identifier_token: (&identifier_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.identifier(&identifier_built)?;
        self.push(ASTType::Identifier(identifier_built), context);
        Ok(())
    }

    /// Semantic action for production 297:
    ///
    /// Number: IntegralNumber;
    ///
    #[parol_runtime::function_name::named]
    fn number_0(&mut self, _integral_number: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integral_number = pop_item!(self, integral_number, IntegralNumber, context);
        let number_0_built = NumberIntegralNumber {
            integral_number: Box::new(integral_number),
        };
        let number_0_built = Number::IntegralNumber(number_0_built);
        // Calling user action here
        self.user_grammar.number(&number_0_built)?;
        self.push(ASTType::Number(number_0_built), context);
        Ok(())
    }

    /// Semantic action for production 298:
    ///
    /// Number: RealNumber;
    ///
    #[parol_runtime::function_name::named]
    fn number_1(&mut self, _real_number: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let real_number = pop_item!(self, real_number, RealNumber, context);
        let number_1_built = NumberRealNumber {
            real_number: Box::new(real_number),
        };
        let number_1_built = Number::RealNumber(number_1_built);
        // Calling user action here
        self.user_grammar.number(&number_1_built)?;
        self.push(ASTType::Number(number_1_built), context);
        Ok(())
    }

    /// Semantic action for production 299:
    ///
    /// IntegralNumber: Based;
    ///
    #[parol_runtime::function_name::named]
    fn integral_number_0(&mut self, _based: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let based = pop_item!(self, based, Based, context);
        let integral_number_0_built = IntegralNumberBased {
            based: Box::new(based),
        };
        let integral_number_0_built = IntegralNumber::Based(integral_number_0_built);
        // Calling user action here
        self.user_grammar
            .integral_number(&integral_number_0_built)?;
        self.push(ASTType::IntegralNumber(integral_number_0_built), context);
        Ok(())
    }

    /// Semantic action for production 300:
    ///
    /// IntegralNumber: BaseLess;
    ///
    #[parol_runtime::function_name::named]
    fn integral_number_1(&mut self, _base_less: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let base_less = pop_item!(self, base_less, BaseLess, context);
        let integral_number_1_built = IntegralNumberBaseLess {
            base_less: Box::new(base_less),
        };
        let integral_number_1_built = IntegralNumber::BaseLess(integral_number_1_built);
        // Calling user action here
        self.user_grammar
            .integral_number(&integral_number_1_built)?;
        self.push(ASTType::IntegralNumber(integral_number_1_built), context);
        Ok(())
    }

    /// Semantic action for production 301:
    ///
    /// IntegralNumber: AllBit;
    ///
    #[parol_runtime::function_name::named]
    fn integral_number_2(&mut self, _all_bit: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let all_bit = pop_item!(self, all_bit, AllBit, context);
        let integral_number_2_built = IntegralNumberAllBit {
            all_bit: Box::new(all_bit),
        };
        let integral_number_2_built = IntegralNumber::AllBit(integral_number_2_built);
        // Calling user action here
        self.user_grammar
            .integral_number(&integral_number_2_built)?;
        self.push(ASTType::IntegralNumber(integral_number_2_built), context);
        Ok(())
    }

    /// Semantic action for production 302:
    ///
    /// RealNumber: FixedPoint;
    ///
    #[parol_runtime::function_name::named]
    fn real_number_0(&mut self, _fixed_point: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let fixed_point = pop_item!(self, fixed_point, FixedPoint, context);
        let real_number_0_built = RealNumberFixedPoint {
            fixed_point: Box::new(fixed_point),
        };
        let real_number_0_built = RealNumber::FixedPoint(real_number_0_built);
        // Calling user action here
        self.user_grammar.real_number(&real_number_0_built)?;
        self.push(ASTType::RealNumber(real_number_0_built), context);
        Ok(())
    }

    /// Semantic action for production 303:
    ///
    /// RealNumber: Exponent;
    ///
    #[parol_runtime::function_name::named]
    fn real_number_1(&mut self, _exponent: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let exponent = pop_item!(self, exponent, Exponent, context);
        let real_number_1_built = RealNumberExponent {
            exponent: Box::new(exponent),
        };
        let real_number_1_built = RealNumber::Exponent(real_number_1_built);
        // Calling user action here
        self.user_grammar.real_number(&real_number_1_built)?;
        self.push(ASTType::RealNumber(real_number_1_built), context);
        Ok(())
    }

    /// Semantic action for production 304:
    ///
    /// HierarchicalIdentifier: Identifier HierarchicalIdentifierList /* Vec */ HierarchicalIdentifierList0 /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn hierarchical_identifier(
        &mut self,
        _identifier: &ParseTreeType<'t>,
        _hierarchical_identifier_list: &ParseTreeType<'t>,
        _hierarchical_identifier_list0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hierarchical_identifier_list0 = pop_and_reverse_item!(
            self,
            hierarchical_identifier_list0,
            HierarchicalIdentifierList0,
            context
        );
        let hierarchical_identifier_list = pop_and_reverse_item!(
            self,
            hierarchical_identifier_list,
            HierarchicalIdentifierList,
            context
        );
        let identifier = pop_item!(self, identifier, Identifier, context);
        let hierarchical_identifier_built = HierarchicalIdentifier {
            identifier: Box::new(identifier),
            hierarchical_identifier_list,
            hierarchical_identifier_list0,
        };
        // Calling user action here
        self.user_grammar
            .hierarchical_identifier(&hierarchical_identifier_built)?;
        self.push(
            ASTType::HierarchicalIdentifier(hierarchical_identifier_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 305:
    ///
    /// HierarchicalIdentifierList0 /* Vec<T>::Push */: Dot Identifier HierarchicalIdentifierList0List /* Vec */ HierarchicalIdentifierList0;
    ///
    #[parol_runtime::function_name::named]
    fn hierarchical_identifier_list0_0(
        &mut self,
        _dot: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _hierarchical_identifier_list0_list: &ParseTreeType<'t>,
        _hierarchical_identifier_list0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut hierarchical_identifier_list0 = pop_item!(
            self,
            hierarchical_identifier_list0,
            HierarchicalIdentifierList0,
            context
        );
        let hierarchical_identifier_list0_list = pop_and_reverse_item!(
            self,
            hierarchical_identifier_list0_list,
            HierarchicalIdentifierList0List,
            context
        );
        let identifier = pop_item!(self, identifier, Identifier, context);
        let dot = pop_item!(self, dot, Dot, context);
        let hierarchical_identifier_list0_0_built = HierarchicalIdentifierList0 {
            hierarchical_identifier_list0_list,
            identifier: Box::new(identifier),
            dot: Box::new(dot),
        };
        // Add an element to the vector
        hierarchical_identifier_list0.push(hierarchical_identifier_list0_0_built);
        self.push(
            ASTType::HierarchicalIdentifierList0(hierarchical_identifier_list0),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 306:
    ///
    /// HierarchicalIdentifierList0List /* Vec<T>::Push */: Select HierarchicalIdentifierList0List;
    ///
    #[parol_runtime::function_name::named]
    fn hierarchical_identifier_list0_list_0(
        &mut self,
        _select: &ParseTreeType<'t>,
        _hierarchical_identifier_list0_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut hierarchical_identifier_list0_list = pop_item!(
            self,
            hierarchical_identifier_list0_list,
            HierarchicalIdentifierList0List,
            context
        );
        let select = pop_item!(self, select, Select, context);
        let hierarchical_identifier_list0_list_0_built = HierarchicalIdentifierList0List {
            select: Box::new(select),
        };
        // Add an element to the vector
        hierarchical_identifier_list0_list.push(hierarchical_identifier_list0_list_0_built);
        self.push(
            ASTType::HierarchicalIdentifierList0List(hierarchical_identifier_list0_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 307:
    ///
    /// HierarchicalIdentifierList0List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn hierarchical_identifier_list0_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hierarchical_identifier_list0_list_1_built = Vec::new();
        self.push(
            ASTType::HierarchicalIdentifierList0List(hierarchical_identifier_list0_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 308:
    ///
    /// HierarchicalIdentifierList0 /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn hierarchical_identifier_list0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hierarchical_identifier_list0_1_built = Vec::new();
        self.push(
            ASTType::HierarchicalIdentifierList0(hierarchical_identifier_list0_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 309:
    ///
    /// HierarchicalIdentifierList /* Vec<T>::Push */: Select HierarchicalIdentifierList;
    ///
    #[parol_runtime::function_name::named]
    fn hierarchical_identifier_list_0(
        &mut self,
        _select: &ParseTreeType<'t>,
        _hierarchical_identifier_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut hierarchical_identifier_list = pop_item!(
            self,
            hierarchical_identifier_list,
            HierarchicalIdentifierList,
            context
        );
        let select = pop_item!(self, select, Select, context);
        let hierarchical_identifier_list_0_built = HierarchicalIdentifierList {
            select: Box::new(select),
        };
        // Add an element to the vector
        hierarchical_identifier_list.push(hierarchical_identifier_list_0_built);
        self.push(
            ASTType::HierarchicalIdentifierList(hierarchical_identifier_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 310:
    ///
    /// HierarchicalIdentifierList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn hierarchical_identifier_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hierarchical_identifier_list_1_built = Vec::new();
        self.push(
            ASTType::HierarchicalIdentifierList(hierarchical_identifier_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 311:
    ///
    /// ScopedIdentifier: Identifier ScopedIdentifierList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn scoped_identifier(
        &mut self,
        _identifier: &ParseTreeType<'t>,
        _scoped_identifier_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scoped_identifier_list =
            pop_and_reverse_item!(self, scoped_identifier_list, ScopedIdentifierList, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let scoped_identifier_built = ScopedIdentifier {
            identifier: Box::new(identifier),
            scoped_identifier_list,
        };
        // Calling user action here
        self.user_grammar
            .scoped_identifier(&scoped_identifier_built)?;
        self.push(ASTType::ScopedIdentifier(scoped_identifier_built), context);
        Ok(())
    }

    /// Semantic action for production 312:
    ///
    /// ScopedIdentifierList /* Vec<T>::Push */: ColonColon Identifier ScopedIdentifierList;
    ///
    #[parol_runtime::function_name::named]
    fn scoped_identifier_list_0(
        &mut self,
        _colon_colon: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _scoped_identifier_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut scoped_identifier_list =
            pop_item!(self, scoped_identifier_list, ScopedIdentifierList, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let colon_colon = pop_item!(self, colon_colon, ColonColon, context);
        let scoped_identifier_list_0_built = ScopedIdentifierList {
            identifier: Box::new(identifier),
            colon_colon: Box::new(colon_colon),
        };
        // Add an element to the vector
        scoped_identifier_list.push(scoped_identifier_list_0_built);
        self.push(
            ASTType::ScopedIdentifierList(scoped_identifier_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 313:
    ///
    /// ScopedIdentifierList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn scoped_identifier_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scoped_identifier_list_1_built = Vec::new();
        self.push(
            ASTType::ScopedIdentifierList(scoped_identifier_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 314:
    ///
    /// ExpressionIdentifier: ExpressionIdentifierOpt /* Option */ Identifier ExpressionIdentifierGroup;
    ///
    #[parol_runtime::function_name::named]
    fn expression_identifier(
        &mut self,
        _expression_identifier_opt: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _expression_identifier_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression_identifier_group = pop_item!(
            self,
            expression_identifier_group,
            ExpressionIdentifierGroup,
            context
        );
        let identifier = pop_item!(self, identifier, Identifier, context);
        let expression_identifier_opt = pop_item!(
            self,
            expression_identifier_opt,
            ExpressionIdentifierOpt,
            context
        );
        let expression_identifier_built = ExpressionIdentifier {
            expression_identifier_opt,
            identifier: Box::new(identifier),
            expression_identifier_group: Box::new(expression_identifier_group),
        };
        // Calling user action here
        self.user_grammar
            .expression_identifier(&expression_identifier_built)?;
        self.push(
            ASTType::ExpressionIdentifier(expression_identifier_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 315:
    ///
    /// ExpressionIdentifierGroup: ColonColon Identifier ExpressionIdentifierGroupList /* Vec */ ExpressionIdentifierGroupList0 /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression_identifier_group_0(
        &mut self,
        _colon_colon: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _expression_identifier_group_list: &ParseTreeType<'t>,
        _expression_identifier_group_list0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression_identifier_group_list0 = pop_and_reverse_item!(
            self,
            expression_identifier_group_list0,
            ExpressionIdentifierGroupList0,
            context
        );
        let expression_identifier_group_list = pop_and_reverse_item!(
            self,
            expression_identifier_group_list,
            ExpressionIdentifierGroupList,
            context
        );
        let identifier = pop_item!(self, identifier, Identifier, context);
        let colon_colon = pop_item!(self, colon_colon, ColonColon, context);
        let expression_identifier_group_0_built = ExpressionIdentifierGroupColonColonIdentifierExpressionIdentifierGroupListExpressionIdentifierGroupList0 {
            colon_colon: Box::new(colon_colon),
            identifier: Box::new(identifier),
            expression_identifier_group_list,
            expression_identifier_group_list0,
        };
        let expression_identifier_group_0_built = ExpressionIdentifierGroup::ColonColonIdentifierExpressionIdentifierGroupListExpressionIdentifierGroupList0(expression_identifier_group_0_built);
        self.push(
            ASTType::ExpressionIdentifierGroup(expression_identifier_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 316:
    ///
    /// ExpressionIdentifierGroupList0 /* Vec<T>::Push */: Select ExpressionIdentifierGroupList0;
    ///
    #[parol_runtime::function_name::named]
    fn expression_identifier_group_list0_0(
        &mut self,
        _select: &ParseTreeType<'t>,
        _expression_identifier_group_list0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression_identifier_group_list0 = pop_item!(
            self,
            expression_identifier_group_list0,
            ExpressionIdentifierGroupList0,
            context
        );
        let select = pop_item!(self, select, Select, context);
        let expression_identifier_group_list0_0_built = ExpressionIdentifierGroupList0 {
            select: Box::new(select),
        };
        // Add an element to the vector
        expression_identifier_group_list0.push(expression_identifier_group_list0_0_built);
        self.push(
            ASTType::ExpressionIdentifierGroupList0(expression_identifier_group_list0),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 317:
    ///
    /// ExpressionIdentifierGroupList0 /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression_identifier_group_list0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression_identifier_group_list0_1_built = Vec::new();
        self.push(
            ASTType::ExpressionIdentifierGroupList0(expression_identifier_group_list0_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 318:
    ///
    /// ExpressionIdentifierGroupList /* Vec<T>::Push */: ColonColon Identifier ExpressionIdentifierGroupList;
    ///
    #[parol_runtime::function_name::named]
    fn expression_identifier_group_list_0(
        &mut self,
        _colon_colon: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _expression_identifier_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression_identifier_group_list = pop_item!(
            self,
            expression_identifier_group_list,
            ExpressionIdentifierGroupList,
            context
        );
        let identifier = pop_item!(self, identifier, Identifier, context);
        let colon_colon = pop_item!(self, colon_colon, ColonColon, context);
        let expression_identifier_group_list_0_built = ExpressionIdentifierGroupList {
            identifier: Box::new(identifier),
            colon_colon: Box::new(colon_colon),
        };
        // Add an element to the vector
        expression_identifier_group_list.push(expression_identifier_group_list_0_built);
        self.push(
            ASTType::ExpressionIdentifierGroupList(expression_identifier_group_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 319:
    ///
    /// ExpressionIdentifierGroupList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression_identifier_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression_identifier_group_list_1_built = Vec::new();
        self.push(
            ASTType::ExpressionIdentifierGroupList(expression_identifier_group_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 320:
    ///
    /// ExpressionIdentifierGroup: ExpressionIdentifierGroupList1 /* Vec */ ExpressionIdentifierGroupList2 /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression_identifier_group_1(
        &mut self,
        _expression_identifier_group_list1: &ParseTreeType<'t>,
        _expression_identifier_group_list2: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression_identifier_group_list2 = pop_and_reverse_item!(
            self,
            expression_identifier_group_list2,
            ExpressionIdentifierGroupList2,
            context
        );
        let expression_identifier_group_list1 = pop_and_reverse_item!(
            self,
            expression_identifier_group_list1,
            ExpressionIdentifierGroupList1,
            context
        );
        let expression_identifier_group_1_built =
            ExpressionIdentifierGroupExpressionIdentifierGroupList1ExpressionIdentifierGroupList2 {
                expression_identifier_group_list1,
                expression_identifier_group_list2,
            };
        let expression_identifier_group_1_built =
            ExpressionIdentifierGroup::ExpressionIdentifierGroupList1ExpressionIdentifierGroupList2(
                expression_identifier_group_1_built,
            );
        self.push(
            ASTType::ExpressionIdentifierGroup(expression_identifier_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 321:
    ///
    /// ExpressionIdentifierGroupList2 /* Vec<T>::Push */: Dot Identifier ExpressionIdentifierGroupList2List /* Vec */ ExpressionIdentifierGroupList2;
    ///
    #[parol_runtime::function_name::named]
    fn expression_identifier_group_list2_0(
        &mut self,
        _dot: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _expression_identifier_group_list2_list: &ParseTreeType<'t>,
        _expression_identifier_group_list2: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression_identifier_group_list2 = pop_item!(
            self,
            expression_identifier_group_list2,
            ExpressionIdentifierGroupList2,
            context
        );
        let expression_identifier_group_list2_list = pop_and_reverse_item!(
            self,
            expression_identifier_group_list2_list,
            ExpressionIdentifierGroupList2List,
            context
        );
        let identifier = pop_item!(self, identifier, Identifier, context);
        let dot = pop_item!(self, dot, Dot, context);
        let expression_identifier_group_list2_0_built = ExpressionIdentifierGroupList2 {
            expression_identifier_group_list2_list,
            identifier: Box::new(identifier),
            dot: Box::new(dot),
        };
        // Add an element to the vector
        expression_identifier_group_list2.push(expression_identifier_group_list2_0_built);
        self.push(
            ASTType::ExpressionIdentifierGroupList2(expression_identifier_group_list2),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 322:
    ///
    /// ExpressionIdentifierGroupList2List /* Vec<T>::Push */: Select ExpressionIdentifierGroupList2List;
    ///
    #[parol_runtime::function_name::named]
    fn expression_identifier_group_list2_list_0(
        &mut self,
        _select: &ParseTreeType<'t>,
        _expression_identifier_group_list2_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression_identifier_group_list2_list = pop_item!(
            self,
            expression_identifier_group_list2_list,
            ExpressionIdentifierGroupList2List,
            context
        );
        let select = pop_item!(self, select, Select, context);
        let expression_identifier_group_list2_list_0_built = ExpressionIdentifierGroupList2List {
            select: Box::new(select),
        };
        // Add an element to the vector
        expression_identifier_group_list2_list.push(expression_identifier_group_list2_list_0_built);
        self.push(
            ASTType::ExpressionIdentifierGroupList2List(expression_identifier_group_list2_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 323:
    ///
    /// ExpressionIdentifierGroupList2List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression_identifier_group_list2_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression_identifier_group_list2_list_1_built = Vec::new();
        self.push(
            ASTType::ExpressionIdentifierGroupList2List(
                expression_identifier_group_list2_list_1_built,
            ),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 324:
    ///
    /// ExpressionIdentifierGroupList2 /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression_identifier_group_list2_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression_identifier_group_list2_1_built = Vec::new();
        self.push(
            ASTType::ExpressionIdentifierGroupList2(expression_identifier_group_list2_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 325:
    ///
    /// ExpressionIdentifierGroupList1 /* Vec<T>::Push */: Select ExpressionIdentifierGroupList1;
    ///
    #[parol_runtime::function_name::named]
    fn expression_identifier_group_list1_0(
        &mut self,
        _select: &ParseTreeType<'t>,
        _expression_identifier_group_list1: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression_identifier_group_list1 = pop_item!(
            self,
            expression_identifier_group_list1,
            ExpressionIdentifierGroupList1,
            context
        );
        let select = pop_item!(self, select, Select, context);
        let expression_identifier_group_list1_0_built = ExpressionIdentifierGroupList1 {
            select: Box::new(select),
        };
        // Add an element to the vector
        expression_identifier_group_list1.push(expression_identifier_group_list1_0_built);
        self.push(
            ASTType::ExpressionIdentifierGroupList1(expression_identifier_group_list1),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 326:
    ///
    /// ExpressionIdentifierGroupList1 /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression_identifier_group_list1_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression_identifier_group_list1_1_built = Vec::new();
        self.push(
            ASTType::ExpressionIdentifierGroupList1(expression_identifier_group_list1_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 327:
    ///
    /// ExpressionIdentifierOpt /* Option<T>::Some */: Dollar;
    ///
    #[parol_runtime::function_name::named]
    fn expression_identifier_opt_0(&mut self, _dollar: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dollar = pop_item!(self, dollar, Dollar, context);
        let expression_identifier_opt_0_built = ExpressionIdentifierOpt {
            dollar: Box::new(dollar),
        };
        self.push(
            ASTType::ExpressionIdentifierOpt(Some(Box::new(expression_identifier_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 328:
    ///
    /// ExpressionIdentifierOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression_identifier_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ExpressionIdentifierOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 329:
    ///
    /// Expression: Expression01 ExpressionList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression(
        &mut self,
        _expression01: &ParseTreeType<'t>,
        _expression_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression_list = pop_and_reverse_item!(self, expression_list, ExpressionList, context);
        let expression01 = pop_item!(self, expression01, Expression01, context);
        let expression_built = Expression {
            expression01: Box::new(expression01),
            expression_list,
        };
        // Calling user action here
        self.user_grammar.expression(&expression_built)?;
        self.push(ASTType::Expression(expression_built), context);
        Ok(())
    }

    /// Semantic action for production 330:
    ///
    /// ExpressionList /* Vec<T>::Push */: Operator01 Expression01 ExpressionList;
    ///
    #[parol_runtime::function_name::named]
    fn expression_list_0(
        &mut self,
        _operator01: &ParseTreeType<'t>,
        _expression01: &ParseTreeType<'t>,
        _expression_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression_list = pop_item!(self, expression_list, ExpressionList, context);
        let expression01 = pop_item!(self, expression01, Expression01, context);
        let operator01 = pop_item!(self, operator01, Operator01, context);
        let expression_list_0_built = ExpressionList {
            expression01: Box::new(expression01),
            operator01: Box::new(operator01),
        };
        // Add an element to the vector
        expression_list.push(expression_list_0_built);
        self.push(ASTType::ExpressionList(expression_list), context);
        Ok(())
    }

    /// Semantic action for production 331:
    ///
    /// ExpressionList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression_list_1_built = Vec::new();
        self.push(ASTType::ExpressionList(expression_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 332:
    ///
    /// Expression01: Expression02 Expression01List /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression01(
        &mut self,
        _expression02: &ParseTreeType<'t>,
        _expression01_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression01_list =
            pop_and_reverse_item!(self, expression01_list, Expression01List, context);
        let expression02 = pop_item!(self, expression02, Expression02, context);
        let expression01_built = Expression01 {
            expression02: Box::new(expression02),
            expression01_list,
        };
        // Calling user action here
        self.user_grammar.expression01(&expression01_built)?;
        self.push(ASTType::Expression01(expression01_built), context);
        Ok(())
    }

    /// Semantic action for production 333:
    ///
    /// Expression01List /* Vec<T>::Push */: Operator02 Expression02 Expression01List;
    ///
    #[parol_runtime::function_name::named]
    fn expression01_list_0(
        &mut self,
        _operator02: &ParseTreeType<'t>,
        _expression02: &ParseTreeType<'t>,
        _expression01_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression01_list = pop_item!(self, expression01_list, Expression01List, context);
        let expression02 = pop_item!(self, expression02, Expression02, context);
        let operator02 = pop_item!(self, operator02, Operator02, context);
        let expression01_list_0_built = Expression01List {
            expression02: Box::new(expression02),
            operator02: Box::new(operator02),
        };
        // Add an element to the vector
        expression01_list.push(expression01_list_0_built);
        self.push(ASTType::Expression01List(expression01_list), context);
        Ok(())
    }

    /// Semantic action for production 334:
    ///
    /// Expression01List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression01_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression01_list_1_built = Vec::new();
        self.push(
            ASTType::Expression01List(expression01_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 335:
    ///
    /// Expression02: Expression03 Expression02List /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression02(
        &mut self,
        _expression03: &ParseTreeType<'t>,
        _expression02_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression02_list =
            pop_and_reverse_item!(self, expression02_list, Expression02List, context);
        let expression03 = pop_item!(self, expression03, Expression03, context);
        let expression02_built = Expression02 {
            expression03: Box::new(expression03),
            expression02_list,
        };
        // Calling user action here
        self.user_grammar.expression02(&expression02_built)?;
        self.push(ASTType::Expression02(expression02_built), context);
        Ok(())
    }

    /// Semantic action for production 336:
    ///
    /// Expression02List /* Vec<T>::Push */: Operator03 Expression03 Expression02List;
    ///
    #[parol_runtime::function_name::named]
    fn expression02_list_0(
        &mut self,
        _operator03: &ParseTreeType<'t>,
        _expression03: &ParseTreeType<'t>,
        _expression02_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression02_list = pop_item!(self, expression02_list, Expression02List, context);
        let expression03 = pop_item!(self, expression03, Expression03, context);
        let operator03 = pop_item!(self, operator03, Operator03, context);
        let expression02_list_0_built = Expression02List {
            expression03: Box::new(expression03),
            operator03: Box::new(operator03),
        };
        // Add an element to the vector
        expression02_list.push(expression02_list_0_built);
        self.push(ASTType::Expression02List(expression02_list), context);
        Ok(())
    }

    /// Semantic action for production 337:
    ///
    /// Expression02List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression02_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression02_list_1_built = Vec::new();
        self.push(
            ASTType::Expression02List(expression02_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 338:
    ///
    /// Expression03: Expression04 Expression03List /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression03(
        &mut self,
        _expression04: &ParseTreeType<'t>,
        _expression03_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression03_list =
            pop_and_reverse_item!(self, expression03_list, Expression03List, context);
        let expression04 = pop_item!(self, expression04, Expression04, context);
        let expression03_built = Expression03 {
            expression04: Box::new(expression04),
            expression03_list,
        };
        // Calling user action here
        self.user_grammar.expression03(&expression03_built)?;
        self.push(ASTType::Expression03(expression03_built), context);
        Ok(())
    }

    /// Semantic action for production 339:
    ///
    /// Expression03List /* Vec<T>::Push */: Operator04 Expression04 Expression03List;
    ///
    #[parol_runtime::function_name::named]
    fn expression03_list_0(
        &mut self,
        _operator04: &ParseTreeType<'t>,
        _expression04: &ParseTreeType<'t>,
        _expression03_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression03_list = pop_item!(self, expression03_list, Expression03List, context);
        let expression04 = pop_item!(self, expression04, Expression04, context);
        let operator04 = pop_item!(self, operator04, Operator04, context);
        let expression03_list_0_built = Expression03List {
            expression04: Box::new(expression04),
            operator04: Box::new(operator04),
        };
        // Add an element to the vector
        expression03_list.push(expression03_list_0_built);
        self.push(ASTType::Expression03List(expression03_list), context);
        Ok(())
    }

    /// Semantic action for production 340:
    ///
    /// Expression03List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression03_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression03_list_1_built = Vec::new();
        self.push(
            ASTType::Expression03List(expression03_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 341:
    ///
    /// Expression04: Expression05 Expression04List /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression04(
        &mut self,
        _expression05: &ParseTreeType<'t>,
        _expression04_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression04_list =
            pop_and_reverse_item!(self, expression04_list, Expression04List, context);
        let expression05 = pop_item!(self, expression05, Expression05, context);
        let expression04_built = Expression04 {
            expression05: Box::new(expression05),
            expression04_list,
        };
        // Calling user action here
        self.user_grammar.expression04(&expression04_built)?;
        self.push(ASTType::Expression04(expression04_built), context);
        Ok(())
    }

    /// Semantic action for production 342:
    ///
    /// Expression04List /* Vec<T>::Push */: Operator05 Expression05 Expression04List;
    ///
    #[parol_runtime::function_name::named]
    fn expression04_list_0(
        &mut self,
        _operator05: &ParseTreeType<'t>,
        _expression05: &ParseTreeType<'t>,
        _expression04_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression04_list = pop_item!(self, expression04_list, Expression04List, context);
        let expression05 = pop_item!(self, expression05, Expression05, context);
        let operator05 = pop_item!(self, operator05, Operator05, context);
        let expression04_list_0_built = Expression04List {
            expression05: Box::new(expression05),
            operator05: Box::new(operator05),
        };
        // Add an element to the vector
        expression04_list.push(expression04_list_0_built);
        self.push(ASTType::Expression04List(expression04_list), context);
        Ok(())
    }

    /// Semantic action for production 343:
    ///
    /// Expression04List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression04_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression04_list_1_built = Vec::new();
        self.push(
            ASTType::Expression04List(expression04_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 344:
    ///
    /// Expression05: Expression06 Expression05List /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression05(
        &mut self,
        _expression06: &ParseTreeType<'t>,
        _expression05_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression05_list =
            pop_and_reverse_item!(self, expression05_list, Expression05List, context);
        let expression06 = pop_item!(self, expression06, Expression06, context);
        let expression05_built = Expression05 {
            expression06: Box::new(expression06),
            expression05_list,
        };
        // Calling user action here
        self.user_grammar.expression05(&expression05_built)?;
        self.push(ASTType::Expression05(expression05_built), context);
        Ok(())
    }

    /// Semantic action for production 345:
    ///
    /// Expression05List /* Vec<T>::Push */: Operator06 Expression06 Expression05List;
    ///
    #[parol_runtime::function_name::named]
    fn expression05_list_0(
        &mut self,
        _operator06: &ParseTreeType<'t>,
        _expression06: &ParseTreeType<'t>,
        _expression05_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression05_list = pop_item!(self, expression05_list, Expression05List, context);
        let expression06 = pop_item!(self, expression06, Expression06, context);
        let operator06 = pop_item!(self, operator06, Operator06, context);
        let expression05_list_0_built = Expression05List {
            expression06: Box::new(expression06),
            operator06: Box::new(operator06),
        };
        // Add an element to the vector
        expression05_list.push(expression05_list_0_built);
        self.push(ASTType::Expression05List(expression05_list), context);
        Ok(())
    }

    /// Semantic action for production 346:
    ///
    /// Expression05List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression05_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression05_list_1_built = Vec::new();
        self.push(
            ASTType::Expression05List(expression05_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 347:
    ///
    /// Expression06: Expression07 Expression06List /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression06(
        &mut self,
        _expression07: &ParseTreeType<'t>,
        _expression06_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression06_list =
            pop_and_reverse_item!(self, expression06_list, Expression06List, context);
        let expression07 = pop_item!(self, expression07, Expression07, context);
        let expression06_built = Expression06 {
            expression07: Box::new(expression07),
            expression06_list,
        };
        // Calling user action here
        self.user_grammar.expression06(&expression06_built)?;
        self.push(ASTType::Expression06(expression06_built), context);
        Ok(())
    }

    /// Semantic action for production 348:
    ///
    /// Expression06List /* Vec<T>::Push */: Operator07 Expression07 Expression06List;
    ///
    #[parol_runtime::function_name::named]
    fn expression06_list_0(
        &mut self,
        _operator07: &ParseTreeType<'t>,
        _expression07: &ParseTreeType<'t>,
        _expression06_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression06_list = pop_item!(self, expression06_list, Expression06List, context);
        let expression07 = pop_item!(self, expression07, Expression07, context);
        let operator07 = pop_item!(self, operator07, Operator07, context);
        let expression06_list_0_built = Expression06List {
            expression07: Box::new(expression07),
            operator07: Box::new(operator07),
        };
        // Add an element to the vector
        expression06_list.push(expression06_list_0_built);
        self.push(ASTType::Expression06List(expression06_list), context);
        Ok(())
    }

    /// Semantic action for production 349:
    ///
    /// Expression06List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression06_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression06_list_1_built = Vec::new();
        self.push(
            ASTType::Expression06List(expression06_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 350:
    ///
    /// Expression07: Expression08 Expression07List /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression07(
        &mut self,
        _expression08: &ParseTreeType<'t>,
        _expression07_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression07_list =
            pop_and_reverse_item!(self, expression07_list, Expression07List, context);
        let expression08 = pop_item!(self, expression08, Expression08, context);
        let expression07_built = Expression07 {
            expression08: Box::new(expression08),
            expression07_list,
        };
        // Calling user action here
        self.user_grammar.expression07(&expression07_built)?;
        self.push(ASTType::Expression07(expression07_built), context);
        Ok(())
    }

    /// Semantic action for production 351:
    ///
    /// Expression07List /* Vec<T>::Push */: Operator08 Expression08 Expression07List;
    ///
    #[parol_runtime::function_name::named]
    fn expression07_list_0(
        &mut self,
        _operator08: &ParseTreeType<'t>,
        _expression08: &ParseTreeType<'t>,
        _expression07_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression07_list = pop_item!(self, expression07_list, Expression07List, context);
        let expression08 = pop_item!(self, expression08, Expression08, context);
        let operator08 = pop_item!(self, operator08, Operator08, context);
        let expression07_list_0_built = Expression07List {
            expression08: Box::new(expression08),
            operator08: Box::new(operator08),
        };
        // Add an element to the vector
        expression07_list.push(expression07_list_0_built);
        self.push(ASTType::Expression07List(expression07_list), context);
        Ok(())
    }

    /// Semantic action for production 352:
    ///
    /// Expression07List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression07_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression07_list_1_built = Vec::new();
        self.push(
            ASTType::Expression07List(expression07_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 353:
    ///
    /// Expression08: Expression09 Expression08List /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression08(
        &mut self,
        _expression09: &ParseTreeType<'t>,
        _expression08_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression08_list =
            pop_and_reverse_item!(self, expression08_list, Expression08List, context);
        let expression09 = pop_item!(self, expression09, Expression09, context);
        let expression08_built = Expression08 {
            expression09: Box::new(expression09),
            expression08_list,
        };
        // Calling user action here
        self.user_grammar.expression08(&expression08_built)?;
        self.push(ASTType::Expression08(expression08_built), context);
        Ok(())
    }

    /// Semantic action for production 354:
    ///
    /// Expression08List /* Vec<T>::Push */: Operator09 Expression09 Expression08List;
    ///
    #[parol_runtime::function_name::named]
    fn expression08_list_0(
        &mut self,
        _operator09: &ParseTreeType<'t>,
        _expression09: &ParseTreeType<'t>,
        _expression08_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression08_list = pop_item!(self, expression08_list, Expression08List, context);
        let expression09 = pop_item!(self, expression09, Expression09, context);
        let operator09 = pop_item!(self, operator09, Operator09, context);
        let expression08_list_0_built = Expression08List {
            expression09: Box::new(expression09),
            operator09: Box::new(operator09),
        };
        // Add an element to the vector
        expression08_list.push(expression08_list_0_built);
        self.push(ASTType::Expression08List(expression08_list), context);
        Ok(())
    }

    /// Semantic action for production 355:
    ///
    /// Expression08List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression08_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression08_list_1_built = Vec::new();
        self.push(
            ASTType::Expression08List(expression08_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 356:
    ///
    /// Expression09: Expression10 Expression09List /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression09(
        &mut self,
        _expression10: &ParseTreeType<'t>,
        _expression09_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression09_list =
            pop_and_reverse_item!(self, expression09_list, Expression09List, context);
        let expression10 = pop_item!(self, expression10, Expression10, context);
        let expression09_built = Expression09 {
            expression10: Box::new(expression10),
            expression09_list,
        };
        // Calling user action here
        self.user_grammar.expression09(&expression09_built)?;
        self.push(ASTType::Expression09(expression09_built), context);
        Ok(())
    }

    /// Semantic action for production 357:
    ///
    /// Expression09List /* Vec<T>::Push */: Expression09ListGroup Expression10 Expression09List;
    ///
    #[parol_runtime::function_name::named]
    fn expression09_list_0(
        &mut self,
        _expression09_list_group: &ParseTreeType<'t>,
        _expression10: &ParseTreeType<'t>,
        _expression09_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression09_list = pop_item!(self, expression09_list, Expression09List, context);
        let expression10 = pop_item!(self, expression10, Expression10, context);
        let expression09_list_group = pop_item!(
            self,
            expression09_list_group,
            Expression09ListGroup,
            context
        );
        let expression09_list_0_built = Expression09List {
            expression10: Box::new(expression10),
            expression09_list_group: Box::new(expression09_list_group),
        };
        // Add an element to the vector
        expression09_list.push(expression09_list_0_built);
        self.push(ASTType::Expression09List(expression09_list), context);
        Ok(())
    }

    /// Semantic action for production 358:
    ///
    /// Expression09ListGroup: Operator10;
    ///
    #[parol_runtime::function_name::named]
    fn expression09_list_group_0(&mut self, _operator10: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator10 = pop_item!(self, operator10, Operator10, context);
        let expression09_list_group_0_built = Expression09ListGroupOperator10 {
            operator10: Box::new(operator10),
        };
        let expression09_list_group_0_built =
            Expression09ListGroup::Operator10(expression09_list_group_0_built);
        self.push(
            ASTType::Expression09ListGroup(expression09_list_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 359:
    ///
    /// Expression09ListGroup: Star;
    ///
    #[parol_runtime::function_name::named]
    fn expression09_list_group_1(&mut self, _star: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let star = pop_item!(self, star, Star, context);
        let expression09_list_group_1_built = Expression09ListGroupStar {
            star: Box::new(star),
        };
        let expression09_list_group_1_built =
            Expression09ListGroup::Star(expression09_list_group_1_built);
        self.push(
            ASTType::Expression09ListGroup(expression09_list_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 360:
    ///
    /// Expression09List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression09_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression09_list_1_built = Vec::new();
        self.push(
            ASTType::Expression09List(expression09_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 361:
    ///
    /// Expression10: Expression11 Expression10List /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression10(
        &mut self,
        _expression11: &ParseTreeType<'t>,
        _expression10_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression10_list =
            pop_and_reverse_item!(self, expression10_list, Expression10List, context);
        let expression11 = pop_item!(self, expression11, Expression11, context);
        let expression10_built = Expression10 {
            expression11: Box::new(expression11),
            expression10_list,
        };
        // Calling user action here
        self.user_grammar.expression10(&expression10_built)?;
        self.push(ASTType::Expression10(expression10_built), context);
        Ok(())
    }

    /// Semantic action for production 362:
    ///
    /// Expression10List /* Vec<T>::Push */: Operator11 Expression11 Expression10List;
    ///
    #[parol_runtime::function_name::named]
    fn expression10_list_0(
        &mut self,
        _operator11: &ParseTreeType<'t>,
        _expression11: &ParseTreeType<'t>,
        _expression10_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression10_list = pop_item!(self, expression10_list, Expression10List, context);
        let expression11 = pop_item!(self, expression11, Expression11, context);
        let operator11 = pop_item!(self, operator11, Operator11, context);
        let expression10_list_0_built = Expression10List {
            expression11: Box::new(expression11),
            operator11: Box::new(operator11),
        };
        // Add an element to the vector
        expression10_list.push(expression10_list_0_built);
        self.push(ASTType::Expression10List(expression10_list), context);
        Ok(())
    }

    /// Semantic action for production 363:
    ///
    /// Expression10List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression10_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression10_list_1_built = Vec::new();
        self.push(
            ASTType::Expression10List(expression10_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 364:
    ///
    /// Expression11: Expression12 Expression11List /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression11(
        &mut self,
        _expression12: &ParseTreeType<'t>,
        _expression11_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression11_list =
            pop_and_reverse_item!(self, expression11_list, Expression11List, context);
        let expression12 = pop_item!(self, expression12, Expression12, context);
        let expression11_built = Expression11 {
            expression12: Box::new(expression12),
            expression11_list,
        };
        // Calling user action here
        self.user_grammar.expression11(&expression11_built)?;
        self.push(ASTType::Expression11(expression11_built), context);
        Ok(())
    }

    /// Semantic action for production 365:
    ///
    /// Expression11List /* Vec<T>::Push */: As ScopedIdentifier Expression11List;
    ///
    #[parol_runtime::function_name::named]
    fn expression11_list_0(
        &mut self,
        _as: &ParseTreeType<'t>,
        _scoped_identifier: &ParseTreeType<'t>,
        _expression11_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression11_list = pop_item!(self, expression11_list, Expression11List, context);
        let scoped_identifier = pop_item!(self, scoped_identifier, ScopedIdentifier, context);
        let r#as = pop_item!(self, r#as, As, context);
        let expression11_list_0_built = Expression11List {
            scoped_identifier: Box::new(scoped_identifier),
            r#as: Box::new(r#as),
        };
        // Add an element to the vector
        expression11_list.push(expression11_list_0_built);
        self.push(ASTType::Expression11List(expression11_list), context);
        Ok(())
    }

    /// Semantic action for production 366:
    ///
    /// Expression11List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression11_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression11_list_1_built = Vec::new();
        self.push(
            ASTType::Expression11List(expression11_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 367:
    ///
    /// Expression12: Expression12List /* Vec */ Factor;
    ///
    #[parol_runtime::function_name::named]
    fn expression12(
        &mut self,
        _expression12_list: &ParseTreeType<'t>,
        _factor: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor = pop_item!(self, factor, Factor, context);
        let expression12_list =
            pop_and_reverse_item!(self, expression12_list, Expression12List, context);
        let expression12_built = Expression12 {
            expression12_list,
            factor: Box::new(factor),
        };
        // Calling user action here
        self.user_grammar.expression12(&expression12_built)?;
        self.push(ASTType::Expression12(expression12_built), context);
        Ok(())
    }

    /// Semantic action for production 368:
    ///
    /// Expression12List /* Vec<T>::Push */: Expression12ListGroup Expression12List;
    ///
    #[parol_runtime::function_name::named]
    fn expression12_list_0(
        &mut self,
        _expression12_list_group: &ParseTreeType<'t>,
        _expression12_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression12_list = pop_item!(self, expression12_list, Expression12List, context);
        let expression12_list_group = pop_item!(
            self,
            expression12_list_group,
            Expression12ListGroup,
            context
        );
        let expression12_list_0_built = Expression12List {
            expression12_list_group: Box::new(expression12_list_group),
        };
        // Add an element to the vector
        expression12_list.push(expression12_list_0_built);
        self.push(ASTType::Expression12List(expression12_list), context);
        Ok(())
    }

    /// Semantic action for production 369:
    ///
    /// Expression12ListGroup: UnaryOperator;
    ///
    #[parol_runtime::function_name::named]
    fn expression12_list_group_0(&mut self, _unary_operator: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unary_operator = pop_item!(self, unary_operator, UnaryOperator, context);
        let expression12_list_group_0_built = Expression12ListGroupUnaryOperator {
            unary_operator: Box::new(unary_operator),
        };
        let expression12_list_group_0_built =
            Expression12ListGroup::UnaryOperator(expression12_list_group_0_built);
        self.push(
            ASTType::Expression12ListGroup(expression12_list_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 370:
    ///
    /// Expression12ListGroup: Operator09;
    ///
    #[parol_runtime::function_name::named]
    fn expression12_list_group_1(&mut self, _operator09: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator09 = pop_item!(self, operator09, Operator09, context);
        let expression12_list_group_1_built = Expression12ListGroupOperator09 {
            operator09: Box::new(operator09),
        };
        let expression12_list_group_1_built =
            Expression12ListGroup::Operator09(expression12_list_group_1_built);
        self.push(
            ASTType::Expression12ListGroup(expression12_list_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 371:
    ///
    /// Expression12ListGroup: Operator05;
    ///
    #[parol_runtime::function_name::named]
    fn expression12_list_group_2(&mut self, _operator05: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator05 = pop_item!(self, operator05, Operator05, context);
        let expression12_list_group_2_built = Expression12ListGroupOperator05 {
            operator05: Box::new(operator05),
        };
        let expression12_list_group_2_built =
            Expression12ListGroup::Operator05(expression12_list_group_2_built);
        self.push(
            ASTType::Expression12ListGroup(expression12_list_group_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 372:
    ///
    /// Expression12ListGroup: Operator03;
    ///
    #[parol_runtime::function_name::named]
    fn expression12_list_group_3(&mut self, _operator03: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator03 = pop_item!(self, operator03, Operator03, context);
        let expression12_list_group_3_built = Expression12ListGroupOperator03 {
            operator03: Box::new(operator03),
        };
        let expression12_list_group_3_built =
            Expression12ListGroup::Operator03(expression12_list_group_3_built);
        self.push(
            ASTType::Expression12ListGroup(expression12_list_group_3_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 373:
    ///
    /// Expression12ListGroup: Operator04;
    ///
    #[parol_runtime::function_name::named]
    fn expression12_list_group_4(&mut self, _operator04: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator04 = pop_item!(self, operator04, Operator04, context);
        let expression12_list_group_4_built = Expression12ListGroupOperator04 {
            operator04: Box::new(operator04),
        };
        let expression12_list_group_4_built =
            Expression12ListGroup::Operator04(expression12_list_group_4_built);
        self.push(
            ASTType::Expression12ListGroup(expression12_list_group_4_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 374:
    ///
    /// Expression12List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression12_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression12_list_1_built = Vec::new();
        self.push(
            ASTType::Expression12List(expression12_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 375:
    ///
    /// Factor: Number;
    ///
    #[parol_runtime::function_name::named]
    fn factor_0(&mut self, _number: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let number = pop_item!(self, number, Number, context);
        let factor_0_built = FactorNumber {
            number: Box::new(number),
        };
        let factor_0_built = Factor::Number(factor_0_built);
        // Calling user action here
        self.user_grammar.factor(&factor_0_built)?;
        self.push(ASTType::Factor(factor_0_built), context);
        Ok(())
    }

    /// Semantic action for production 376:
    ///
    /// Factor: ExpressionIdentifier FactorOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn factor_1(
        &mut self,
        _expression_identifier: &ParseTreeType<'t>,
        _factor_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor_opt = pop_item!(self, factor_opt, FactorOpt, context);
        let expression_identifier =
            pop_item!(self, expression_identifier, ExpressionIdentifier, context);
        let factor_1_built = FactorExpressionIdentifierFactorOpt {
            expression_identifier: Box::new(expression_identifier),
            factor_opt,
        };
        let factor_1_built = Factor::ExpressionIdentifierFactorOpt(factor_1_built);
        // Calling user action here
        self.user_grammar.factor(&factor_1_built)?;
        self.push(ASTType::Factor(factor_1_built), context);
        Ok(())
    }

    /// Semantic action for production 377:
    ///
    /// Factor: LParen Expression RParen;
    ///
    #[parol_runtime::function_name::named]
    fn factor_2(
        &mut self,
        _l_paren: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let expression = pop_item!(self, expression, Expression, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let factor_2_built = FactorLParenExpressionRParen {
            l_paren: Box::new(l_paren),
            expression: Box::new(expression),
            r_paren: Box::new(r_paren),
        };
        let factor_2_built = Factor::LParenExpressionRParen(factor_2_built);
        // Calling user action here
        self.user_grammar.factor(&factor_2_built)?;
        self.push(ASTType::Factor(factor_2_built), context);
        Ok(())
    }

    /// Semantic action for production 378:
    ///
    /// Factor: LBrace ConcatenationList RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn factor_3(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _concatenation_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let concatenation_list = pop_item!(self, concatenation_list, ConcatenationList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let factor_3_built = FactorLBraceConcatenationListRBrace {
            l_brace: Box::new(l_brace),
            concatenation_list: Box::new(concatenation_list),
            r_brace: Box::new(r_brace),
        };
        let factor_3_built = Factor::LBraceConcatenationListRBrace(factor_3_built);
        // Calling user action here
        self.user_grammar.factor(&factor_3_built)?;
        self.push(ASTType::Factor(factor_3_built), context);
        Ok(())
    }

    /// Semantic action for production 379:
    ///
    /// Factor: IfExpression;
    ///
    #[parol_runtime::function_name::named]
    fn factor_4(&mut self, _if_expression: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_expression = pop_item!(self, if_expression, IfExpression, context);
        let factor_4_built = FactorIfExpression {
            if_expression: Box::new(if_expression),
        };
        let factor_4_built = Factor::IfExpression(factor_4_built);
        // Calling user action here
        self.user_grammar.factor(&factor_4_built)?;
        self.push(ASTType::Factor(factor_4_built), context);
        Ok(())
    }

    /// Semantic action for production 380:
    ///
    /// Factor: CaseExpression;
    ///
    #[parol_runtime::function_name::named]
    fn factor_5(&mut self, _case_expression: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let case_expression = pop_item!(self, case_expression, CaseExpression, context);
        let factor_5_built = FactorCaseExpression {
            case_expression: Box::new(case_expression),
        };
        let factor_5_built = Factor::CaseExpression(factor_5_built);
        // Calling user action here
        self.user_grammar.factor(&factor_5_built)?;
        self.push(ASTType::Factor(factor_5_built), context);
        Ok(())
    }

    /// Semantic action for production 381:
    ///
    /// Factor: StringLiteral;
    ///
    #[parol_runtime::function_name::named]
    fn factor_6(&mut self, _string_literal: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string_literal = pop_item!(self, string_literal, StringLiteral, context);
        let factor_6_built = FactorStringLiteral {
            string_literal: Box::new(string_literal),
        };
        let factor_6_built = Factor::StringLiteral(factor_6_built);
        // Calling user action here
        self.user_grammar.factor(&factor_6_built)?;
        self.push(ASTType::Factor(factor_6_built), context);
        Ok(())
    }

    /// Semantic action for production 382:
    ///
    /// Factor: FactorGroup;
    ///
    #[parol_runtime::function_name::named]
    fn factor_7(&mut self, _factor_group: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor_group = pop_item!(self, factor_group, FactorGroup, context);
        let factor_7_built = FactorFactorGroup {
            factor_group: Box::new(factor_group),
        };
        let factor_7_built = Factor::FactorGroup(factor_7_built);
        // Calling user action here
        self.user_grammar.factor(&factor_7_built)?;
        self.push(ASTType::Factor(factor_7_built), context);
        Ok(())
    }

    /// Semantic action for production 383:
    ///
    /// FactorGroup: Msb;
    ///
    #[parol_runtime::function_name::named]
    fn factor_group_0(&mut self, _msb: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let msb = pop_item!(self, msb, Msb, context);
        let factor_group_0_built = FactorGroupMsb { msb: Box::new(msb) };
        let factor_group_0_built = FactorGroup::Msb(factor_group_0_built);
        self.push(ASTType::FactorGroup(factor_group_0_built), context);
        Ok(())
    }

    /// Semantic action for production 384:
    ///
    /// FactorGroup: Lsb;
    ///
    #[parol_runtime::function_name::named]
    fn factor_group_1(&mut self, _lsb: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let lsb = pop_item!(self, lsb, Lsb, context);
        let factor_group_1_built = FactorGroupLsb { lsb: Box::new(lsb) };
        let factor_group_1_built = FactorGroup::Lsb(factor_group_1_built);
        self.push(ASTType::FactorGroup(factor_group_1_built), context);
        Ok(())
    }

    /// Semantic action for production 385:
    ///
    /// Factor: InsideExpression;
    ///
    #[parol_runtime::function_name::named]
    fn factor_8(&mut self, _inside_expression: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inside_expression = pop_item!(self, inside_expression, InsideExpression, context);
        let factor_8_built = FactorInsideExpression {
            inside_expression: Box::new(inside_expression),
        };
        let factor_8_built = Factor::InsideExpression(factor_8_built);
        // Calling user action here
        self.user_grammar.factor(&factor_8_built)?;
        self.push(ASTType::Factor(factor_8_built), context);
        Ok(())
    }

    /// Semantic action for production 386:
    ///
    /// Factor: OutsideExpression;
    ///
    #[parol_runtime::function_name::named]
    fn factor_9(&mut self, _outside_expression: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let outside_expression = pop_item!(self, outside_expression, OutsideExpression, context);
        let factor_9_built = FactorOutsideExpression {
            outside_expression: Box::new(outside_expression),
        };
        let factor_9_built = Factor::OutsideExpression(factor_9_built);
        // Calling user action here
        self.user_grammar.factor(&factor_9_built)?;
        self.push(ASTType::Factor(factor_9_built), context);
        Ok(())
    }

    /// Semantic action for production 387:
    ///
    /// FactorOpt /* Option<T>::Some */: FunctionCall;
    ///
    #[parol_runtime::function_name::named]
    fn factor_opt_0(&mut self, _function_call: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_call = pop_item!(self, function_call, FunctionCall, context);
        let factor_opt_0_built = FactorOpt {
            function_call: Box::new(function_call),
        };
        self.push(
            ASTType::FactorOpt(Some(Box::new(factor_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 388:
    ///
    /// FactorOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn factor_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FactorOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 389:
    ///
    /// FunctionCall: LParen FunctionCallOpt /* Option */ RParen;
    ///
    #[parol_runtime::function_name::named]
    fn function_call(
        &mut self,
        _l_paren: &ParseTreeType<'t>,
        _function_call_opt: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let function_call_opt = pop_item!(self, function_call_opt, FunctionCallOpt, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let function_call_built = FunctionCall {
            l_paren: Box::new(l_paren),
            function_call_opt,
            r_paren: Box::new(r_paren),
        };
        // Calling user action here
        self.user_grammar.function_call(&function_call_built)?;
        self.push(ASTType::FunctionCall(function_call_built), context);
        Ok(())
    }

    /// Semantic action for production 390:
    ///
    /// FunctionCallOpt /* Option<T>::Some */: ArgumentList;
    ///
    #[parol_runtime::function_name::named]
    fn function_call_opt_0(&mut self, _argument_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let argument_list = pop_item!(self, argument_list, ArgumentList, context);
        let function_call_opt_0_built = FunctionCallOpt {
            argument_list: Box::new(argument_list),
        };
        self.push(
            ASTType::FunctionCallOpt(Some(Box::new(function_call_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 391:
    ///
    /// FunctionCallOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn function_call_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FunctionCallOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 392:
    ///
    /// ArgumentList: ArgumentItem ArgumentListList /* Vec */ ArgumentListOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn argument_list(
        &mut self,
        _argument_item: &ParseTreeType<'t>,
        _argument_list_list: &ParseTreeType<'t>,
        _argument_list_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let argument_list_opt = pop_item!(self, argument_list_opt, ArgumentListOpt, context);
        let argument_list_list =
            pop_and_reverse_item!(self, argument_list_list, ArgumentListList, context);
        let argument_item = pop_item!(self, argument_item, ArgumentItem, context);
        let argument_list_built = ArgumentList {
            argument_item: Box::new(argument_item),
            argument_list_list,
            argument_list_opt,
        };
        // Calling user action here
        self.user_grammar.argument_list(&argument_list_built)?;
        self.push(ASTType::ArgumentList(argument_list_built), context);
        Ok(())
    }

    /// Semantic action for production 393:
    ///
    /// ArgumentListList /* Vec<T>::Push */: Comma ArgumentItem ArgumentListList;
    ///
    #[parol_runtime::function_name::named]
    fn argument_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _argument_item: &ParseTreeType<'t>,
        _argument_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut argument_list_list = pop_item!(self, argument_list_list, ArgumentListList, context);
        let argument_item = pop_item!(self, argument_item, ArgumentItem, context);
        let comma = pop_item!(self, comma, Comma, context);
        let argument_list_list_0_built = ArgumentListList {
            argument_item: Box::new(argument_item),
            comma: Box::new(comma),
        };
        // Add an element to the vector
        argument_list_list.push(argument_list_list_0_built);
        self.push(ASTType::ArgumentListList(argument_list_list), context);
        Ok(())
    }

    /// Semantic action for production 394:
    ///
    /// ArgumentListList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn argument_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let argument_list_list_1_built = Vec::new();
        self.push(
            ASTType::ArgumentListList(argument_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 395:
    ///
    /// ArgumentListOpt /* Option<T>::Some */: Comma;
    ///
    #[parol_runtime::function_name::named]
    fn argument_list_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let argument_list_opt_0_built = ArgumentListOpt {
            comma: Box::new(comma),
        };
        self.push(
            ASTType::ArgumentListOpt(Some(Box::new(argument_list_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 396:
    ///
    /// ArgumentListOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn argument_list_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ArgumentListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 397:
    ///
    /// ArgumentItem: Expression;
    ///
    #[parol_runtime::function_name::named]
    fn argument_item(&mut self, _expression: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let argument_item_built = ArgumentItem {
            expression: Box::new(expression),
        };
        // Calling user action here
        self.user_grammar.argument_item(&argument_item_built)?;
        self.push(ASTType::ArgumentItem(argument_item_built), context);
        Ok(())
    }

    /// Semantic action for production 398:
    ///
    /// ConcatenationList: ConcatenationItem ConcatenationListList /* Vec */ ConcatenationListOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn concatenation_list(
        &mut self,
        _concatenation_item: &ParseTreeType<'t>,
        _concatenation_list_list: &ParseTreeType<'t>,
        _concatenation_list_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let concatenation_list_opt =
            pop_item!(self, concatenation_list_opt, ConcatenationListOpt, context);
        let concatenation_list_list = pop_and_reverse_item!(
            self,
            concatenation_list_list,
            ConcatenationListList,
            context
        );
        let concatenation_item = pop_item!(self, concatenation_item, ConcatenationItem, context);
        let concatenation_list_built = ConcatenationList {
            concatenation_item: Box::new(concatenation_item),
            concatenation_list_list,
            concatenation_list_opt,
        };
        // Calling user action here
        self.user_grammar
            .concatenation_list(&concatenation_list_built)?;
        self.push(
            ASTType::ConcatenationList(concatenation_list_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 399:
    ///
    /// ConcatenationListList /* Vec<T>::Push */: Comma ConcatenationItem ConcatenationListList;
    ///
    #[parol_runtime::function_name::named]
    fn concatenation_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _concatenation_item: &ParseTreeType<'t>,
        _concatenation_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut concatenation_list_list = pop_item!(
            self,
            concatenation_list_list,
            ConcatenationListList,
            context
        );
        let concatenation_item = pop_item!(self, concatenation_item, ConcatenationItem, context);
        let comma = pop_item!(self, comma, Comma, context);
        let concatenation_list_list_0_built = ConcatenationListList {
            concatenation_item: Box::new(concatenation_item),
            comma: Box::new(comma),
        };
        // Add an element to the vector
        concatenation_list_list.push(concatenation_list_list_0_built);
        self.push(
            ASTType::ConcatenationListList(concatenation_list_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 400:
    ///
    /// ConcatenationListList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn concatenation_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let concatenation_list_list_1_built = Vec::new();
        self.push(
            ASTType::ConcatenationListList(concatenation_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 401:
    ///
    /// ConcatenationListOpt /* Option<T>::Some */: Comma;
    ///
    #[parol_runtime::function_name::named]
    fn concatenation_list_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let concatenation_list_opt_0_built = ConcatenationListOpt {
            comma: Box::new(comma),
        };
        self.push(
            ASTType::ConcatenationListOpt(Some(Box::new(concatenation_list_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 402:
    ///
    /// ConcatenationListOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn concatenation_list_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ConcatenationListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 403:
    ///
    /// ConcatenationItem: Expression ConcatenationItemOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn concatenation_item(
        &mut self,
        _expression: &ParseTreeType<'t>,
        _concatenation_item_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let concatenation_item_opt =
            pop_item!(self, concatenation_item_opt, ConcatenationItemOpt, context);
        let expression = pop_item!(self, expression, Expression, context);
        let concatenation_item_built = ConcatenationItem {
            expression: Box::new(expression),
            concatenation_item_opt,
        };
        // Calling user action here
        self.user_grammar
            .concatenation_item(&concatenation_item_built)?;
        self.push(
            ASTType::ConcatenationItem(concatenation_item_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 404:
    ///
    /// ConcatenationItemOpt /* Option<T>::Some */: Repeat Expression;
    ///
    #[parol_runtime::function_name::named]
    fn concatenation_item_opt_0(
        &mut self,
        _repeat: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let repeat = pop_item!(self, repeat, Repeat, context);
        let concatenation_item_opt_0_built = ConcatenationItemOpt {
            repeat: Box::new(repeat),
            expression: Box::new(expression),
        };
        self.push(
            ASTType::ConcatenationItemOpt(Some(Box::new(concatenation_item_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 405:
    ///
    /// ConcatenationItemOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn concatenation_item_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ConcatenationItemOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 406:
    ///
    /// IfExpression: If Expression LBrace Expression RBrace IfExpressionList /* Vec */ Else LBrace Expression RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn if_expression(
        &mut self,
        _if: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _expression0: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
        _if_expression_list: &ParseTreeType<'t>,
        _else: &ParseTreeType<'t>,
        _l_brace0: &ParseTreeType<'t>,
        _expression1: &ParseTreeType<'t>,
        _r_brace0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace0 = pop_item!(self, r_brace0, RBrace, context);
        let expression1 = pop_item!(self, expression1, Expression, context);
        let l_brace0 = pop_item!(self, l_brace0, LBrace, context);
        let r#else = pop_item!(self, r#else, Else, context);
        let if_expression_list =
            pop_and_reverse_item!(self, if_expression_list, IfExpressionList, context);
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let expression0 = pop_item!(self, expression0, Expression, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let expression = pop_item!(self, expression, Expression, context);
        let r#if = pop_item!(self, r#if, If, context);
        let if_expression_built = IfExpression {
            r#if: Box::new(r#if),
            expression: Box::new(expression),
            l_brace: Box::new(l_brace),
            expression0: Box::new(expression0),
            r_brace: Box::new(r_brace),
            if_expression_list,
            r#else: Box::new(r#else),
            l_brace0: Box::new(l_brace0),
            expression1: Box::new(expression1),
            r_brace0: Box::new(r_brace0),
        };
        // Calling user action here
        self.user_grammar.if_expression(&if_expression_built)?;
        self.push(ASTType::IfExpression(if_expression_built), context);
        Ok(())
    }

    /// Semantic action for production 407:
    ///
    /// IfExpressionList /* Vec<T>::Push */: Else If Expression LBrace Expression RBrace IfExpressionList;
    ///
    #[parol_runtime::function_name::named]
    fn if_expression_list_0(
        &mut self,
        _else: &ParseTreeType<'t>,
        _if: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _expression0: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
        _if_expression_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut if_expression_list = pop_item!(self, if_expression_list, IfExpressionList, context);
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let expression0 = pop_item!(self, expression0, Expression, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let expression = pop_item!(self, expression, Expression, context);
        let r#if = pop_item!(self, r#if, If, context);
        let r#else = pop_item!(self, r#else, Else, context);
        let if_expression_list_0_built = IfExpressionList {
            r_brace: Box::new(r_brace),
            expression0: Box::new(expression0),
            l_brace: Box::new(l_brace),
            expression: Box::new(expression),
            r#if: Box::new(r#if),
            r#else: Box::new(r#else),
        };
        // Add an element to the vector
        if_expression_list.push(if_expression_list_0_built);
        self.push(ASTType::IfExpressionList(if_expression_list), context);
        Ok(())
    }

    /// Semantic action for production 408:
    ///
    /// IfExpressionList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn if_expression_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_expression_list_1_built = Vec::new();
        self.push(
            ASTType::IfExpressionList(if_expression_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 409:
    ///
    /// CaseExpression: Case Expression LBrace Expression Colon Expression Comma CaseExpressionList /* Vec */ Defaul Colon Expression CaseExpressionOpt /* Option */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn case_expression(
        &mut self,
        _case: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _expression0: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _expression1: &ParseTreeType<'t>,
        _comma: &ParseTreeType<'t>,
        _case_expression_list: &ParseTreeType<'t>,
        _defaul: &ParseTreeType<'t>,
        _colon0: &ParseTreeType<'t>,
        _expression2: &ParseTreeType<'t>,
        _case_expression_opt: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let case_expression_opt = pop_item!(self, case_expression_opt, CaseExpressionOpt, context);
        let expression2 = pop_item!(self, expression2, Expression, context);
        let colon0 = pop_item!(self, colon0, Colon, context);
        let defaul = pop_item!(self, defaul, Defaul, context);
        let case_expression_list =
            pop_and_reverse_item!(self, case_expression_list, CaseExpressionList, context);
        let comma = pop_item!(self, comma, Comma, context);
        let expression1 = pop_item!(self, expression1, Expression, context);
        let colon = pop_item!(self, colon, Colon, context);
        let expression0 = pop_item!(self, expression0, Expression, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let expression = pop_item!(self, expression, Expression, context);
        let case = pop_item!(self, case, Case, context);
        let case_expression_built = CaseExpression {
            case: Box::new(case),
            expression: Box::new(expression),
            l_brace: Box::new(l_brace),
            expression0: Box::new(expression0),
            colon: Box::new(colon),
            expression1: Box::new(expression1),
            comma: Box::new(comma),
            case_expression_list,
            defaul: Box::new(defaul),
            colon0: Box::new(colon0),
            expression2: Box::new(expression2),
            case_expression_opt,
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar.case_expression(&case_expression_built)?;
        self.push(ASTType::CaseExpression(case_expression_built), context);
        Ok(())
    }

    /// Semantic action for production 410:
    ///
    /// CaseExpressionList /* Vec<T>::Push */: Expression Colon Expression Comma CaseExpressionList;
    ///
    #[parol_runtime::function_name::named]
    fn case_expression_list_0(
        &mut self,
        _expression: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _expression0: &ParseTreeType<'t>,
        _comma: &ParseTreeType<'t>,
        _case_expression_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut case_expression_list =
            pop_item!(self, case_expression_list, CaseExpressionList, context);
        let comma = pop_item!(self, comma, Comma, context);
        let expression0 = pop_item!(self, expression0, Expression, context);
        let colon = pop_item!(self, colon, Colon, context);
        let expression = pop_item!(self, expression, Expression, context);
        let case_expression_list_0_built = CaseExpressionList {
            comma: Box::new(comma),
            expression0: Box::new(expression0),
            colon: Box::new(colon),
            expression: Box::new(expression),
        };
        // Add an element to the vector
        case_expression_list.push(case_expression_list_0_built);
        self.push(ASTType::CaseExpressionList(case_expression_list), context);
        Ok(())
    }

    /// Semantic action for production 411:
    ///
    /// CaseExpressionList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn case_expression_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let case_expression_list_1_built = Vec::new();
        self.push(
            ASTType::CaseExpressionList(case_expression_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 412:
    ///
    /// CaseExpressionOpt /* Option<T>::Some */: Comma;
    ///
    #[parol_runtime::function_name::named]
    fn case_expression_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let case_expression_opt_0_built = CaseExpressionOpt {
            comma: Box::new(comma),
        };
        self.push(
            ASTType::CaseExpressionOpt(Some(Box::new(case_expression_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 413:
    ///
    /// CaseExpressionOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn case_expression_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::CaseExpressionOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 414:
    ///
    /// TypeExpression: ScalarType;
    ///
    #[parol_runtime::function_name::named]
    fn type_expression_0(&mut self, _scalar_type: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scalar_type = pop_item!(self, scalar_type, ScalarType, context);
        let type_expression_0_built = TypeExpressionScalarType {
            scalar_type: Box::new(scalar_type),
        };
        let type_expression_0_built = TypeExpression::ScalarType(type_expression_0_built);
        // Calling user action here
        self.user_grammar
            .type_expression(&type_expression_0_built)?;
        self.push(ASTType::TypeExpression(type_expression_0_built), context);
        Ok(())
    }

    /// Semantic action for production 415:
    ///
    /// TypeExpression: Type LParen Expression RParen;
    ///
    #[parol_runtime::function_name::named]
    fn type_expression_1(
        &mut self,
        _type: &ParseTreeType<'t>,
        _l_paren: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let expression = pop_item!(self, expression, Expression, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let r#type = pop_item!(self, r#type, Type, context);
        let type_expression_1_built = TypeExpressionTypeLParenExpressionRParen {
            r#type: Box::new(r#type),
            l_paren: Box::new(l_paren),
            expression: Box::new(expression),
            r_paren: Box::new(r_paren),
        };
        let type_expression_1_built =
            TypeExpression::TypeLParenExpressionRParen(type_expression_1_built);
        // Calling user action here
        self.user_grammar
            .type_expression(&type_expression_1_built)?;
        self.push(ASTType::TypeExpression(type_expression_1_built), context);
        Ok(())
    }

    /// Semantic action for production 416:
    ///
    /// InsideExpression: Inside Expression LBrace RangeList RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn inside_expression(
        &mut self,
        _inside: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _range_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let range_list = pop_item!(self, range_list, RangeList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let expression = pop_item!(self, expression, Expression, context);
        let inside = pop_item!(self, inside, Inside, context);
        let inside_expression_built = InsideExpression {
            inside: Box::new(inside),
            expression: Box::new(expression),
            l_brace: Box::new(l_brace),
            range_list: Box::new(range_list),
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar
            .inside_expression(&inside_expression_built)?;
        self.push(ASTType::InsideExpression(inside_expression_built), context);
        Ok(())
    }

    /// Semantic action for production 417:
    ///
    /// OutsideExpression: Outside Expression LBrace RangeList RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn outside_expression(
        &mut self,
        _outside: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _range_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let range_list = pop_item!(self, range_list, RangeList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let expression = pop_item!(self, expression, Expression, context);
        let outside = pop_item!(self, outside, Outside, context);
        let outside_expression_built = OutsideExpression {
            outside: Box::new(outside),
            expression: Box::new(expression),
            l_brace: Box::new(l_brace),
            range_list: Box::new(range_list),
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar
            .outside_expression(&outside_expression_built)?;
        self.push(
            ASTType::OutsideExpression(outside_expression_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 418:
    ///
    /// RangeList: RangeItem RangeListList /* Vec */ RangeListOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn range_list(
        &mut self,
        _range_item: &ParseTreeType<'t>,
        _range_list_list: &ParseTreeType<'t>,
        _range_list_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let range_list_opt = pop_item!(self, range_list_opt, RangeListOpt, context);
        let range_list_list = pop_and_reverse_item!(self, range_list_list, RangeListList, context);
        let range_item = pop_item!(self, range_item, RangeItem, context);
        let range_list_built = RangeList {
            range_item: Box::new(range_item),
            range_list_list,
            range_list_opt,
        };
        // Calling user action here
        self.user_grammar.range_list(&range_list_built)?;
        self.push(ASTType::RangeList(range_list_built), context);
        Ok(())
    }

    /// Semantic action for production 419:
    ///
    /// RangeListList /* Vec<T>::Push */: Comma RangeItem RangeListList;
    ///
    #[parol_runtime::function_name::named]
    fn range_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _range_item: &ParseTreeType<'t>,
        _range_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut range_list_list = pop_item!(self, range_list_list, RangeListList, context);
        let range_item = pop_item!(self, range_item, RangeItem, context);
        let comma = pop_item!(self, comma, Comma, context);
        let range_list_list_0_built = RangeListList {
            range_item: Box::new(range_item),
            comma: Box::new(comma),
        };
        // Add an element to the vector
        range_list_list.push(range_list_list_0_built);
        self.push(ASTType::RangeListList(range_list_list), context);
        Ok(())
    }

    /// Semantic action for production 420:
    ///
    /// RangeListList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn range_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let range_list_list_1_built = Vec::new();
        self.push(ASTType::RangeListList(range_list_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 421:
    ///
    /// RangeListOpt /* Option<T>::Some */: Comma;
    ///
    #[parol_runtime::function_name::named]
    fn range_list_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let range_list_opt_0_built = RangeListOpt {
            comma: Box::new(comma),
        };
        self.push(
            ASTType::RangeListOpt(Some(Box::new(range_list_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 422:
    ///
    /// RangeListOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn range_list_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::RangeListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 423:
    ///
    /// RangeItem: Range;
    ///
    #[parol_runtime::function_name::named]
    fn range_item(&mut self, _range: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let range = pop_item!(self, range, Range, context);
        let range_item_built = RangeItem {
            range: Box::new(range),
        };
        // Calling user action here
        self.user_grammar.range_item(&range_item_built)?;
        self.push(ASTType::RangeItem(range_item_built), context);
        Ok(())
    }

    /// Semantic action for production 424:
    ///
    /// Select: LBracket Expression SelectOpt /* Option */ RBracket;
    ///
    #[parol_runtime::function_name::named]
    fn select(
        &mut self,
        _l_bracket: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _select_opt: &ParseTreeType<'t>,
        _r_bracket: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_bracket = pop_item!(self, r_bracket, RBracket, context);
        let select_opt = pop_item!(self, select_opt, SelectOpt, context);
        let expression = pop_item!(self, expression, Expression, context);
        let l_bracket = pop_item!(self, l_bracket, LBracket, context);
        let select_built = Select {
            l_bracket: Box::new(l_bracket),
            expression: Box::new(expression),
            select_opt,
            r_bracket: Box::new(r_bracket),
        };
        // Calling user action here
        self.user_grammar.select(&select_built)?;
        self.push(ASTType::Select(select_built), context);
        Ok(())
    }

    /// Semantic action for production 425:
    ///
    /// SelectOpt /* Option<T>::Some */: SelectOperator Expression;
    ///
    #[parol_runtime::function_name::named]
    fn select_opt_0(
        &mut self,
        _select_operator: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let select_operator = pop_item!(self, select_operator, SelectOperator, context);
        let select_opt_0_built = SelectOpt {
            select_operator: Box::new(select_operator),
            expression: Box::new(expression),
        };
        self.push(
            ASTType::SelectOpt(Some(Box::new(select_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 426:
    ///
    /// SelectOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn select_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::SelectOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 427:
    ///
    /// SelectOperator: Colon;
    ///
    #[parol_runtime::function_name::named]
    fn select_operator_0(&mut self, _colon: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon = pop_item!(self, colon, Colon, context);
        let select_operator_0_built = SelectOperatorColon {
            colon: Box::new(colon),
        };
        let select_operator_0_built = SelectOperator::Colon(select_operator_0_built);
        // Calling user action here
        self.user_grammar
            .select_operator(&select_operator_0_built)?;
        self.push(ASTType::SelectOperator(select_operator_0_built), context);
        Ok(())
    }

    /// Semantic action for production 428:
    ///
    /// SelectOperator: PlusColon;
    ///
    #[parol_runtime::function_name::named]
    fn select_operator_1(&mut self, _plus_colon: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus_colon = pop_item!(self, plus_colon, PlusColon, context);
        let select_operator_1_built = SelectOperatorPlusColon {
            plus_colon: Box::new(plus_colon),
        };
        let select_operator_1_built = SelectOperator::PlusColon(select_operator_1_built);
        // Calling user action here
        self.user_grammar
            .select_operator(&select_operator_1_built)?;
        self.push(ASTType::SelectOperator(select_operator_1_built), context);
        Ok(())
    }

    /// Semantic action for production 429:
    ///
    /// SelectOperator: MinusColon;
    ///
    #[parol_runtime::function_name::named]
    fn select_operator_2(&mut self, _minus_colon: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus_colon = pop_item!(self, minus_colon, MinusColon, context);
        let select_operator_2_built = SelectOperatorMinusColon {
            minus_colon: Box::new(minus_colon),
        };
        let select_operator_2_built = SelectOperator::MinusColon(select_operator_2_built);
        // Calling user action here
        self.user_grammar
            .select_operator(&select_operator_2_built)?;
        self.push(ASTType::SelectOperator(select_operator_2_built), context);
        Ok(())
    }

    /// Semantic action for production 430:
    ///
    /// SelectOperator: Step;
    ///
    #[parol_runtime::function_name::named]
    fn select_operator_3(&mut self, _step: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let step = pop_item!(self, step, Step, context);
        let select_operator_3_built = SelectOperatorStep {
            step: Box::new(step),
        };
        let select_operator_3_built = SelectOperator::Step(select_operator_3_built);
        // Calling user action here
        self.user_grammar
            .select_operator(&select_operator_3_built)?;
        self.push(ASTType::SelectOperator(select_operator_3_built), context);
        Ok(())
    }

    /// Semantic action for production 431:
    ///
    /// Width: LAngle Expression WidthList /* Vec */ RAngle;
    ///
    #[parol_runtime::function_name::named]
    fn width(
        &mut self,
        _l_angle: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _width_list: &ParseTreeType<'t>,
        _r_angle: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_angle = pop_item!(self, r_angle, RAngle, context);
        let width_list = pop_and_reverse_item!(self, width_list, WidthList, context);
        let expression = pop_item!(self, expression, Expression, context);
        let l_angle = pop_item!(self, l_angle, LAngle, context);
        let width_built = Width {
            l_angle: Box::new(l_angle),
            expression: Box::new(expression),
            width_list,
            r_angle: Box::new(r_angle),
        };
        // Calling user action here
        self.user_grammar.width(&width_built)?;
        self.push(ASTType::Width(width_built), context);
        Ok(())
    }

    /// Semantic action for production 432:
    ///
    /// WidthList /* Vec<T>::Push */: Comma Expression WidthList;
    ///
    #[parol_runtime::function_name::named]
    fn width_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _width_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut width_list = pop_item!(self, width_list, WidthList, context);
        let expression = pop_item!(self, expression, Expression, context);
        let comma = pop_item!(self, comma, Comma, context);
        let width_list_0_built = WidthList {
            expression: Box::new(expression),
            comma: Box::new(comma),
        };
        // Add an element to the vector
        width_list.push(width_list_0_built);
        self.push(ASTType::WidthList(width_list), context);
        Ok(())
    }

    /// Semantic action for production 433:
    ///
    /// WidthList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn width_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let width_list_1_built = Vec::new();
        self.push(ASTType::WidthList(width_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 434:
    ///
    /// Array: LBracket Expression ArrayList /* Vec */ RBracket;
    ///
    #[parol_runtime::function_name::named]
    fn array(
        &mut self,
        _l_bracket: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _array_list: &ParseTreeType<'t>,
        _r_bracket: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_bracket = pop_item!(self, r_bracket, RBracket, context);
        let array_list = pop_and_reverse_item!(self, array_list, ArrayList, context);
        let expression = pop_item!(self, expression, Expression, context);
        let l_bracket = pop_item!(self, l_bracket, LBracket, context);
        let array_built = Array {
            l_bracket: Box::new(l_bracket),
            expression: Box::new(expression),
            array_list,
            r_bracket: Box::new(r_bracket),
        };
        // Calling user action here
        self.user_grammar.array(&array_built)?;
        self.push(ASTType::Array(array_built), context);
        Ok(())
    }

    /// Semantic action for production 435:
    ///
    /// ArrayList /* Vec<T>::Push */: Comma Expression ArrayList;
    ///
    #[parol_runtime::function_name::named]
    fn array_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _array_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut array_list = pop_item!(self, array_list, ArrayList, context);
        let expression = pop_item!(self, expression, Expression, context);
        let comma = pop_item!(self, comma, Comma, context);
        let array_list_0_built = ArrayList {
            expression: Box::new(expression),
            comma: Box::new(comma),
        };
        // Add an element to the vector
        array_list.push(array_list_0_built);
        self.push(ASTType::ArrayList(array_list), context);
        Ok(())
    }

    /// Semantic action for production 436:
    ///
    /// ArrayList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn array_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_list_1_built = Vec::new();
        self.push(ASTType::ArrayList(array_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 437:
    ///
    /// Range: Expression RangeOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn range(
        &mut self,
        _expression: &ParseTreeType<'t>,
        _range_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let range_opt = pop_item!(self, range_opt, RangeOpt, context);
        let expression = pop_item!(self, expression, Expression, context);
        let range_built = Range {
            expression: Box::new(expression),
            range_opt,
        };
        // Calling user action here
        self.user_grammar.range(&range_built)?;
        self.push(ASTType::Range(range_built), context);
        Ok(())
    }

    /// Semantic action for production 438:
    ///
    /// RangeOpt /* Option<T>::Some */: RangeOperator Expression;
    ///
    #[parol_runtime::function_name::named]
    fn range_opt_0(
        &mut self,
        _range_operator: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let range_operator = pop_item!(self, range_operator, RangeOperator, context);
        let range_opt_0_built = RangeOpt {
            range_operator: Box::new(range_operator),
            expression: Box::new(expression),
        };
        self.push(
            ASTType::RangeOpt(Some(Box::new(range_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 439:
    ///
    /// RangeOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn range_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::RangeOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 440:
    ///
    /// RangeOperator: DotDot;
    ///
    #[parol_runtime::function_name::named]
    fn range_operator_0(&mut self, _dot_dot: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_dot = pop_item!(self, dot_dot, DotDot, context);
        let range_operator_0_built = RangeOperatorDotDot {
            dot_dot: Box::new(dot_dot),
        };
        let range_operator_0_built = RangeOperator::DotDot(range_operator_0_built);
        // Calling user action here
        self.user_grammar.range_operator(&range_operator_0_built)?;
        self.push(ASTType::RangeOperator(range_operator_0_built), context);
        Ok(())
    }

    /// Semantic action for production 441:
    ///
    /// RangeOperator: DotDotEqu;
    ///
    #[parol_runtime::function_name::named]
    fn range_operator_1(&mut self, _dot_dot_equ: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_dot_equ = pop_item!(self, dot_dot_equ, DotDotEqu, context);
        let range_operator_1_built = RangeOperatorDotDotEqu {
            dot_dot_equ: Box::new(dot_dot_equ),
        };
        let range_operator_1_built = RangeOperator::DotDotEqu(range_operator_1_built);
        // Calling user action here
        self.user_grammar.range_operator(&range_operator_1_built)?;
        self.push(ASTType::RangeOperator(range_operator_1_built), context);
        Ok(())
    }

    /// Semantic action for production 442:
    ///
    /// FixedType: U32;
    ///
    #[parol_runtime::function_name::named]
    fn fixed_type_0(&mut self, _u32: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u32 = pop_item!(self, u32, U32, context);
        let fixed_type_0_built = FixedTypeU32 { u32: Box::new(u32) };
        let fixed_type_0_built = FixedType::U32(fixed_type_0_built);
        // Calling user action here
        self.user_grammar.fixed_type(&fixed_type_0_built)?;
        self.push(ASTType::FixedType(fixed_type_0_built), context);
        Ok(())
    }

    /// Semantic action for production 443:
    ///
    /// FixedType: U64;
    ///
    #[parol_runtime::function_name::named]
    fn fixed_type_1(&mut self, _u64: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u64 = pop_item!(self, u64, U64, context);
        let fixed_type_1_built = FixedTypeU64 { u64: Box::new(u64) };
        let fixed_type_1_built = FixedType::U64(fixed_type_1_built);
        // Calling user action here
        self.user_grammar.fixed_type(&fixed_type_1_built)?;
        self.push(ASTType::FixedType(fixed_type_1_built), context);
        Ok(())
    }

    /// Semantic action for production 444:
    ///
    /// FixedType: I32;
    ///
    #[parol_runtime::function_name::named]
    fn fixed_type_2(&mut self, _i32: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i32 = pop_item!(self, i32, I32, context);
        let fixed_type_2_built = FixedTypeI32 { i32: Box::new(i32) };
        let fixed_type_2_built = FixedType::I32(fixed_type_2_built);
        // Calling user action here
        self.user_grammar.fixed_type(&fixed_type_2_built)?;
        self.push(ASTType::FixedType(fixed_type_2_built), context);
        Ok(())
    }

    /// Semantic action for production 445:
    ///
    /// FixedType: I64;
    ///
    #[parol_runtime::function_name::named]
    fn fixed_type_3(&mut self, _i64: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i64 = pop_item!(self, i64, I64, context);
        let fixed_type_3_built = FixedTypeI64 { i64: Box::new(i64) };
        let fixed_type_3_built = FixedType::I64(fixed_type_3_built);
        // Calling user action here
        self.user_grammar.fixed_type(&fixed_type_3_built)?;
        self.push(ASTType::FixedType(fixed_type_3_built), context);
        Ok(())
    }

    /// Semantic action for production 446:
    ///
    /// FixedType: F32;
    ///
    #[parol_runtime::function_name::named]
    fn fixed_type_4(&mut self, _f32: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f32 = pop_item!(self, f32, F32, context);
        let fixed_type_4_built = FixedTypeF32 { f32: Box::new(f32) };
        let fixed_type_4_built = FixedType::F32(fixed_type_4_built);
        // Calling user action here
        self.user_grammar.fixed_type(&fixed_type_4_built)?;
        self.push(ASTType::FixedType(fixed_type_4_built), context);
        Ok(())
    }

    /// Semantic action for production 447:
    ///
    /// FixedType: F64;
    ///
    #[parol_runtime::function_name::named]
    fn fixed_type_5(&mut self, _f64: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f64 = pop_item!(self, f64, F64, context);
        let fixed_type_5_built = FixedTypeF64 { f64: Box::new(f64) };
        let fixed_type_5_built = FixedType::F64(fixed_type_5_built);
        // Calling user action here
        self.user_grammar.fixed_type(&fixed_type_5_built)?;
        self.push(ASTType::FixedType(fixed_type_5_built), context);
        Ok(())
    }

    /// Semantic action for production 448:
    ///
    /// FixedType: Strin;
    ///
    #[parol_runtime::function_name::named]
    fn fixed_type_6(&mut self, _strin: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let strin = pop_item!(self, strin, Strin, context);
        let fixed_type_6_built = FixedTypeStrin {
            strin: Box::new(strin),
        };
        let fixed_type_6_built = FixedType::Strin(fixed_type_6_built);
        // Calling user action here
        self.user_grammar.fixed_type(&fixed_type_6_built)?;
        self.push(ASTType::FixedType(fixed_type_6_built), context);
        Ok(())
    }

    /// Semantic action for production 449:
    ///
    /// VariableType: VariableTypeGroup VariableTypeOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn variable_type(
        &mut self,
        _variable_type_group: &ParseTreeType<'t>,
        _variable_type_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let variable_type_opt = pop_item!(self, variable_type_opt, VariableTypeOpt, context);
        let variable_type_group = pop_item!(self, variable_type_group, VariableTypeGroup, context);
        let variable_type_built = VariableType {
            variable_type_group: Box::new(variable_type_group),
            variable_type_opt,
        };
        // Calling user action here
        self.user_grammar.variable_type(&variable_type_built)?;
        self.push(ASTType::VariableType(variable_type_built), context);
        Ok(())
    }

    /// Semantic action for production 450:
    ///
    /// VariableTypeGroup: Logic;
    ///
    #[parol_runtime::function_name::named]
    fn variable_type_group_0(&mut self, _logic: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logic = pop_item!(self, logic, Logic, context);
        let variable_type_group_0_built = VariableTypeGroupLogic {
            logic: Box::new(logic),
        };
        let variable_type_group_0_built = VariableTypeGroup::Logic(variable_type_group_0_built);
        self.push(
            ASTType::VariableTypeGroup(variable_type_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 451:
    ///
    /// VariableTypeGroup: Bit;
    ///
    #[parol_runtime::function_name::named]
    fn variable_type_group_1(&mut self, _bit: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bit = pop_item!(self, bit, Bit, context);
        let variable_type_group_1_built = VariableTypeGroupBit { bit: Box::new(bit) };
        let variable_type_group_1_built = VariableTypeGroup::Bit(variable_type_group_1_built);
        self.push(
            ASTType::VariableTypeGroup(variable_type_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 452:
    ///
    /// VariableTypeGroup: ScopedIdentifier;
    ///
    #[parol_runtime::function_name::named]
    fn variable_type_group_2(&mut self, _scoped_identifier: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scoped_identifier = pop_item!(self, scoped_identifier, ScopedIdentifier, context);
        let variable_type_group_2_built = VariableTypeGroupScopedIdentifier {
            scoped_identifier: Box::new(scoped_identifier),
        };
        let variable_type_group_2_built =
            VariableTypeGroup::ScopedIdentifier(variable_type_group_2_built);
        self.push(
            ASTType::VariableTypeGroup(variable_type_group_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 453:
    ///
    /// VariableTypeOpt /* Option<T>::Some */: Width;
    ///
    #[parol_runtime::function_name::named]
    fn variable_type_opt_0(&mut self, _width: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let width = pop_item!(self, width, Width, context);
        let variable_type_opt_0_built = VariableTypeOpt {
            width: Box::new(width),
        };
        self.push(
            ASTType::VariableTypeOpt(Some(Box::new(variable_type_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 454:
    ///
    /// VariableTypeOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn variable_type_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::VariableTypeOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 455:
    ///
    /// TypeModifier: Tri;
    ///
    #[parol_runtime::function_name::named]
    fn type_modifier_0(&mut self, _tri: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tri = pop_item!(self, tri, Tri, context);
        let type_modifier_0_built = TypeModifierTri { tri: Box::new(tri) };
        let type_modifier_0_built = TypeModifier::Tri(type_modifier_0_built);
        // Calling user action here
        self.user_grammar.type_modifier(&type_modifier_0_built)?;
        self.push(ASTType::TypeModifier(type_modifier_0_built), context);
        Ok(())
    }

    /// Semantic action for production 456:
    ///
    /// TypeModifier: Signed;
    ///
    #[parol_runtime::function_name::named]
    fn type_modifier_1(&mut self, _signed: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let signed = pop_item!(self, signed, Signed, context);
        let type_modifier_1_built = TypeModifierSigned {
            signed: Box::new(signed),
        };
        let type_modifier_1_built = TypeModifier::Signed(type_modifier_1_built);
        // Calling user action here
        self.user_grammar.type_modifier(&type_modifier_1_built)?;
        self.push(ASTType::TypeModifier(type_modifier_1_built), context);
        Ok(())
    }

    /// Semantic action for production 457:
    ///
    /// ScalarType: ScalarTypeList /* Vec */ ScalarTypeGroup;
    ///
    #[parol_runtime::function_name::named]
    fn scalar_type(
        &mut self,
        _scalar_type_list: &ParseTreeType<'t>,
        _scalar_type_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scalar_type_group = pop_item!(self, scalar_type_group, ScalarTypeGroup, context);
        let scalar_type_list =
            pop_and_reverse_item!(self, scalar_type_list, ScalarTypeList, context);
        let scalar_type_built = ScalarType {
            scalar_type_list,
            scalar_type_group: Box::new(scalar_type_group),
        };
        // Calling user action here
        self.user_grammar.scalar_type(&scalar_type_built)?;
        self.push(ASTType::ScalarType(scalar_type_built), context);
        Ok(())
    }

    /// Semantic action for production 458:
    ///
    /// ScalarTypeGroup: VariableType;
    ///
    #[parol_runtime::function_name::named]
    fn scalar_type_group_0(&mut self, _variable_type: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let variable_type = pop_item!(self, variable_type, VariableType, context);
        let scalar_type_group_0_built = ScalarTypeGroupVariableType {
            variable_type: Box::new(variable_type),
        };
        let scalar_type_group_0_built = ScalarTypeGroup::VariableType(scalar_type_group_0_built);
        self.push(ASTType::ScalarTypeGroup(scalar_type_group_0_built), context);
        Ok(())
    }

    /// Semantic action for production 459:
    ///
    /// ScalarTypeGroup: FixedType;
    ///
    #[parol_runtime::function_name::named]
    fn scalar_type_group_1(&mut self, _fixed_type: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let fixed_type = pop_item!(self, fixed_type, FixedType, context);
        let scalar_type_group_1_built = ScalarTypeGroupFixedType {
            fixed_type: Box::new(fixed_type),
        };
        let scalar_type_group_1_built = ScalarTypeGroup::FixedType(scalar_type_group_1_built);
        self.push(ASTType::ScalarTypeGroup(scalar_type_group_1_built), context);
        Ok(())
    }

    /// Semantic action for production 460:
    ///
    /// ScalarTypeList /* Vec<T>::Push */: TypeModifier ScalarTypeList;
    ///
    #[parol_runtime::function_name::named]
    fn scalar_type_list_0(
        &mut self,
        _type_modifier: &ParseTreeType<'t>,
        _scalar_type_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut scalar_type_list = pop_item!(self, scalar_type_list, ScalarTypeList, context);
        let type_modifier = pop_item!(self, type_modifier, TypeModifier, context);
        let scalar_type_list_0_built = ScalarTypeList {
            type_modifier: Box::new(type_modifier),
        };
        // Add an element to the vector
        scalar_type_list.push(scalar_type_list_0_built);
        self.push(ASTType::ScalarTypeList(scalar_type_list), context);
        Ok(())
    }

    /// Semantic action for production 461:
    ///
    /// ScalarTypeList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn scalar_type_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scalar_type_list_1_built = Vec::new();
        self.push(ASTType::ScalarTypeList(scalar_type_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 462:
    ///
    /// ArrayType: ScalarType ArrayTypeOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn array_type(
        &mut self,
        _scalar_type: &ParseTreeType<'t>,
        _array_type_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_type_opt = pop_item!(self, array_type_opt, ArrayTypeOpt, context);
        let scalar_type = pop_item!(self, scalar_type, ScalarType, context);
        let array_type_built = ArrayType {
            scalar_type: Box::new(scalar_type),
            array_type_opt,
        };
        // Calling user action here
        self.user_grammar.array_type(&array_type_built)?;
        self.push(ASTType::ArrayType(array_type_built), context);
        Ok(())
    }

    /// Semantic action for production 463:
    ///
    /// ArrayTypeOpt /* Option<T>::Some */: Array;
    ///
    #[parol_runtime::function_name::named]
    fn array_type_opt_0(&mut self, _array: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array = pop_item!(self, array, Array, context);
        let array_type_opt_0_built = ArrayTypeOpt {
            array: Box::new(array),
        };
        self.push(
            ASTType::ArrayTypeOpt(Some(Box::new(array_type_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 464:
    ///
    /// ArrayTypeOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn array_type_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ArrayTypeOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 465:
    ///
    /// Statement: IdentifierStatement;
    ///
    #[parol_runtime::function_name::named]
    fn statement_0(&mut self, _identifier_statement: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier_statement =
            pop_item!(self, identifier_statement, IdentifierStatement, context);
        let statement_0_built = StatementIdentifierStatement {
            identifier_statement: Box::new(identifier_statement),
        };
        let statement_0_built = Statement::IdentifierStatement(statement_0_built);
        // Calling user action here
        self.user_grammar.statement(&statement_0_built)?;
        self.push(ASTType::Statement(statement_0_built), context);
        Ok(())
    }

    /// Semantic action for production 466:
    ///
    /// Statement: IfStatement;
    ///
    #[parol_runtime::function_name::named]
    fn statement_1(&mut self, _if_statement: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_statement = pop_item!(self, if_statement, IfStatement, context);
        let statement_1_built = StatementIfStatement {
            if_statement: Box::new(if_statement),
        };
        let statement_1_built = Statement::IfStatement(statement_1_built);
        // Calling user action here
        self.user_grammar.statement(&statement_1_built)?;
        self.push(ASTType::Statement(statement_1_built), context);
        Ok(())
    }

    /// Semantic action for production 467:
    ///
    /// Statement: IfResetStatement;
    ///
    #[parol_runtime::function_name::named]
    fn statement_2(&mut self, _if_reset_statement: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_reset_statement = pop_item!(self, if_reset_statement, IfResetStatement, context);
        let statement_2_built = StatementIfResetStatement {
            if_reset_statement: Box::new(if_reset_statement),
        };
        let statement_2_built = Statement::IfResetStatement(statement_2_built);
        // Calling user action here
        self.user_grammar.statement(&statement_2_built)?;
        self.push(ASTType::Statement(statement_2_built), context);
        Ok(())
    }

    /// Semantic action for production 468:
    ///
    /// Statement: ReturnStatement;
    ///
    #[parol_runtime::function_name::named]
    fn statement_3(&mut self, _return_statement: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let return_statement = pop_item!(self, return_statement, ReturnStatement, context);
        let statement_3_built = StatementReturnStatement {
            return_statement: Box::new(return_statement),
        };
        let statement_3_built = Statement::ReturnStatement(statement_3_built);
        // Calling user action here
        self.user_grammar.statement(&statement_3_built)?;
        self.push(ASTType::Statement(statement_3_built), context);
        Ok(())
    }

    /// Semantic action for production 469:
    ///
    /// Statement: ForStatement;
    ///
    #[parol_runtime::function_name::named]
    fn statement_4(&mut self, _for_statement: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let for_statement = pop_item!(self, for_statement, ForStatement, context);
        let statement_4_built = StatementForStatement {
            for_statement: Box::new(for_statement),
        };
        let statement_4_built = Statement::ForStatement(statement_4_built);
        // Calling user action here
        self.user_grammar.statement(&statement_4_built)?;
        self.push(ASTType::Statement(statement_4_built), context);
        Ok(())
    }

    /// Semantic action for production 470:
    ///
    /// Statement: CaseStatement;
    ///
    #[parol_runtime::function_name::named]
    fn statement_5(&mut self, _case_statement: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let case_statement = pop_item!(self, case_statement, CaseStatement, context);
        let statement_5_built = StatementCaseStatement {
            case_statement: Box::new(case_statement),
        };
        let statement_5_built = Statement::CaseStatement(statement_5_built);
        // Calling user action here
        self.user_grammar.statement(&statement_5_built)?;
        self.push(ASTType::Statement(statement_5_built), context);
        Ok(())
    }

    /// Semantic action for production 471:
    ///
    /// IdentifierStatement: ExpressionIdentifier IdentifierStatementGroup Semicolon;
    ///
    #[parol_runtime::function_name::named]
    fn identifier_statement(
        &mut self,
        _expression_identifier: &ParseTreeType<'t>,
        _identifier_statement_group: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let identifier_statement_group = pop_item!(
            self,
            identifier_statement_group,
            IdentifierStatementGroup,
            context
        );
        let expression_identifier =
            pop_item!(self, expression_identifier, ExpressionIdentifier, context);
        let identifier_statement_built = IdentifierStatement {
            expression_identifier: Box::new(expression_identifier),
            identifier_statement_group: Box::new(identifier_statement_group),
            semicolon: Box::new(semicolon),
        };
        // Calling user action here
        self.user_grammar
            .identifier_statement(&identifier_statement_built)?;
        self.push(
            ASTType::IdentifierStatement(identifier_statement_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 472:
    ///
    /// IdentifierStatementGroup: FunctionCall;
    ///
    #[parol_runtime::function_name::named]
    fn identifier_statement_group_0(&mut self, _function_call: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_call = pop_item!(self, function_call, FunctionCall, context);
        let identifier_statement_group_0_built = IdentifierStatementGroupFunctionCall {
            function_call: Box::new(function_call),
        };
        let identifier_statement_group_0_built =
            IdentifierStatementGroup::FunctionCall(identifier_statement_group_0_built);
        self.push(
            ASTType::IdentifierStatementGroup(identifier_statement_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 473:
    ///
    /// IdentifierStatementGroup: Assignment;
    ///
    #[parol_runtime::function_name::named]
    fn identifier_statement_group_1(&mut self, _assignment: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assignment = pop_item!(self, assignment, Assignment, context);
        let identifier_statement_group_1_built = IdentifierStatementGroupAssignment {
            assignment: Box::new(assignment),
        };
        let identifier_statement_group_1_built =
            IdentifierStatementGroup::Assignment(identifier_statement_group_1_built);
        self.push(
            ASTType::IdentifierStatementGroup(identifier_statement_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 474:
    ///
    /// Assignment: AssignmentGroup Expression;
    ///
    #[parol_runtime::function_name::named]
    fn assignment(
        &mut self,
        _assignment_group: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let assignment_group = pop_item!(self, assignment_group, AssignmentGroup, context);
        let assignment_built = Assignment {
            assignment_group: Box::new(assignment_group),
            expression: Box::new(expression),
        };
        // Calling user action here
        self.user_grammar.assignment(&assignment_built)?;
        self.push(ASTType::Assignment(assignment_built), context);
        Ok(())
    }

    /// Semantic action for production 475:
    ///
    /// AssignmentGroup: Equ;
    ///
    #[parol_runtime::function_name::named]
    fn assignment_group_0(&mut self, _equ: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equ = pop_item!(self, equ, Equ, context);
        let assignment_group_0_built = AssignmentGroupEqu { equ: Box::new(equ) };
        let assignment_group_0_built = AssignmentGroup::Equ(assignment_group_0_built);
        self.push(ASTType::AssignmentGroup(assignment_group_0_built), context);
        Ok(())
    }

    /// Semantic action for production 476:
    ///
    /// AssignmentGroup: AssignmentOperator;
    ///
    #[parol_runtime::function_name::named]
    fn assignment_group_1(&mut self, _assignment_operator: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assignment_operator = pop_item!(self, assignment_operator, AssignmentOperator, context);
        let assignment_group_1_built = AssignmentGroupAssignmentOperator {
            assignment_operator: Box::new(assignment_operator),
        };
        let assignment_group_1_built =
            AssignmentGroup::AssignmentOperator(assignment_group_1_built);
        self.push(ASTType::AssignmentGroup(assignment_group_1_built), context);
        Ok(())
    }

    /// Semantic action for production 477:
    ///
    /// IfStatement: If Expression LBrace IfStatementList /* Vec */ RBrace IfStatementList0 /* Vec */ IfStatementOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement(
        &mut self,
        _if: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _if_statement_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
        _if_statement_list0: &ParseTreeType<'t>,
        _if_statement_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_statement_opt = pop_item!(self, if_statement_opt, IfStatementOpt, context);
        let if_statement_list0 =
            pop_and_reverse_item!(self, if_statement_list0, IfStatementList0, context);
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let if_statement_list =
            pop_and_reverse_item!(self, if_statement_list, IfStatementList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let expression = pop_item!(self, expression, Expression, context);
        let r#if = pop_item!(self, r#if, If, context);
        let if_statement_built = IfStatement {
            r#if: Box::new(r#if),
            expression: Box::new(expression),
            l_brace: Box::new(l_brace),
            if_statement_list,
            r_brace: Box::new(r_brace),
            if_statement_list0,
            if_statement_opt,
        };
        // Calling user action here
        self.user_grammar.if_statement(&if_statement_built)?;
        self.push(ASTType::IfStatement(if_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 478:
    ///
    /// IfStatementList0 /* Vec<T>::Push */: Else If Expression LBrace IfStatementList0List /* Vec */ RBrace IfStatementList0;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_list0_0(
        &mut self,
        _else: &ParseTreeType<'t>,
        _if: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _if_statement_list0_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
        _if_statement_list0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut if_statement_list0 = pop_item!(self, if_statement_list0, IfStatementList0, context);
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let if_statement_list0_list =
            pop_and_reverse_item!(self, if_statement_list0_list, IfStatementList0List, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let expression = pop_item!(self, expression, Expression, context);
        let r#if = pop_item!(self, r#if, If, context);
        let r#else = pop_item!(self, r#else, Else, context);
        let if_statement_list0_0_built = IfStatementList0 {
            r_brace: Box::new(r_brace),
            if_statement_list0_list,
            l_brace: Box::new(l_brace),
            expression: Box::new(expression),
            r#if: Box::new(r#if),
            r#else: Box::new(r#else),
        };
        // Add an element to the vector
        if_statement_list0.push(if_statement_list0_0_built);
        self.push(ASTType::IfStatementList0(if_statement_list0), context);
        Ok(())
    }

    /// Semantic action for production 479:
    ///
    /// IfStatementList0List /* Vec<T>::Push */: Statement IfStatementList0List;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_list0_list_0(
        &mut self,
        _statement: &ParseTreeType<'t>,
        _if_statement_list0_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut if_statement_list0_list =
            pop_item!(self, if_statement_list0_list, IfStatementList0List, context);
        let statement = pop_item!(self, statement, Statement, context);
        let if_statement_list0_list_0_built = IfStatementList0List {
            statement: Box::new(statement),
        };
        // Add an element to the vector
        if_statement_list0_list.push(if_statement_list0_list_0_built);
        self.push(
            ASTType::IfStatementList0List(if_statement_list0_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 480:
    ///
    /// IfStatementList0List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_list0_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_statement_list0_list_1_built = Vec::new();
        self.push(
            ASTType::IfStatementList0List(if_statement_list0_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 481:
    ///
    /// IfStatementList0 /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_list0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_statement_list0_1_built = Vec::new();
        self.push(
            ASTType::IfStatementList0(if_statement_list0_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 482:
    ///
    /// IfStatementList /* Vec<T>::Push */: Statement IfStatementList;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_list_0(
        &mut self,
        _statement: &ParseTreeType<'t>,
        _if_statement_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut if_statement_list = pop_item!(self, if_statement_list, IfStatementList, context);
        let statement = pop_item!(self, statement, Statement, context);
        let if_statement_list_0_built = IfStatementList {
            statement: Box::new(statement),
        };
        // Add an element to the vector
        if_statement_list.push(if_statement_list_0_built);
        self.push(ASTType::IfStatementList(if_statement_list), context);
        Ok(())
    }

    /// Semantic action for production 483:
    ///
    /// IfStatementList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_statement_list_1_built = Vec::new();
        self.push(ASTType::IfStatementList(if_statement_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 484:
    ///
    /// IfStatementOpt /* Option<T>::Some */: Else LBrace IfStatementOptList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_opt_0(
        &mut self,
        _else: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _if_statement_opt_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let if_statement_opt_list =
            pop_and_reverse_item!(self, if_statement_opt_list, IfStatementOptList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let r#else = pop_item!(self, r#else, Else, context);
        let if_statement_opt_0_built = IfStatementOpt {
            r#else: Box::new(r#else),
            l_brace: Box::new(l_brace),
            if_statement_opt_list,
            r_brace: Box::new(r_brace),
        };
        self.push(
            ASTType::IfStatementOpt(Some(Box::new(if_statement_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 485:
    ///
    /// IfStatementOptList /* Vec<T>::Push */: Statement IfStatementOptList;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_opt_list_0(
        &mut self,
        _statement: &ParseTreeType<'t>,
        _if_statement_opt_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut if_statement_opt_list =
            pop_item!(self, if_statement_opt_list, IfStatementOptList, context);
        let statement = pop_item!(self, statement, Statement, context);
        let if_statement_opt_list_0_built = IfStatementOptList {
            statement: Box::new(statement),
        };
        // Add an element to the vector
        if_statement_opt_list.push(if_statement_opt_list_0_built);
        self.push(ASTType::IfStatementOptList(if_statement_opt_list), context);
        Ok(())
    }

    /// Semantic action for production 486:
    ///
    /// IfStatementOptList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_opt_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_statement_opt_list_1_built = Vec::new();
        self.push(
            ASTType::IfStatementOptList(if_statement_opt_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 487:
    ///
    /// IfStatementOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::IfStatementOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 488:
    ///
    /// IfResetStatement: IfReset LBrace IfResetStatementList /* Vec */ RBrace IfResetStatementList0 /* Vec */ IfResetStatementOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn if_reset_statement(
        &mut self,
        _if_reset: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _if_reset_statement_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
        _if_reset_statement_list0: &ParseTreeType<'t>,
        _if_reset_statement_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_reset_statement_opt =
            pop_item!(self, if_reset_statement_opt, IfResetStatementOpt, context);
        let if_reset_statement_list0 = pop_and_reverse_item!(
            self,
            if_reset_statement_list0,
            IfResetStatementList0,
            context
        );
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let if_reset_statement_list =
            pop_and_reverse_item!(self, if_reset_statement_list, IfResetStatementList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let if_reset = pop_item!(self, if_reset, IfReset, context);
        let if_reset_statement_built = IfResetStatement {
            if_reset: Box::new(if_reset),
            l_brace: Box::new(l_brace),
            if_reset_statement_list,
            r_brace: Box::new(r_brace),
            if_reset_statement_list0,
            if_reset_statement_opt,
        };
        // Calling user action here
        self.user_grammar
            .if_reset_statement(&if_reset_statement_built)?;
        self.push(ASTType::IfResetStatement(if_reset_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 489:
    ///
    /// IfResetStatementList0 /* Vec<T>::Push */: Else If Expression LBrace IfResetStatementList0List /* Vec */ RBrace IfResetStatementList0;
    ///
    #[parol_runtime::function_name::named]
    fn if_reset_statement_list0_0(
        &mut self,
        _else: &ParseTreeType<'t>,
        _if: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _if_reset_statement_list0_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
        _if_reset_statement_list0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut if_reset_statement_list0 = pop_item!(
            self,
            if_reset_statement_list0,
            IfResetStatementList0,
            context
        );
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let if_reset_statement_list0_list = pop_and_reverse_item!(
            self,
            if_reset_statement_list0_list,
            IfResetStatementList0List,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let expression = pop_item!(self, expression, Expression, context);
        let r#if = pop_item!(self, r#if, If, context);
        let r#else = pop_item!(self, r#else, Else, context);
        let if_reset_statement_list0_0_built = IfResetStatementList0 {
            r_brace: Box::new(r_brace),
            if_reset_statement_list0_list,
            l_brace: Box::new(l_brace),
            expression: Box::new(expression),
            r#if: Box::new(r#if),
            r#else: Box::new(r#else),
        };
        // Add an element to the vector
        if_reset_statement_list0.push(if_reset_statement_list0_0_built);
        self.push(
            ASTType::IfResetStatementList0(if_reset_statement_list0),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 490:
    ///
    /// IfResetStatementList0List /* Vec<T>::Push */: Statement IfResetStatementList0List;
    ///
    #[parol_runtime::function_name::named]
    fn if_reset_statement_list0_list_0(
        &mut self,
        _statement: &ParseTreeType<'t>,
        _if_reset_statement_list0_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut if_reset_statement_list0_list = pop_item!(
            self,
            if_reset_statement_list0_list,
            IfResetStatementList0List,
            context
        );
        let statement = pop_item!(self, statement, Statement, context);
        let if_reset_statement_list0_list_0_built = IfResetStatementList0List {
            statement: Box::new(statement),
        };
        // Add an element to the vector
        if_reset_statement_list0_list.push(if_reset_statement_list0_list_0_built);
        self.push(
            ASTType::IfResetStatementList0List(if_reset_statement_list0_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 491:
    ///
    /// IfResetStatementList0List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn if_reset_statement_list0_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_reset_statement_list0_list_1_built = Vec::new();
        self.push(
            ASTType::IfResetStatementList0List(if_reset_statement_list0_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 492:
    ///
    /// IfResetStatementList0 /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn if_reset_statement_list0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_reset_statement_list0_1_built = Vec::new();
        self.push(
            ASTType::IfResetStatementList0(if_reset_statement_list0_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 493:
    ///
    /// IfResetStatementList /* Vec<T>::Push */: Statement IfResetStatementList;
    ///
    #[parol_runtime::function_name::named]
    fn if_reset_statement_list_0(
        &mut self,
        _statement: &ParseTreeType<'t>,
        _if_reset_statement_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut if_reset_statement_list =
            pop_item!(self, if_reset_statement_list, IfResetStatementList, context);
        let statement = pop_item!(self, statement, Statement, context);
        let if_reset_statement_list_0_built = IfResetStatementList {
            statement: Box::new(statement),
        };
        // Add an element to the vector
        if_reset_statement_list.push(if_reset_statement_list_0_built);
        self.push(
            ASTType::IfResetStatementList(if_reset_statement_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 494:
    ///
    /// IfResetStatementList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn if_reset_statement_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_reset_statement_list_1_built = Vec::new();
        self.push(
            ASTType::IfResetStatementList(if_reset_statement_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 495:
    ///
    /// IfResetStatementOpt /* Option<T>::Some */: Else LBrace IfResetStatementOptList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn if_reset_statement_opt_0(
        &mut self,
        _else: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _if_reset_statement_opt_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let if_reset_statement_opt_list = pop_and_reverse_item!(
            self,
            if_reset_statement_opt_list,
            IfResetStatementOptList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let r#else = pop_item!(self, r#else, Else, context);
        let if_reset_statement_opt_0_built = IfResetStatementOpt {
            r#else: Box::new(r#else),
            l_brace: Box::new(l_brace),
            if_reset_statement_opt_list,
            r_brace: Box::new(r_brace),
        };
        self.push(
            ASTType::IfResetStatementOpt(Some(Box::new(if_reset_statement_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 496:
    ///
    /// IfResetStatementOptList /* Vec<T>::Push */: Statement IfResetStatementOptList;
    ///
    #[parol_runtime::function_name::named]
    fn if_reset_statement_opt_list_0(
        &mut self,
        _statement: &ParseTreeType<'t>,
        _if_reset_statement_opt_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut if_reset_statement_opt_list = pop_item!(
            self,
            if_reset_statement_opt_list,
            IfResetStatementOptList,
            context
        );
        let statement = pop_item!(self, statement, Statement, context);
        let if_reset_statement_opt_list_0_built = IfResetStatementOptList {
            statement: Box::new(statement),
        };
        // Add an element to the vector
        if_reset_statement_opt_list.push(if_reset_statement_opt_list_0_built);
        self.push(
            ASTType::IfResetStatementOptList(if_reset_statement_opt_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 497:
    ///
    /// IfResetStatementOptList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn if_reset_statement_opt_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_reset_statement_opt_list_1_built = Vec::new();
        self.push(
            ASTType::IfResetStatementOptList(if_reset_statement_opt_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 498:
    ///
    /// IfResetStatementOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn if_reset_statement_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::IfResetStatementOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 499:
    ///
    /// ReturnStatement: Return Expression Semicolon;
    ///
    #[parol_runtime::function_name::named]
    fn return_statement(
        &mut self,
        _return: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let expression = pop_item!(self, expression, Expression, context);
        let r#return = pop_item!(self, r#return, Return, context);
        let return_statement_built = ReturnStatement {
            r#return: Box::new(r#return),
            expression: Box::new(expression),
            semicolon: Box::new(semicolon),
        };
        // Calling user action here
        self.user_grammar
            .return_statement(&return_statement_built)?;
        self.push(ASTType::ReturnStatement(return_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 500:
    ///
    /// ForStatement: For Identifier Colon ScalarType In Range ForStatementOpt /* Option */ LBrace ForStatementList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn for_statement(
        &mut self,
        _for: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _scalar_type: &ParseTreeType<'t>,
        _in: &ParseTreeType<'t>,
        _range: &ParseTreeType<'t>,
        _for_statement_opt: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _for_statement_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let for_statement_list =
            pop_and_reverse_item!(self, for_statement_list, ForStatementList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let for_statement_opt = pop_item!(self, for_statement_opt, ForStatementOpt, context);
        let range = pop_item!(self, range, Range, context);
        let r#in = pop_item!(self, r#in, In, context);
        let scalar_type = pop_item!(self, scalar_type, ScalarType, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let r#for = pop_item!(self, r#for, For, context);
        let for_statement_built = ForStatement {
            r#for: Box::new(r#for),
            identifier: Box::new(identifier),
            colon: Box::new(colon),
            scalar_type: Box::new(scalar_type),
            r#in: Box::new(r#in),
            range: Box::new(range),
            for_statement_opt,
            l_brace: Box::new(l_brace),
            for_statement_list,
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar.for_statement(&for_statement_built)?;
        self.push(ASTType::ForStatement(for_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 501:
    ///
    /// ForStatementList /* Vec<T>::Push */: Statement ForStatementList;
    ///
    #[parol_runtime::function_name::named]
    fn for_statement_list_0(
        &mut self,
        _statement: &ParseTreeType<'t>,
        _for_statement_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut for_statement_list = pop_item!(self, for_statement_list, ForStatementList, context);
        let statement = pop_item!(self, statement, Statement, context);
        let for_statement_list_0_built = ForStatementList {
            statement: Box::new(statement),
        };
        // Add an element to the vector
        for_statement_list.push(for_statement_list_0_built);
        self.push(ASTType::ForStatementList(for_statement_list), context);
        Ok(())
    }

    /// Semantic action for production 502:
    ///
    /// ForStatementList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn for_statement_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let for_statement_list_1_built = Vec::new();
        self.push(
            ASTType::ForStatementList(for_statement_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 503:
    ///
    /// ForStatementOpt /* Option<T>::Some */: Step AssignmentOperator Expression;
    ///
    #[parol_runtime::function_name::named]
    fn for_statement_opt_0(
        &mut self,
        _step: &ParseTreeType<'t>,
        _assignment_operator: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let assignment_operator = pop_item!(self, assignment_operator, AssignmentOperator, context);
        let step = pop_item!(self, step, Step, context);
        let for_statement_opt_0_built = ForStatementOpt {
            step: Box::new(step),
            assignment_operator: Box::new(assignment_operator),
            expression: Box::new(expression),
        };
        self.push(
            ASTType::ForStatementOpt(Some(Box::new(for_statement_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 504:
    ///
    /// ForStatementOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn for_statement_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ForStatementOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 505:
    ///
    /// CaseStatement: Case Expression LBrace CaseStatementList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn case_statement(
        &mut self,
        _case: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _case_statement_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let case_statement_list =
            pop_and_reverse_item!(self, case_statement_list, CaseStatementList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let expression = pop_item!(self, expression, Expression, context);
        let case = pop_item!(self, case, Case, context);
        let case_statement_built = CaseStatement {
            case: Box::new(case),
            expression: Box::new(expression),
            l_brace: Box::new(l_brace),
            case_statement_list,
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar.case_statement(&case_statement_built)?;
        self.push(ASTType::CaseStatement(case_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 506:
    ///
    /// CaseStatementList /* Vec<T>::Push */: CaseItem CaseStatementList;
    ///
    #[parol_runtime::function_name::named]
    fn case_statement_list_0(
        &mut self,
        _case_item: &ParseTreeType<'t>,
        _case_statement_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut case_statement_list =
            pop_item!(self, case_statement_list, CaseStatementList, context);
        let case_item = pop_item!(self, case_item, CaseItem, context);
        let case_statement_list_0_built = CaseStatementList {
            case_item: Box::new(case_item),
        };
        // Add an element to the vector
        case_statement_list.push(case_statement_list_0_built);
        self.push(ASTType::CaseStatementList(case_statement_list), context);
        Ok(())
    }

    /// Semantic action for production 507:
    ///
    /// CaseStatementList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn case_statement_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let case_statement_list_1_built = Vec::new();
        self.push(
            ASTType::CaseStatementList(case_statement_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 508:
    ///
    /// CaseItem: CaseItemGroup Colon CaseItemGroup0;
    ///
    #[parol_runtime::function_name::named]
    fn case_item(
        &mut self,
        _case_item_group: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _case_item_group0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let case_item_group0 = pop_item!(self, case_item_group0, CaseItemGroup0, context);
        let colon = pop_item!(self, colon, Colon, context);
        let case_item_group = pop_item!(self, case_item_group, CaseItemGroup, context);
        let case_item_built = CaseItem {
            case_item_group: Box::new(case_item_group),
            colon: Box::new(colon),
            case_item_group0: Box::new(case_item_group0),
        };
        // Calling user action here
        self.user_grammar.case_item(&case_item_built)?;
        self.push(ASTType::CaseItem(case_item_built), context);
        Ok(())
    }

    /// Semantic action for production 509:
    ///
    /// CaseItemGroup0: Statement;
    ///
    #[parol_runtime::function_name::named]
    fn case_item_group0_0(&mut self, _statement: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement = pop_item!(self, statement, Statement, context);
        let case_item_group0_0_built = CaseItemGroup0Statement {
            statement: Box::new(statement),
        };
        let case_item_group0_0_built = CaseItemGroup0::Statement(case_item_group0_0_built);
        self.push(ASTType::CaseItemGroup0(case_item_group0_0_built), context);
        Ok(())
    }

    /// Semantic action for production 510:
    ///
    /// CaseItemGroup0: LBrace CaseItemGroup0List /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn case_item_group0_1(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _case_item_group0_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let case_item_group0_list =
            pop_and_reverse_item!(self, case_item_group0_list, CaseItemGroup0List, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let case_item_group0_1_built = CaseItemGroup0LBraceCaseItemGroup0ListRBrace {
            l_brace: Box::new(l_brace),
            case_item_group0_list,
            r_brace: Box::new(r_brace),
        };
        let case_item_group0_1_built =
            CaseItemGroup0::LBraceCaseItemGroup0ListRBrace(case_item_group0_1_built);
        self.push(ASTType::CaseItemGroup0(case_item_group0_1_built), context);
        Ok(())
    }

    /// Semantic action for production 511:
    ///
    /// CaseItemGroup0List /* Vec<T>::Push */: Statement CaseItemGroup0List;
    ///
    #[parol_runtime::function_name::named]
    fn case_item_group0_list_0(
        &mut self,
        _statement: &ParseTreeType<'t>,
        _case_item_group0_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut case_item_group0_list =
            pop_item!(self, case_item_group0_list, CaseItemGroup0List, context);
        let statement = pop_item!(self, statement, Statement, context);
        let case_item_group0_list_0_built = CaseItemGroup0List {
            statement: Box::new(statement),
        };
        // Add an element to the vector
        case_item_group0_list.push(case_item_group0_list_0_built);
        self.push(ASTType::CaseItemGroup0List(case_item_group0_list), context);
        Ok(())
    }

    /// Semantic action for production 512:
    ///
    /// CaseItemGroup0List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn case_item_group0_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let case_item_group0_list_1_built = Vec::new();
        self.push(
            ASTType::CaseItemGroup0List(case_item_group0_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 513:
    ///
    /// CaseItemGroup: Expression;
    ///
    #[parol_runtime::function_name::named]
    fn case_item_group_0(&mut self, _expression: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let case_item_group_0_built = CaseItemGroupExpression {
            expression: Box::new(expression),
        };
        let case_item_group_0_built = CaseItemGroup::Expression(case_item_group_0_built);
        self.push(ASTType::CaseItemGroup(case_item_group_0_built), context);
        Ok(())
    }

    /// Semantic action for production 514:
    ///
    /// CaseItemGroup: Defaul;
    ///
    #[parol_runtime::function_name::named]
    fn case_item_group_1(&mut self, _defaul: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let defaul = pop_item!(self, defaul, Defaul, context);
        let case_item_group_1_built = CaseItemGroupDefaul {
            defaul: Box::new(defaul),
        };
        let case_item_group_1_built = CaseItemGroup::Defaul(case_item_group_1_built);
        self.push(ASTType::CaseItemGroup(case_item_group_1_built), context);
        Ok(())
    }

    /// Semantic action for production 515:
    ///
    /// Attribute: Hash LBracket Identifier AttributeOpt /* Option */ RBracket;
    ///
    #[parol_runtime::function_name::named]
    fn attribute(
        &mut self,
        _hash: &ParseTreeType<'t>,
        _l_bracket: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _attribute_opt: &ParseTreeType<'t>,
        _r_bracket: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_bracket = pop_item!(self, r_bracket, RBracket, context);
        let attribute_opt = pop_item!(self, attribute_opt, AttributeOpt, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let l_bracket = pop_item!(self, l_bracket, LBracket, context);
        let hash = pop_item!(self, hash, Hash, context);
        let attribute_built = Attribute {
            hash: Box::new(hash),
            l_bracket: Box::new(l_bracket),
            identifier: Box::new(identifier),
            attribute_opt,
            r_bracket: Box::new(r_bracket),
        };
        // Calling user action here
        self.user_grammar.attribute(&attribute_built)?;
        self.push(ASTType::Attribute(attribute_built), context);
        Ok(())
    }

    /// Semantic action for production 516:
    ///
    /// AttributeOpt /* Option<T>::Some */: LParen AttributeList RParen;
    ///
    #[parol_runtime::function_name::named]
    fn attribute_opt_0(
        &mut self,
        _l_paren: &ParseTreeType<'t>,
        _attribute_list: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let attribute_list = pop_item!(self, attribute_list, AttributeList, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let attribute_opt_0_built = AttributeOpt {
            l_paren: Box::new(l_paren),
            attribute_list: Box::new(attribute_list),
            r_paren: Box::new(r_paren),
        };
        self.push(
            ASTType::AttributeOpt(Some(Box::new(attribute_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 517:
    ///
    /// AttributeOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn attribute_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::AttributeOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 518:
    ///
    /// AttributeList: AttributeItem AttributeListList /* Vec */ AttributeListOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn attribute_list(
        &mut self,
        _attribute_item: &ParseTreeType<'t>,
        _attribute_list_list: &ParseTreeType<'t>,
        _attribute_list_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let attribute_list_opt = pop_item!(self, attribute_list_opt, AttributeListOpt, context);
        let attribute_list_list =
            pop_and_reverse_item!(self, attribute_list_list, AttributeListList, context);
        let attribute_item = pop_item!(self, attribute_item, AttributeItem, context);
        let attribute_list_built = AttributeList {
            attribute_item: Box::new(attribute_item),
            attribute_list_list,
            attribute_list_opt,
        };
        // Calling user action here
        self.user_grammar.attribute_list(&attribute_list_built)?;
        self.push(ASTType::AttributeList(attribute_list_built), context);
        Ok(())
    }

    /// Semantic action for production 519:
    ///
    /// AttributeListList /* Vec<T>::Push */: Comma AttributeItem AttributeListList;
    ///
    #[parol_runtime::function_name::named]
    fn attribute_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _attribute_item: &ParseTreeType<'t>,
        _attribute_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut attribute_list_list =
            pop_item!(self, attribute_list_list, AttributeListList, context);
        let attribute_item = pop_item!(self, attribute_item, AttributeItem, context);
        let comma = pop_item!(self, comma, Comma, context);
        let attribute_list_list_0_built = AttributeListList {
            attribute_item: Box::new(attribute_item),
            comma: Box::new(comma),
        };
        // Add an element to the vector
        attribute_list_list.push(attribute_list_list_0_built);
        self.push(ASTType::AttributeListList(attribute_list_list), context);
        Ok(())
    }

    /// Semantic action for production 520:
    ///
    /// AttributeListList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn attribute_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let attribute_list_list_1_built = Vec::new();
        self.push(
            ASTType::AttributeListList(attribute_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 521:
    ///
    /// AttributeListOpt /* Option<T>::Some */: Comma;
    ///
    #[parol_runtime::function_name::named]
    fn attribute_list_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let attribute_list_opt_0_built = AttributeListOpt {
            comma: Box::new(comma),
        };
        self.push(
            ASTType::AttributeListOpt(Some(Box::new(attribute_list_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 522:
    ///
    /// AttributeListOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn attribute_list_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::AttributeListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 523:
    ///
    /// AttributeItem: Identifier;
    ///
    #[parol_runtime::function_name::named]
    fn attribute_item_0(&mut self, _identifier: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier = pop_item!(self, identifier, Identifier, context);
        let attribute_item_0_built = AttributeItemIdentifier {
            identifier: Box::new(identifier),
        };
        let attribute_item_0_built = AttributeItem::Identifier(attribute_item_0_built);
        // Calling user action here
        self.user_grammar.attribute_item(&attribute_item_0_built)?;
        self.push(ASTType::AttributeItem(attribute_item_0_built), context);
        Ok(())
    }

    /// Semantic action for production 524:
    ///
    /// AttributeItem: StringLiteral;
    ///
    #[parol_runtime::function_name::named]
    fn attribute_item_1(&mut self, _string_literal: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string_literal = pop_item!(self, string_literal, StringLiteral, context);
        let attribute_item_1_built = AttributeItemStringLiteral {
            string_literal: Box::new(string_literal),
        };
        let attribute_item_1_built = AttributeItem::StringLiteral(attribute_item_1_built);
        // Calling user action here
        self.user_grammar.attribute_item(&attribute_item_1_built)?;
        self.push(ASTType::AttributeItem(attribute_item_1_built), context);
        Ok(())
    }

    /// Semantic action for production 525:
    ///
    /// VarDeclaration: Var Identifier Colon ArrayType VarDeclarationOpt /* Option */ Semicolon;
    ///
    #[parol_runtime::function_name::named]
    fn var_declaration(
        &mut self,
        _var: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _array_type: &ParseTreeType<'t>,
        _var_declaration_opt: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let var_declaration_opt = pop_item!(self, var_declaration_opt, VarDeclarationOpt, context);
        let array_type = pop_item!(self, array_type, ArrayType, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let var = pop_item!(self, var, Var, context);
        let var_declaration_built = VarDeclaration {
            var: Box::new(var),
            identifier: Box::new(identifier),
            colon: Box::new(colon),
            array_type: Box::new(array_type),
            var_declaration_opt,
            semicolon: Box::new(semicolon),
        };
        // Calling user action here
        self.user_grammar.var_declaration(&var_declaration_built)?;
        self.push(ASTType::VarDeclaration(var_declaration_built), context);
        Ok(())
    }

    /// Semantic action for production 526:
    ///
    /// VarDeclarationOpt /* Option<T>::Some */: Equ Expression;
    ///
    #[parol_runtime::function_name::named]
    fn var_declaration_opt_0(
        &mut self,
        _equ: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let equ = pop_item!(self, equ, Equ, context);
        let var_declaration_opt_0_built = VarDeclarationOpt {
            equ: Box::new(equ),
            expression: Box::new(expression),
        };
        self.push(
            ASTType::VarDeclarationOpt(Some(Box::new(var_declaration_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 527:
    ///
    /// VarDeclarationOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn var_declaration_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::VarDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 528:
    ///
    /// LocalparamDeclaration: Localparam Identifier Colon LocalparamDeclarationGroup Semicolon;
    ///
    #[parol_runtime::function_name::named]
    fn localparam_declaration(
        &mut self,
        _localparam: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _localparam_declaration_group: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let localparam_declaration_group = pop_item!(
            self,
            localparam_declaration_group,
            LocalparamDeclarationGroup,
            context
        );
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let localparam = pop_item!(self, localparam, Localparam, context);
        let localparam_declaration_built = LocalparamDeclaration {
            localparam: Box::new(localparam),
            identifier: Box::new(identifier),
            colon: Box::new(colon),
            localparam_declaration_group: Box::new(localparam_declaration_group),
            semicolon: Box::new(semicolon),
        };
        // Calling user action here
        self.user_grammar
            .localparam_declaration(&localparam_declaration_built)?;
        self.push(
            ASTType::LocalparamDeclaration(localparam_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 529:
    ///
    /// LocalparamDeclarationGroup: ArrayType Equ Expression;
    ///
    #[parol_runtime::function_name::named]
    fn localparam_declaration_group_0(
        &mut self,
        _array_type: &ParseTreeType<'t>,
        _equ: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let equ = pop_item!(self, equ, Equ, context);
        let array_type = pop_item!(self, array_type, ArrayType, context);
        let localparam_declaration_group_0_built =
            LocalparamDeclarationGroupArrayTypeEquExpression {
                array_type: Box::new(array_type),
                equ: Box::new(equ),
                expression: Box::new(expression),
            };
        let localparam_declaration_group_0_built =
            LocalparamDeclarationGroup::ArrayTypeEquExpression(
                localparam_declaration_group_0_built,
            );
        self.push(
            ASTType::LocalparamDeclarationGroup(localparam_declaration_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 530:
    ///
    /// LocalparamDeclarationGroup: Type Equ TypeExpression;
    ///
    #[parol_runtime::function_name::named]
    fn localparam_declaration_group_1(
        &mut self,
        _type: &ParseTreeType<'t>,
        _equ: &ParseTreeType<'t>,
        _type_expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_expression = pop_item!(self, type_expression, TypeExpression, context);
        let equ = pop_item!(self, equ, Equ, context);
        let r#type = pop_item!(self, r#type, Type, context);
        let localparam_declaration_group_1_built =
            LocalparamDeclarationGroupTypeEquTypeExpression {
                r#type: Box::new(r#type),
                equ: Box::new(equ),
                type_expression: Box::new(type_expression),
            };
        let localparam_declaration_group_1_built =
            LocalparamDeclarationGroup::TypeEquTypeExpression(localparam_declaration_group_1_built);
        self.push(
            ASTType::LocalparamDeclarationGroup(localparam_declaration_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 531:
    ///
    /// AlwaysFfDeclaration: AlwaysFf LParen AlwaysFfClock AlwaysFfDeclarationOpt /* Option */ RParen LBrace AlwaysFfDeclarationList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_declaration(
        &mut self,
        _always_ff: &ParseTreeType<'t>,
        _l_paren: &ParseTreeType<'t>,
        _always_ff_clock: &ParseTreeType<'t>,
        _always_ff_declaration_opt: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _always_ff_declaration_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let always_ff_declaration_list = pop_and_reverse_item!(
            self,
            always_ff_declaration_list,
            AlwaysFfDeclarationList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let always_ff_declaration_opt = pop_item!(
            self,
            always_ff_declaration_opt,
            AlwaysFfDeclarationOpt,
            context
        );
        let always_ff_clock = pop_item!(self, always_ff_clock, AlwaysFfClock, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let always_ff = pop_item!(self, always_ff, AlwaysFf, context);
        let always_ff_declaration_built = AlwaysFfDeclaration {
            always_ff: Box::new(always_ff),
            l_paren: Box::new(l_paren),
            always_ff_clock: Box::new(always_ff_clock),
            always_ff_declaration_opt,
            r_paren: Box::new(r_paren),
            l_brace: Box::new(l_brace),
            always_ff_declaration_list,
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar
            .always_ff_declaration(&always_ff_declaration_built)?;
        self.push(
            ASTType::AlwaysFfDeclaration(always_ff_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 532:
    ///
    /// AlwaysFfDeclarationList /* Vec<T>::Push */: Statement AlwaysFfDeclarationList;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_declaration_list_0(
        &mut self,
        _statement: &ParseTreeType<'t>,
        _always_ff_declaration_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut always_ff_declaration_list = pop_item!(
            self,
            always_ff_declaration_list,
            AlwaysFfDeclarationList,
            context
        );
        let statement = pop_item!(self, statement, Statement, context);
        let always_ff_declaration_list_0_built = AlwaysFfDeclarationList {
            statement: Box::new(statement),
        };
        // Add an element to the vector
        always_ff_declaration_list.push(always_ff_declaration_list_0_built);
        self.push(
            ASTType::AlwaysFfDeclarationList(always_ff_declaration_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 533:
    ///
    /// AlwaysFfDeclarationList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_declaration_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_ff_declaration_list_1_built = Vec::new();
        self.push(
            ASTType::AlwaysFfDeclarationList(always_ff_declaration_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 534:
    ///
    /// AlwaysFfDeclarationOpt /* Option<T>::Some */: Comma AlwaysFfReset;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_declaration_opt_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _always_ff_reset: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_ff_reset = pop_item!(self, always_ff_reset, AlwaysFfReset, context);
        let comma = pop_item!(self, comma, Comma, context);
        let always_ff_declaration_opt_0_built = AlwaysFfDeclarationOpt {
            comma: Box::new(comma),
            always_ff_reset: Box::new(always_ff_reset),
        };
        self.push(
            ASTType::AlwaysFfDeclarationOpt(Some(Box::new(always_ff_declaration_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 535:
    ///
    /// AlwaysFfDeclarationOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_declaration_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::AlwaysFfDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 536:
    ///
    /// AlwaysFfClock: AlwaysFfClockOpt /* Option */ HierarchicalIdentifier;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_clock(
        &mut self,
        _always_ff_clock_opt: &ParseTreeType<'t>,
        _hierarchical_identifier: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hierarchical_identifier = pop_item!(
            self,
            hierarchical_identifier,
            HierarchicalIdentifier,
            context
        );
        let always_ff_clock_opt = pop_item!(self, always_ff_clock_opt, AlwaysFfClockOpt, context);
        let always_ff_clock_built = AlwaysFfClock {
            always_ff_clock_opt,
            hierarchical_identifier: Box::new(hierarchical_identifier),
        };
        // Calling user action here
        self.user_grammar.always_ff_clock(&always_ff_clock_built)?;
        self.push(ASTType::AlwaysFfClock(always_ff_clock_built), context);
        Ok(())
    }

    /// Semantic action for production 537:
    ///
    /// AlwaysFfClockOpt /* Option<T>::Some */: AlwaysFfClockOptGroup;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_clock_opt_0(
        &mut self,
        _always_ff_clock_opt_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_ff_clock_opt_group = pop_item!(
            self,
            always_ff_clock_opt_group,
            AlwaysFfClockOptGroup,
            context
        );
        let always_ff_clock_opt_0_built = AlwaysFfClockOpt {
            always_ff_clock_opt_group: Box::new(always_ff_clock_opt_group),
        };
        self.push(
            ASTType::AlwaysFfClockOpt(Some(Box::new(always_ff_clock_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 538:
    ///
    /// AlwaysFfClockOptGroup: Posedge;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_clock_opt_group_0(&mut self, _posedge: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let posedge = pop_item!(self, posedge, Posedge, context);
        let always_ff_clock_opt_group_0_built = AlwaysFfClockOptGroupPosedge {
            posedge: Box::new(posedge),
        };
        let always_ff_clock_opt_group_0_built =
            AlwaysFfClockOptGroup::Posedge(always_ff_clock_opt_group_0_built);
        self.push(
            ASTType::AlwaysFfClockOptGroup(always_ff_clock_opt_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 539:
    ///
    /// AlwaysFfClockOptGroup: Negedge;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_clock_opt_group_1(&mut self, _negedge: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let negedge = pop_item!(self, negedge, Negedge, context);
        let always_ff_clock_opt_group_1_built = AlwaysFfClockOptGroupNegedge {
            negedge: Box::new(negedge),
        };
        let always_ff_clock_opt_group_1_built =
            AlwaysFfClockOptGroup::Negedge(always_ff_clock_opt_group_1_built);
        self.push(
            ASTType::AlwaysFfClockOptGroup(always_ff_clock_opt_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 540:
    ///
    /// AlwaysFfClockOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_clock_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::AlwaysFfClockOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 541:
    ///
    /// AlwaysFfReset: AlwaysFfResetOpt /* Option */ HierarchicalIdentifier;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_reset(
        &mut self,
        _always_ff_reset_opt: &ParseTreeType<'t>,
        _hierarchical_identifier: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hierarchical_identifier = pop_item!(
            self,
            hierarchical_identifier,
            HierarchicalIdentifier,
            context
        );
        let always_ff_reset_opt = pop_item!(self, always_ff_reset_opt, AlwaysFfResetOpt, context);
        let always_ff_reset_built = AlwaysFfReset {
            always_ff_reset_opt,
            hierarchical_identifier: Box::new(hierarchical_identifier),
        };
        // Calling user action here
        self.user_grammar.always_ff_reset(&always_ff_reset_built)?;
        self.push(ASTType::AlwaysFfReset(always_ff_reset_built), context);
        Ok(())
    }

    /// Semantic action for production 542:
    ///
    /// AlwaysFfResetOpt /* Option<T>::Some */: AlwaysFfResetOptGroup;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_reset_opt_0(
        &mut self,
        _always_ff_reset_opt_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_ff_reset_opt_group = pop_item!(
            self,
            always_ff_reset_opt_group,
            AlwaysFfResetOptGroup,
            context
        );
        let always_ff_reset_opt_0_built = AlwaysFfResetOpt {
            always_ff_reset_opt_group: Box::new(always_ff_reset_opt_group),
        };
        self.push(
            ASTType::AlwaysFfResetOpt(Some(Box::new(always_ff_reset_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 543:
    ///
    /// AlwaysFfResetOptGroup: AsyncLow;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_reset_opt_group_0(&mut self, _async_low: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let async_low = pop_item!(self, async_low, AsyncLow, context);
        let always_ff_reset_opt_group_0_built = AlwaysFfResetOptGroupAsyncLow {
            async_low: Box::new(async_low),
        };
        let always_ff_reset_opt_group_0_built =
            AlwaysFfResetOptGroup::AsyncLow(always_ff_reset_opt_group_0_built);
        self.push(
            ASTType::AlwaysFfResetOptGroup(always_ff_reset_opt_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 544:
    ///
    /// AlwaysFfResetOptGroup: AsyncHigh;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_reset_opt_group_1(&mut self, _async_high: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let async_high = pop_item!(self, async_high, AsyncHigh, context);
        let always_ff_reset_opt_group_1_built = AlwaysFfResetOptGroupAsyncHigh {
            async_high: Box::new(async_high),
        };
        let always_ff_reset_opt_group_1_built =
            AlwaysFfResetOptGroup::AsyncHigh(always_ff_reset_opt_group_1_built);
        self.push(
            ASTType::AlwaysFfResetOptGroup(always_ff_reset_opt_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 545:
    ///
    /// AlwaysFfResetOptGroup: SyncLow;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_reset_opt_group_2(&mut self, _sync_low: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let sync_low = pop_item!(self, sync_low, SyncLow, context);
        let always_ff_reset_opt_group_2_built = AlwaysFfResetOptGroupSyncLow {
            sync_low: Box::new(sync_low),
        };
        let always_ff_reset_opt_group_2_built =
            AlwaysFfResetOptGroup::SyncLow(always_ff_reset_opt_group_2_built);
        self.push(
            ASTType::AlwaysFfResetOptGroup(always_ff_reset_opt_group_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 546:
    ///
    /// AlwaysFfResetOptGroup: SyncHigh;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_reset_opt_group_3(&mut self, _sync_high: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let sync_high = pop_item!(self, sync_high, SyncHigh, context);
        let always_ff_reset_opt_group_3_built = AlwaysFfResetOptGroupSyncHigh {
            sync_high: Box::new(sync_high),
        };
        let always_ff_reset_opt_group_3_built =
            AlwaysFfResetOptGroup::SyncHigh(always_ff_reset_opt_group_3_built);
        self.push(
            ASTType::AlwaysFfResetOptGroup(always_ff_reset_opt_group_3_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 547:
    ///
    /// AlwaysFfResetOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_reset_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::AlwaysFfResetOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 548:
    ///
    /// AlwaysCombDeclaration: AlwaysComb LBrace AlwaysCombDeclarationList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn always_comb_declaration(
        &mut self,
        _always_comb: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _always_comb_declaration_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let always_comb_declaration_list = pop_and_reverse_item!(
            self,
            always_comb_declaration_list,
            AlwaysCombDeclarationList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let always_comb = pop_item!(self, always_comb, AlwaysComb, context);
        let always_comb_declaration_built = AlwaysCombDeclaration {
            always_comb: Box::new(always_comb),
            l_brace: Box::new(l_brace),
            always_comb_declaration_list,
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar
            .always_comb_declaration(&always_comb_declaration_built)?;
        self.push(
            ASTType::AlwaysCombDeclaration(always_comb_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 549:
    ///
    /// AlwaysCombDeclarationList /* Vec<T>::Push */: Statement AlwaysCombDeclarationList;
    ///
    #[parol_runtime::function_name::named]
    fn always_comb_declaration_list_0(
        &mut self,
        _statement: &ParseTreeType<'t>,
        _always_comb_declaration_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut always_comb_declaration_list = pop_item!(
            self,
            always_comb_declaration_list,
            AlwaysCombDeclarationList,
            context
        );
        let statement = pop_item!(self, statement, Statement, context);
        let always_comb_declaration_list_0_built = AlwaysCombDeclarationList {
            statement: Box::new(statement),
        };
        // Add an element to the vector
        always_comb_declaration_list.push(always_comb_declaration_list_0_built);
        self.push(
            ASTType::AlwaysCombDeclarationList(always_comb_declaration_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 550:
    ///
    /// AlwaysCombDeclarationList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn always_comb_declaration_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_comb_declaration_list_1_built = Vec::new();
        self.push(
            ASTType::AlwaysCombDeclarationList(always_comb_declaration_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 551:
    ///
    /// AssignDeclaration: Assign HierarchicalIdentifier Equ Expression Semicolon;
    ///
    #[parol_runtime::function_name::named]
    fn assign_declaration(
        &mut self,
        _assign: &ParseTreeType<'t>,
        _hierarchical_identifier: &ParseTreeType<'t>,
        _equ: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let expression = pop_item!(self, expression, Expression, context);
        let equ = pop_item!(self, equ, Equ, context);
        let hierarchical_identifier = pop_item!(
            self,
            hierarchical_identifier,
            HierarchicalIdentifier,
            context
        );
        let assign = pop_item!(self, assign, Assign, context);
        let assign_declaration_built = AssignDeclaration {
            assign: Box::new(assign),
            hierarchical_identifier: Box::new(hierarchical_identifier),
            equ: Box::new(equ),
            expression: Box::new(expression),
            semicolon: Box::new(semicolon),
        };
        // Calling user action here
        self.user_grammar
            .assign_declaration(&assign_declaration_built)?;
        self.push(
            ASTType::AssignDeclaration(assign_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 552:
    ///
    /// ModportDeclaration: Modport Identifier LBrace ModportList RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn modport_declaration(
        &mut self,
        _modport: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _modport_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let modport_list = pop_item!(self, modport_list, ModportList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let modport = pop_item!(self, modport, Modport, context);
        let modport_declaration_built = ModportDeclaration {
            modport: Box::new(modport),
            identifier: Box::new(identifier),
            l_brace: Box::new(l_brace),
            modport_list: Box::new(modport_list),
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar
            .modport_declaration(&modport_declaration_built)?;
        self.push(
            ASTType::ModportDeclaration(modport_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 553:
    ///
    /// ModportList: ModportGroup ModportListList /* Vec */ ModportListOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn modport_list(
        &mut self,
        _modport_group: &ParseTreeType<'t>,
        _modport_list_list: &ParseTreeType<'t>,
        _modport_list_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport_list_opt = pop_item!(self, modport_list_opt, ModportListOpt, context);
        let modport_list_list =
            pop_and_reverse_item!(self, modport_list_list, ModportListList, context);
        let modport_group = pop_item!(self, modport_group, ModportGroup, context);
        let modport_list_built = ModportList {
            modport_group: Box::new(modport_group),
            modport_list_list,
            modport_list_opt,
        };
        // Calling user action here
        self.user_grammar.modport_list(&modport_list_built)?;
        self.push(ASTType::ModportList(modport_list_built), context);
        Ok(())
    }

    /// Semantic action for production 554:
    ///
    /// ModportListList /* Vec<T>::Push */: Comma ModportGroup ModportListList;
    ///
    #[parol_runtime::function_name::named]
    fn modport_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _modport_group: &ParseTreeType<'t>,
        _modport_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut modport_list_list = pop_item!(self, modport_list_list, ModportListList, context);
        let modport_group = pop_item!(self, modport_group, ModportGroup, context);
        let comma = pop_item!(self, comma, Comma, context);
        let modport_list_list_0_built = ModportListList {
            modport_group: Box::new(modport_group),
            comma: Box::new(comma),
        };
        // Add an element to the vector
        modport_list_list.push(modport_list_list_0_built);
        self.push(ASTType::ModportListList(modport_list_list), context);
        Ok(())
    }

    /// Semantic action for production 555:
    ///
    /// ModportListList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn modport_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport_list_list_1_built = Vec::new();
        self.push(ASTType::ModportListList(modport_list_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 556:
    ///
    /// ModportListOpt /* Option<T>::Some */: Comma;
    ///
    #[parol_runtime::function_name::named]
    fn modport_list_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let modport_list_opt_0_built = ModportListOpt {
            comma: Box::new(comma),
        };
        self.push(
            ASTType::ModportListOpt(Some(Box::new(modport_list_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 557:
    ///
    /// ModportListOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn modport_list_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ModportListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 558:
    ///
    /// ModportGroup: ModportGroupList /* Vec */ ModportGroupGroup;
    ///
    #[parol_runtime::function_name::named]
    fn modport_group(
        &mut self,
        _modport_group_list: &ParseTreeType<'t>,
        _modport_group_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport_group_group = pop_item!(self, modport_group_group, ModportGroupGroup, context);
        let modport_group_list =
            pop_and_reverse_item!(self, modport_group_list, ModportGroupList, context);
        let modport_group_built = ModportGroup {
            modport_group_list,
            modport_group_group: Box::new(modport_group_group),
        };
        // Calling user action here
        self.user_grammar.modport_group(&modport_group_built)?;
        self.push(ASTType::ModportGroup(modport_group_built), context);
        Ok(())
    }

    /// Semantic action for production 559:
    ///
    /// ModportGroupGroup: LBrace ModportList RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn modport_group_group_0(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _modport_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let modport_list = pop_item!(self, modport_list, ModportList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let modport_group_group_0_built = ModportGroupGroupLBraceModportListRBrace {
            l_brace: Box::new(l_brace),
            modport_list: Box::new(modport_list),
            r_brace: Box::new(r_brace),
        };
        let modport_group_group_0_built =
            ModportGroupGroup::LBraceModportListRBrace(modport_group_group_0_built);
        self.push(
            ASTType::ModportGroupGroup(modport_group_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 560:
    ///
    /// ModportGroupGroup: ModportItem;
    ///
    #[parol_runtime::function_name::named]
    fn modport_group_group_1(&mut self, _modport_item: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport_item = pop_item!(self, modport_item, ModportItem, context);
        let modport_group_group_1_built = ModportGroupGroupModportItem {
            modport_item: Box::new(modport_item),
        };
        let modport_group_group_1_built =
            ModportGroupGroup::ModportItem(modport_group_group_1_built);
        self.push(
            ASTType::ModportGroupGroup(modport_group_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 561:
    ///
    /// ModportGroupList /* Vec<T>::Push */: Attribute ModportGroupList;
    ///
    #[parol_runtime::function_name::named]
    fn modport_group_list_0(
        &mut self,
        _attribute: &ParseTreeType<'t>,
        _modport_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut modport_group_list = pop_item!(self, modport_group_list, ModportGroupList, context);
        let attribute = pop_item!(self, attribute, Attribute, context);
        let modport_group_list_0_built = ModportGroupList {
            attribute: Box::new(attribute),
        };
        // Add an element to the vector
        modport_group_list.push(modport_group_list_0_built);
        self.push(ASTType::ModportGroupList(modport_group_list), context);
        Ok(())
    }

    /// Semantic action for production 562:
    ///
    /// ModportGroupList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn modport_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport_group_list_1_built = Vec::new();
        self.push(
            ASTType::ModportGroupList(modport_group_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 563:
    ///
    /// ModportItem: Identifier Colon Direction;
    ///
    #[parol_runtime::function_name::named]
    fn modport_item(
        &mut self,
        _identifier: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _direction: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let direction = pop_item!(self, direction, Direction, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let modport_item_built = ModportItem {
            identifier: Box::new(identifier),
            colon: Box::new(colon),
            direction: Box::new(direction),
        };
        // Calling user action here
        self.user_grammar.modport_item(&modport_item_built)?;
        self.push(ASTType::ModportItem(modport_item_built), context);
        Ok(())
    }

    /// Semantic action for production 564:
    ///
    /// EnumDeclaration: Enum Identifier Colon ScalarType LBrace EnumList RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn enum_declaration(
        &mut self,
        _enum: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _scalar_type: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _enum_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let enum_list = pop_item!(self, enum_list, EnumList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let scalar_type = pop_item!(self, scalar_type, ScalarType, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let r#enum = pop_item!(self, r#enum, Enum, context);
        let enum_declaration_built = EnumDeclaration {
            r#enum: Box::new(r#enum),
            identifier: Box::new(identifier),
            colon: Box::new(colon),
            scalar_type: Box::new(scalar_type),
            l_brace: Box::new(l_brace),
            enum_list: Box::new(enum_list),
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar
            .enum_declaration(&enum_declaration_built)?;
        self.push(ASTType::EnumDeclaration(enum_declaration_built), context);
        Ok(())
    }

    /// Semantic action for production 565:
    ///
    /// EnumList: EnumGroup EnumListList /* Vec */ EnumListOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn enum_list(
        &mut self,
        _enum_group: &ParseTreeType<'t>,
        _enum_list_list: &ParseTreeType<'t>,
        _enum_list_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enum_list_opt = pop_item!(self, enum_list_opt, EnumListOpt, context);
        let enum_list_list = pop_and_reverse_item!(self, enum_list_list, EnumListList, context);
        let enum_group = pop_item!(self, enum_group, EnumGroup, context);
        let enum_list_built = EnumList {
            enum_group: Box::new(enum_group),
            enum_list_list,
            enum_list_opt,
        };
        // Calling user action here
        self.user_grammar.enum_list(&enum_list_built)?;
        self.push(ASTType::EnumList(enum_list_built), context);
        Ok(())
    }

    /// Semantic action for production 566:
    ///
    /// EnumListList /* Vec<T>::Push */: Comma EnumGroup EnumListList;
    ///
    #[parol_runtime::function_name::named]
    fn enum_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _enum_group: &ParseTreeType<'t>,
        _enum_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut enum_list_list = pop_item!(self, enum_list_list, EnumListList, context);
        let enum_group = pop_item!(self, enum_group, EnumGroup, context);
        let comma = pop_item!(self, comma, Comma, context);
        let enum_list_list_0_built = EnumListList {
            enum_group: Box::new(enum_group),
            comma: Box::new(comma),
        };
        // Add an element to the vector
        enum_list_list.push(enum_list_list_0_built);
        self.push(ASTType::EnumListList(enum_list_list), context);
        Ok(())
    }

    /// Semantic action for production 567:
    ///
    /// EnumListList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn enum_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enum_list_list_1_built = Vec::new();
        self.push(ASTType::EnumListList(enum_list_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 568:
    ///
    /// EnumListOpt /* Option<T>::Some */: Comma;
    ///
    #[parol_runtime::function_name::named]
    fn enum_list_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let enum_list_opt_0_built = EnumListOpt {
            comma: Box::new(comma),
        };
        self.push(
            ASTType::EnumListOpt(Some(Box::new(enum_list_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 569:
    ///
    /// EnumListOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn enum_list_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::EnumListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 570:
    ///
    /// EnumGroup: EnumGroupList /* Vec */ EnumGroupGroup;
    ///
    #[parol_runtime::function_name::named]
    fn enum_group(
        &mut self,
        _enum_group_list: &ParseTreeType<'t>,
        _enum_group_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enum_group_group = pop_item!(self, enum_group_group, EnumGroupGroup, context);
        let enum_group_list = pop_and_reverse_item!(self, enum_group_list, EnumGroupList, context);
        let enum_group_built = EnumGroup {
            enum_group_list,
            enum_group_group: Box::new(enum_group_group),
        };
        // Calling user action here
        self.user_grammar.enum_group(&enum_group_built)?;
        self.push(ASTType::EnumGroup(enum_group_built), context);
        Ok(())
    }

    /// Semantic action for production 571:
    ///
    /// EnumGroupGroup: LBrace EnumList RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn enum_group_group_0(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _enum_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let enum_list = pop_item!(self, enum_list, EnumList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let enum_group_group_0_built = EnumGroupGroupLBraceEnumListRBrace {
            l_brace: Box::new(l_brace),
            enum_list: Box::new(enum_list),
            r_brace: Box::new(r_brace),
        };
        let enum_group_group_0_built =
            EnumGroupGroup::LBraceEnumListRBrace(enum_group_group_0_built);
        self.push(ASTType::EnumGroupGroup(enum_group_group_0_built), context);
        Ok(())
    }

    /// Semantic action for production 572:
    ///
    /// EnumGroupGroup: EnumItem;
    ///
    #[parol_runtime::function_name::named]
    fn enum_group_group_1(&mut self, _enum_item: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enum_item = pop_item!(self, enum_item, EnumItem, context);
        let enum_group_group_1_built = EnumGroupGroupEnumItem {
            enum_item: Box::new(enum_item),
        };
        let enum_group_group_1_built = EnumGroupGroup::EnumItem(enum_group_group_1_built);
        self.push(ASTType::EnumGroupGroup(enum_group_group_1_built), context);
        Ok(())
    }

    /// Semantic action for production 573:
    ///
    /// EnumGroupList /* Vec<T>::Push */: Attribute EnumGroupList;
    ///
    #[parol_runtime::function_name::named]
    fn enum_group_list_0(
        &mut self,
        _attribute: &ParseTreeType<'t>,
        _enum_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut enum_group_list = pop_item!(self, enum_group_list, EnumGroupList, context);
        let attribute = pop_item!(self, attribute, Attribute, context);
        let enum_group_list_0_built = EnumGroupList {
            attribute: Box::new(attribute),
        };
        // Add an element to the vector
        enum_group_list.push(enum_group_list_0_built);
        self.push(ASTType::EnumGroupList(enum_group_list), context);
        Ok(())
    }

    /// Semantic action for production 574:
    ///
    /// EnumGroupList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn enum_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enum_group_list_1_built = Vec::new();
        self.push(ASTType::EnumGroupList(enum_group_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 575:
    ///
    /// EnumItem: Identifier EnumItemOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn enum_item(
        &mut self,
        _identifier: &ParseTreeType<'t>,
        _enum_item_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enum_item_opt = pop_item!(self, enum_item_opt, EnumItemOpt, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let enum_item_built = EnumItem {
            identifier: Box::new(identifier),
            enum_item_opt,
        };
        // Calling user action here
        self.user_grammar.enum_item(&enum_item_built)?;
        self.push(ASTType::EnumItem(enum_item_built), context);
        Ok(())
    }

    /// Semantic action for production 576:
    ///
    /// EnumItemOpt /* Option<T>::Some */: Equ Expression;
    ///
    #[parol_runtime::function_name::named]
    fn enum_item_opt_0(
        &mut self,
        _equ: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let equ = pop_item!(self, equ, Equ, context);
        let enum_item_opt_0_built = EnumItemOpt {
            equ: Box::new(equ),
            expression: Box::new(expression),
        };
        self.push(
            ASTType::EnumItemOpt(Some(Box::new(enum_item_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 577:
    ///
    /// EnumItemOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn enum_item_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::EnumItemOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 578:
    ///
    /// StructDeclaration: Struct Identifier LBrace StructList RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn struct_declaration(
        &mut self,
        _struct: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _struct_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let struct_list = pop_item!(self, struct_list, StructList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let r#struct = pop_item!(self, r#struct, Struct, context);
        let struct_declaration_built = StructDeclaration {
            r#struct: Box::new(r#struct),
            identifier: Box::new(identifier),
            l_brace: Box::new(l_brace),
            struct_list: Box::new(struct_list),
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar
            .struct_declaration(&struct_declaration_built)?;
        self.push(
            ASTType::StructDeclaration(struct_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 579:
    ///
    /// StructList: StructGroup StructListList /* Vec */ StructListOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn struct_list(
        &mut self,
        _struct_group: &ParseTreeType<'t>,
        _struct_list_list: &ParseTreeType<'t>,
        _struct_list_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let struct_list_opt = pop_item!(self, struct_list_opt, StructListOpt, context);
        let struct_list_list =
            pop_and_reverse_item!(self, struct_list_list, StructListList, context);
        let struct_group = pop_item!(self, struct_group, StructGroup, context);
        let struct_list_built = StructList {
            struct_group: Box::new(struct_group),
            struct_list_list,
            struct_list_opt,
        };
        // Calling user action here
        self.user_grammar.struct_list(&struct_list_built)?;
        self.push(ASTType::StructList(struct_list_built), context);
        Ok(())
    }

    /// Semantic action for production 580:
    ///
    /// StructListList /* Vec<T>::Push */: Comma StructGroup StructListList;
    ///
    #[parol_runtime::function_name::named]
    fn struct_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _struct_group: &ParseTreeType<'t>,
        _struct_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut struct_list_list = pop_item!(self, struct_list_list, StructListList, context);
        let struct_group = pop_item!(self, struct_group, StructGroup, context);
        let comma = pop_item!(self, comma, Comma, context);
        let struct_list_list_0_built = StructListList {
            struct_group: Box::new(struct_group),
            comma: Box::new(comma),
        };
        // Add an element to the vector
        struct_list_list.push(struct_list_list_0_built);
        self.push(ASTType::StructListList(struct_list_list), context);
        Ok(())
    }

    /// Semantic action for production 581:
    ///
    /// StructListList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn struct_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let struct_list_list_1_built = Vec::new();
        self.push(ASTType::StructListList(struct_list_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 582:
    ///
    /// StructListOpt /* Option<T>::Some */: Comma;
    ///
    #[parol_runtime::function_name::named]
    fn struct_list_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let struct_list_opt_0_built = StructListOpt {
            comma: Box::new(comma),
        };
        self.push(
            ASTType::StructListOpt(Some(Box::new(struct_list_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 583:
    ///
    /// StructListOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn struct_list_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::StructListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 584:
    ///
    /// StructGroup: StructGroupList /* Vec */ StructGroupGroup;
    ///
    #[parol_runtime::function_name::named]
    fn struct_group(
        &mut self,
        _struct_group_list: &ParseTreeType<'t>,
        _struct_group_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let struct_group_group = pop_item!(self, struct_group_group, StructGroupGroup, context);
        let struct_group_list =
            pop_and_reverse_item!(self, struct_group_list, StructGroupList, context);
        let struct_group_built = StructGroup {
            struct_group_list,
            struct_group_group: Box::new(struct_group_group),
        };
        // Calling user action here
        self.user_grammar.struct_group(&struct_group_built)?;
        self.push(ASTType::StructGroup(struct_group_built), context);
        Ok(())
    }

    /// Semantic action for production 585:
    ///
    /// StructGroupGroup: LBrace StructList RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn struct_group_group_0(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _struct_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let struct_list = pop_item!(self, struct_list, StructList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let struct_group_group_0_built = StructGroupGroupLBraceStructListRBrace {
            l_brace: Box::new(l_brace),
            struct_list: Box::new(struct_list),
            r_brace: Box::new(r_brace),
        };
        let struct_group_group_0_built =
            StructGroupGroup::LBraceStructListRBrace(struct_group_group_0_built);
        self.push(
            ASTType::StructGroupGroup(struct_group_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 586:
    ///
    /// StructGroupGroup: StructItem;
    ///
    #[parol_runtime::function_name::named]
    fn struct_group_group_1(&mut self, _struct_item: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let struct_item = pop_item!(self, struct_item, StructItem, context);
        let struct_group_group_1_built = StructGroupGroupStructItem {
            struct_item: Box::new(struct_item),
        };
        let struct_group_group_1_built = StructGroupGroup::StructItem(struct_group_group_1_built);
        self.push(
            ASTType::StructGroupGroup(struct_group_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 587:
    ///
    /// StructGroupList /* Vec<T>::Push */: Attribute StructGroupList;
    ///
    #[parol_runtime::function_name::named]
    fn struct_group_list_0(
        &mut self,
        _attribute: &ParseTreeType<'t>,
        _struct_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut struct_group_list = pop_item!(self, struct_group_list, StructGroupList, context);
        let attribute = pop_item!(self, attribute, Attribute, context);
        let struct_group_list_0_built = StructGroupList {
            attribute: Box::new(attribute),
        };
        // Add an element to the vector
        struct_group_list.push(struct_group_list_0_built);
        self.push(ASTType::StructGroupList(struct_group_list), context);
        Ok(())
    }

    /// Semantic action for production 588:
    ///
    /// StructGroupList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn struct_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let struct_group_list_1_built = Vec::new();
        self.push(ASTType::StructGroupList(struct_group_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 589:
    ///
    /// StructItem: Identifier Colon ScalarType;
    ///
    #[parol_runtime::function_name::named]
    fn struct_item(
        &mut self,
        _identifier: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _scalar_type: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scalar_type = pop_item!(self, scalar_type, ScalarType, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let struct_item_built = StructItem {
            identifier: Box::new(identifier),
            colon: Box::new(colon),
            scalar_type: Box::new(scalar_type),
        };
        // Calling user action here
        self.user_grammar.struct_item(&struct_item_built)?;
        self.push(ASTType::StructItem(struct_item_built), context);
        Ok(())
    }

    /// Semantic action for production 590:
    ///
    /// InitialDeclaration: Initial LBrace InitialDeclarationList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn initial_declaration(
        &mut self,
        _initial: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _initial_declaration_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let initial_declaration_list = pop_and_reverse_item!(
            self,
            initial_declaration_list,
            InitialDeclarationList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let initial = pop_item!(self, initial, Initial, context);
        let initial_declaration_built = InitialDeclaration {
            initial: Box::new(initial),
            l_brace: Box::new(l_brace),
            initial_declaration_list,
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar
            .initial_declaration(&initial_declaration_built)?;
        self.push(
            ASTType::InitialDeclaration(initial_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 591:
    ///
    /// InitialDeclarationList /* Vec<T>::Push */: InitialItem InitialDeclarationList;
    ///
    #[parol_runtime::function_name::named]
    fn initial_declaration_list_0(
        &mut self,
        _initial_item: &ParseTreeType<'t>,
        _initial_declaration_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut initial_declaration_list = pop_item!(
            self,
            initial_declaration_list,
            InitialDeclarationList,
            context
        );
        let initial_item = pop_item!(self, initial_item, InitialItem, context);
        let initial_declaration_list_0_built = InitialDeclarationList {
            initial_item: Box::new(initial_item),
        };
        // Add an element to the vector
        initial_declaration_list.push(initial_declaration_list_0_built);
        self.push(
            ASTType::InitialDeclarationList(initial_declaration_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 592:
    ///
    /// InitialDeclarationList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn initial_declaration_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let initial_declaration_list_1_built = Vec::new();
        self.push(
            ASTType::InitialDeclarationList(initial_declaration_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 593:
    ///
    /// InitialItem: Statement;
    ///
    #[parol_runtime::function_name::named]
    fn initial_item_0(&mut self, _statement: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement = pop_item!(self, statement, Statement, context);
        let initial_item_0_built = InitialItemStatement {
            statement: Box::new(statement),
        };
        let initial_item_0_built = InitialItem::Statement(initial_item_0_built);
        // Calling user action here
        self.user_grammar.initial_item(&initial_item_0_built)?;
        self.push(ASTType::InitialItem(initial_item_0_built), context);
        Ok(())
    }

    /// Semantic action for production 594:
    ///
    /// InitialItem: Assignment;
    ///
    #[parol_runtime::function_name::named]
    fn initial_item_1(&mut self, _assignment: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assignment = pop_item!(self, assignment, Assignment, context);
        let initial_item_1_built = InitialItemAssignment {
            assignment: Box::new(assignment),
        };
        let initial_item_1_built = InitialItem::Assignment(initial_item_1_built);
        // Calling user action here
        self.user_grammar.initial_item(&initial_item_1_built)?;
        self.push(ASTType::InitialItem(initial_item_1_built), context);
        Ok(())
    }

    /// Semantic action for production 595:
    ///
    /// FinalDeclaration: Final LBrace FinalDeclarationList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn final_declaration(
        &mut self,
        _final: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _final_declaration_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let final_declaration_list =
            pop_and_reverse_item!(self, final_declaration_list, FinalDeclarationList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let r#final = pop_item!(self, r#final, Final, context);
        let final_declaration_built = FinalDeclaration {
            r#final: Box::new(r#final),
            l_brace: Box::new(l_brace),
            final_declaration_list,
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar
            .final_declaration(&final_declaration_built)?;
        self.push(ASTType::FinalDeclaration(final_declaration_built), context);
        Ok(())
    }

    /// Semantic action for production 596:
    ///
    /// FinalDeclarationList /* Vec<T>::Push */: Statement FinalDeclarationList;
    ///
    #[parol_runtime::function_name::named]
    fn final_declaration_list_0(
        &mut self,
        _statement: &ParseTreeType<'t>,
        _final_declaration_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut final_declaration_list =
            pop_item!(self, final_declaration_list, FinalDeclarationList, context);
        let statement = pop_item!(self, statement, Statement, context);
        let final_declaration_list_0_built = FinalDeclarationList {
            statement: Box::new(statement),
        };
        // Add an element to the vector
        final_declaration_list.push(final_declaration_list_0_built);
        self.push(
            ASTType::FinalDeclarationList(final_declaration_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 597:
    ///
    /// FinalDeclarationList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn final_declaration_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let final_declaration_list_1_built = Vec::new();
        self.push(
            ASTType::FinalDeclarationList(final_declaration_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 598:
    ///
    /// InstDeclaration: Inst Identifier Colon ScopedIdentifier InstDeclarationOpt /* Option */ InstDeclarationOpt0 /* Option */ InstDeclarationOpt1 /* Option */ Semicolon;
    ///
    #[parol_runtime::function_name::named]
    fn inst_declaration(
        &mut self,
        _inst: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _scoped_identifier: &ParseTreeType<'t>,
        _inst_declaration_opt: &ParseTreeType<'t>,
        _inst_declaration_opt0: &ParseTreeType<'t>,
        _inst_declaration_opt1: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let inst_declaration_opt1 =
            pop_item!(self, inst_declaration_opt1, InstDeclarationOpt1, context);
        let inst_declaration_opt0 =
            pop_item!(self, inst_declaration_opt0, InstDeclarationOpt0, context);
        let inst_declaration_opt =
            pop_item!(self, inst_declaration_opt, InstDeclarationOpt, context);
        let scoped_identifier = pop_item!(self, scoped_identifier, ScopedIdentifier, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let inst = pop_item!(self, inst, Inst, context);
        let inst_declaration_built = InstDeclaration {
            inst: Box::new(inst),
            identifier: Box::new(identifier),
            colon: Box::new(colon),
            scoped_identifier: Box::new(scoped_identifier),
            inst_declaration_opt,
            inst_declaration_opt0,
            inst_declaration_opt1,
            semicolon: Box::new(semicolon),
        };
        // Calling user action here
        self.user_grammar
            .inst_declaration(&inst_declaration_built)?;
        self.push(ASTType::InstDeclaration(inst_declaration_built), context);
        Ok(())
    }

    /// Semantic action for production 599:
    ///
    /// InstDeclarationOpt1 /* Option<T>::Some */: LParen InstDeclarationOpt2 /* Option */ RParen;
    ///
    #[parol_runtime::function_name::named]
    fn inst_declaration_opt1_0(
        &mut self,
        _l_paren: &ParseTreeType<'t>,
        _inst_declaration_opt2: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let inst_declaration_opt2 =
            pop_item!(self, inst_declaration_opt2, InstDeclarationOpt2, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let inst_declaration_opt1_0_built = InstDeclarationOpt1 {
            l_paren: Box::new(l_paren),
            inst_declaration_opt2,
            r_paren: Box::new(r_paren),
        };
        self.push(
            ASTType::InstDeclarationOpt1(Some(Box::new(inst_declaration_opt1_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 600:
    ///
    /// InstDeclarationOpt2 /* Option<T>::Some */: InstPortList;
    ///
    #[parol_runtime::function_name::named]
    fn inst_declaration_opt2_0(&mut self, _inst_port_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_port_list = pop_item!(self, inst_port_list, InstPortList, context);
        let inst_declaration_opt2_0_built = InstDeclarationOpt2 {
            inst_port_list: Box::new(inst_port_list),
        };
        self.push(
            ASTType::InstDeclarationOpt2(Some(Box::new(inst_declaration_opt2_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 601:
    ///
    /// InstDeclarationOpt2 /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn inst_declaration_opt2_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InstDeclarationOpt2(None), context);
        Ok(())
    }

    /// Semantic action for production 602:
    ///
    /// InstDeclarationOpt1 /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn inst_declaration_opt1_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InstDeclarationOpt1(None), context);
        Ok(())
    }

    /// Semantic action for production 603:
    ///
    /// InstDeclarationOpt0 /* Option<T>::Some */: InstParameter;
    ///
    #[parol_runtime::function_name::named]
    fn inst_declaration_opt0_0(&mut self, _inst_parameter: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_parameter = pop_item!(self, inst_parameter, InstParameter, context);
        let inst_declaration_opt0_0_built = InstDeclarationOpt0 {
            inst_parameter: Box::new(inst_parameter),
        };
        self.push(
            ASTType::InstDeclarationOpt0(Some(Box::new(inst_declaration_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 604:
    ///
    /// InstDeclarationOpt0 /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn inst_declaration_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InstDeclarationOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 605:
    ///
    /// InstDeclarationOpt /* Option<T>::Some */: Array;
    ///
    #[parol_runtime::function_name::named]
    fn inst_declaration_opt_0(&mut self, _array: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array = pop_item!(self, array, Array, context);
        let inst_declaration_opt_0_built = InstDeclarationOpt {
            array: Box::new(array),
        };
        self.push(
            ASTType::InstDeclarationOpt(Some(Box::new(inst_declaration_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 606:
    ///
    /// InstDeclarationOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn inst_declaration_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InstDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 607:
    ///
    /// InstParameter: Hash LParen InstParameterOpt /* Option */ RParen;
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter(
        &mut self,
        _hash: &ParseTreeType<'t>,
        _l_paren: &ParseTreeType<'t>,
        _inst_parameter_opt: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let inst_parameter_opt = pop_item!(self, inst_parameter_opt, InstParameterOpt, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let hash = pop_item!(self, hash, Hash, context);
        let inst_parameter_built = InstParameter {
            hash: Box::new(hash),
            l_paren: Box::new(l_paren),
            inst_parameter_opt,
            r_paren: Box::new(r_paren),
        };
        // Calling user action here
        self.user_grammar.inst_parameter(&inst_parameter_built)?;
        self.push(ASTType::InstParameter(inst_parameter_built), context);
        Ok(())
    }

    /// Semantic action for production 608:
    ///
    /// InstParameterOpt /* Option<T>::Some */: InstParameterList;
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_opt_0(&mut self, _inst_parameter_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_parameter_list = pop_item!(self, inst_parameter_list, InstParameterList, context);
        let inst_parameter_opt_0_built = InstParameterOpt {
            inst_parameter_list: Box::new(inst_parameter_list),
        };
        self.push(
            ASTType::InstParameterOpt(Some(Box::new(inst_parameter_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 609:
    ///
    /// InstParameterOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InstParameterOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 610:
    ///
    /// InstParameterList: InstParameterGroup InstParameterListList /* Vec */ InstParameterListOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_list(
        &mut self,
        _inst_parameter_group: &ParseTreeType<'t>,
        _inst_parameter_list_list: &ParseTreeType<'t>,
        _inst_parameter_list_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_parameter_list_opt =
            pop_item!(self, inst_parameter_list_opt, InstParameterListOpt, context);
        let inst_parameter_list_list = pop_and_reverse_item!(
            self,
            inst_parameter_list_list,
            InstParameterListList,
            context
        );
        let inst_parameter_group =
            pop_item!(self, inst_parameter_group, InstParameterGroup, context);
        let inst_parameter_list_built = InstParameterList {
            inst_parameter_group: Box::new(inst_parameter_group),
            inst_parameter_list_list,
            inst_parameter_list_opt,
        };
        // Calling user action here
        self.user_grammar
            .inst_parameter_list(&inst_parameter_list_built)?;
        self.push(
            ASTType::InstParameterList(inst_parameter_list_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 611:
    ///
    /// InstParameterListList /* Vec<T>::Push */: Comma InstParameterGroup InstParameterListList;
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _inst_parameter_group: &ParseTreeType<'t>,
        _inst_parameter_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut inst_parameter_list_list = pop_item!(
            self,
            inst_parameter_list_list,
            InstParameterListList,
            context
        );
        let inst_parameter_group =
            pop_item!(self, inst_parameter_group, InstParameterGroup, context);
        let comma = pop_item!(self, comma, Comma, context);
        let inst_parameter_list_list_0_built = InstParameterListList {
            inst_parameter_group: Box::new(inst_parameter_group),
            comma: Box::new(comma),
        };
        // Add an element to the vector
        inst_parameter_list_list.push(inst_parameter_list_list_0_built);
        self.push(
            ASTType::InstParameterListList(inst_parameter_list_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 612:
    ///
    /// InstParameterListList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_parameter_list_list_1_built = Vec::new();
        self.push(
            ASTType::InstParameterListList(inst_parameter_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 613:
    ///
    /// InstParameterListOpt /* Option<T>::Some */: Comma;
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_list_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let inst_parameter_list_opt_0_built = InstParameterListOpt {
            comma: Box::new(comma),
        };
        self.push(
            ASTType::InstParameterListOpt(Some(Box::new(inst_parameter_list_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 614:
    ///
    /// InstParameterListOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_list_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InstParameterListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 615:
    ///
    /// InstParameterGroup: InstParameterGroupList /* Vec */ InstParameterGroupGroup;
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_group(
        &mut self,
        _inst_parameter_group_list: &ParseTreeType<'t>,
        _inst_parameter_group_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_parameter_group_group = pop_item!(
            self,
            inst_parameter_group_group,
            InstParameterGroupGroup,
            context
        );
        let inst_parameter_group_list = pop_and_reverse_item!(
            self,
            inst_parameter_group_list,
            InstParameterGroupList,
            context
        );
        let inst_parameter_group_built = InstParameterGroup {
            inst_parameter_group_list,
            inst_parameter_group_group: Box::new(inst_parameter_group_group),
        };
        // Calling user action here
        self.user_grammar
            .inst_parameter_group(&inst_parameter_group_built)?;
        self.push(
            ASTType::InstParameterGroup(inst_parameter_group_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 616:
    ///
    /// InstParameterGroupGroup: LBrace InstParameterList RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_group_group_0(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _inst_parameter_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let inst_parameter_list = pop_item!(self, inst_parameter_list, InstParameterList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let inst_parameter_group_group_0_built =
            InstParameterGroupGroupLBraceInstParameterListRBrace {
                l_brace: Box::new(l_brace),
                inst_parameter_list: Box::new(inst_parameter_list),
                r_brace: Box::new(r_brace),
            };
        let inst_parameter_group_group_0_built =
            InstParameterGroupGroup::LBraceInstParameterListRBrace(
                inst_parameter_group_group_0_built,
            );
        self.push(
            ASTType::InstParameterGroupGroup(inst_parameter_group_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 617:
    ///
    /// InstParameterGroupGroup: InstParameterItem;
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_group_group_1(
        &mut self,
        _inst_parameter_item: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_parameter_item = pop_item!(self, inst_parameter_item, InstParameterItem, context);
        let inst_parameter_group_group_1_built = InstParameterGroupGroupInstParameterItem {
            inst_parameter_item: Box::new(inst_parameter_item),
        };
        let inst_parameter_group_group_1_built =
            InstParameterGroupGroup::InstParameterItem(inst_parameter_group_group_1_built);
        self.push(
            ASTType::InstParameterGroupGroup(inst_parameter_group_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 618:
    ///
    /// InstParameterGroupList /* Vec<T>::Push */: Attribute InstParameterGroupList;
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_group_list_0(
        &mut self,
        _attribute: &ParseTreeType<'t>,
        _inst_parameter_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut inst_parameter_group_list = pop_item!(
            self,
            inst_parameter_group_list,
            InstParameterGroupList,
            context
        );
        let attribute = pop_item!(self, attribute, Attribute, context);
        let inst_parameter_group_list_0_built = InstParameterGroupList {
            attribute: Box::new(attribute),
        };
        // Add an element to the vector
        inst_parameter_group_list.push(inst_parameter_group_list_0_built);
        self.push(
            ASTType::InstParameterGroupList(inst_parameter_group_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 619:
    ///
    /// InstParameterGroupList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_parameter_group_list_1_built = Vec::new();
        self.push(
            ASTType::InstParameterGroupList(inst_parameter_group_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 620:
    ///
    /// InstParameterItem: Identifier InstParameterItemOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_item(
        &mut self,
        _identifier: &ParseTreeType<'t>,
        _inst_parameter_item_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_parameter_item_opt =
            pop_item!(self, inst_parameter_item_opt, InstParameterItemOpt, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let inst_parameter_item_built = InstParameterItem {
            identifier: Box::new(identifier),
            inst_parameter_item_opt,
        };
        // Calling user action here
        self.user_grammar
            .inst_parameter_item(&inst_parameter_item_built)?;
        self.push(
            ASTType::InstParameterItem(inst_parameter_item_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 621:
    ///
    /// InstParameterItemOpt /* Option<T>::Some */: Colon Expression;
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_item_opt_0(
        &mut self,
        _colon: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let colon = pop_item!(self, colon, Colon, context);
        let inst_parameter_item_opt_0_built = InstParameterItemOpt {
            colon: Box::new(colon),
            expression: Box::new(expression),
        };
        self.push(
            ASTType::InstParameterItemOpt(Some(Box::new(inst_parameter_item_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 622:
    ///
    /// InstParameterItemOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_item_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InstParameterItemOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 623:
    ///
    /// InstPortList: InstPortGroup InstPortListList /* Vec */ InstPortListOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn inst_port_list(
        &mut self,
        _inst_port_group: &ParseTreeType<'t>,
        _inst_port_list_list: &ParseTreeType<'t>,
        _inst_port_list_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_port_list_opt = pop_item!(self, inst_port_list_opt, InstPortListOpt, context);
        let inst_port_list_list =
            pop_and_reverse_item!(self, inst_port_list_list, InstPortListList, context);
        let inst_port_group = pop_item!(self, inst_port_group, InstPortGroup, context);
        let inst_port_list_built = InstPortList {
            inst_port_group: Box::new(inst_port_group),
            inst_port_list_list,
            inst_port_list_opt,
        };
        // Calling user action here
        self.user_grammar.inst_port_list(&inst_port_list_built)?;
        self.push(ASTType::InstPortList(inst_port_list_built), context);
        Ok(())
    }

    /// Semantic action for production 624:
    ///
    /// InstPortListList /* Vec<T>::Push */: Comma InstPortGroup InstPortListList;
    ///
    #[parol_runtime::function_name::named]
    fn inst_port_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _inst_port_group: &ParseTreeType<'t>,
        _inst_port_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut inst_port_list_list =
            pop_item!(self, inst_port_list_list, InstPortListList, context);
        let inst_port_group = pop_item!(self, inst_port_group, InstPortGroup, context);
        let comma = pop_item!(self, comma, Comma, context);
        let inst_port_list_list_0_built = InstPortListList {
            inst_port_group: Box::new(inst_port_group),
            comma: Box::new(comma),
        };
        // Add an element to the vector
        inst_port_list_list.push(inst_port_list_list_0_built);
        self.push(ASTType::InstPortListList(inst_port_list_list), context);
        Ok(())
    }

    /// Semantic action for production 625:
    ///
    /// InstPortListList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn inst_port_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_port_list_list_1_built = Vec::new();
        self.push(
            ASTType::InstPortListList(inst_port_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 626:
    ///
    /// InstPortListOpt /* Option<T>::Some */: Comma;
    ///
    #[parol_runtime::function_name::named]
    fn inst_port_list_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let inst_port_list_opt_0_built = InstPortListOpt {
            comma: Box::new(comma),
        };
        self.push(
            ASTType::InstPortListOpt(Some(Box::new(inst_port_list_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 627:
    ///
    /// InstPortListOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn inst_port_list_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InstPortListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 628:
    ///
    /// InstPortGroup: InstPortGroupList /* Vec */ InstPortGroupGroup;
    ///
    #[parol_runtime::function_name::named]
    fn inst_port_group(
        &mut self,
        _inst_port_group_list: &ParseTreeType<'t>,
        _inst_port_group_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_port_group_group =
            pop_item!(self, inst_port_group_group, InstPortGroupGroup, context);
        let inst_port_group_list =
            pop_and_reverse_item!(self, inst_port_group_list, InstPortGroupList, context);
        let inst_port_group_built = InstPortGroup {
            inst_port_group_list,
            inst_port_group_group: Box::new(inst_port_group_group),
        };
        // Calling user action here
        self.user_grammar.inst_port_group(&inst_port_group_built)?;
        self.push(ASTType::InstPortGroup(inst_port_group_built), context);
        Ok(())
    }

    /// Semantic action for production 629:
    ///
    /// InstPortGroupGroup: LBrace InstPortList RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn inst_port_group_group_0(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _inst_port_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let inst_port_list = pop_item!(self, inst_port_list, InstPortList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let inst_port_group_group_0_built = InstPortGroupGroupLBraceInstPortListRBrace {
            l_brace: Box::new(l_brace),
            inst_port_list: Box::new(inst_port_list),
            r_brace: Box::new(r_brace),
        };
        let inst_port_group_group_0_built =
            InstPortGroupGroup::LBraceInstPortListRBrace(inst_port_group_group_0_built);
        self.push(
            ASTType::InstPortGroupGroup(inst_port_group_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 630:
    ///
    /// InstPortGroupGroup: InstPortItem;
    ///
    #[parol_runtime::function_name::named]
    fn inst_port_group_group_1(&mut self, _inst_port_item: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_port_item = pop_item!(self, inst_port_item, InstPortItem, context);
        let inst_port_group_group_1_built = InstPortGroupGroupInstPortItem {
            inst_port_item: Box::new(inst_port_item),
        };
        let inst_port_group_group_1_built =
            InstPortGroupGroup::InstPortItem(inst_port_group_group_1_built);
        self.push(
            ASTType::InstPortGroupGroup(inst_port_group_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 631:
    ///
    /// InstPortGroupList /* Vec<T>::Push */: Attribute InstPortGroupList;
    ///
    #[parol_runtime::function_name::named]
    fn inst_port_group_list_0(
        &mut self,
        _attribute: &ParseTreeType<'t>,
        _inst_port_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut inst_port_group_list =
            pop_item!(self, inst_port_group_list, InstPortGroupList, context);
        let attribute = pop_item!(self, attribute, Attribute, context);
        let inst_port_group_list_0_built = InstPortGroupList {
            attribute: Box::new(attribute),
        };
        // Add an element to the vector
        inst_port_group_list.push(inst_port_group_list_0_built);
        self.push(ASTType::InstPortGroupList(inst_port_group_list), context);
        Ok(())
    }

    /// Semantic action for production 632:
    ///
    /// InstPortGroupList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn inst_port_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_port_group_list_1_built = Vec::new();
        self.push(
            ASTType::InstPortGroupList(inst_port_group_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 633:
    ///
    /// InstPortItem: Identifier InstPortItemOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn inst_port_item(
        &mut self,
        _identifier: &ParseTreeType<'t>,
        _inst_port_item_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_port_item_opt = pop_item!(self, inst_port_item_opt, InstPortItemOpt, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let inst_port_item_built = InstPortItem {
            identifier: Box::new(identifier),
            inst_port_item_opt,
        };
        // Calling user action here
        self.user_grammar.inst_port_item(&inst_port_item_built)?;
        self.push(ASTType::InstPortItem(inst_port_item_built), context);
        Ok(())
    }

    /// Semantic action for production 634:
    ///
    /// InstPortItemOpt /* Option<T>::Some */: Colon Expression;
    ///
    #[parol_runtime::function_name::named]
    fn inst_port_item_opt_0(
        &mut self,
        _colon: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let colon = pop_item!(self, colon, Colon, context);
        let inst_port_item_opt_0_built = InstPortItemOpt {
            colon: Box::new(colon),
            expression: Box::new(expression),
        };
        self.push(
            ASTType::InstPortItemOpt(Some(Box::new(inst_port_item_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 635:
    ///
    /// InstPortItemOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn inst_port_item_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InstPortItemOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 636:
    ///
    /// WithParameter: Hash LParen WithParameterOpt /* Option */ RParen;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter(
        &mut self,
        _hash: &ParseTreeType<'t>,
        _l_paren: &ParseTreeType<'t>,
        _with_parameter_opt: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let with_parameter_opt = pop_item!(self, with_parameter_opt, WithParameterOpt, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let hash = pop_item!(self, hash, Hash, context);
        let with_parameter_built = WithParameter {
            hash: Box::new(hash),
            l_paren: Box::new(l_paren),
            with_parameter_opt,
            r_paren: Box::new(r_paren),
        };
        // Calling user action here
        self.user_grammar.with_parameter(&with_parameter_built)?;
        self.push(ASTType::WithParameter(with_parameter_built), context);
        Ok(())
    }

    /// Semantic action for production 637:
    ///
    /// WithParameterOpt /* Option<T>::Some */: WithParameterList;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_opt_0(&mut self, _with_parameter_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter_list = pop_item!(self, with_parameter_list, WithParameterList, context);
        let with_parameter_opt_0_built = WithParameterOpt {
            with_parameter_list: Box::new(with_parameter_list),
        };
        self.push(
            ASTType::WithParameterOpt(Some(Box::new(with_parameter_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 638:
    ///
    /// WithParameterOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::WithParameterOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 639:
    ///
    /// WithParameterList: WithParameterGroup WithParameterListList /* Vec */ WithParameterListOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_list(
        &mut self,
        _with_parameter_group: &ParseTreeType<'t>,
        _with_parameter_list_list: &ParseTreeType<'t>,
        _with_parameter_list_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter_list_opt =
            pop_item!(self, with_parameter_list_opt, WithParameterListOpt, context);
        let with_parameter_list_list = pop_and_reverse_item!(
            self,
            with_parameter_list_list,
            WithParameterListList,
            context
        );
        let with_parameter_group =
            pop_item!(self, with_parameter_group, WithParameterGroup, context);
        let with_parameter_list_built = WithParameterList {
            with_parameter_group: Box::new(with_parameter_group),
            with_parameter_list_list,
            with_parameter_list_opt,
        };
        // Calling user action here
        self.user_grammar
            .with_parameter_list(&with_parameter_list_built)?;
        self.push(
            ASTType::WithParameterList(with_parameter_list_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 640:
    ///
    /// WithParameterListList /* Vec<T>::Push */: Comma WithParameterGroup WithParameterListList;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _with_parameter_group: &ParseTreeType<'t>,
        _with_parameter_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut with_parameter_list_list = pop_item!(
            self,
            with_parameter_list_list,
            WithParameterListList,
            context
        );
        let with_parameter_group =
            pop_item!(self, with_parameter_group, WithParameterGroup, context);
        let comma = pop_item!(self, comma, Comma, context);
        let with_parameter_list_list_0_built = WithParameterListList {
            with_parameter_group: Box::new(with_parameter_group),
            comma: Box::new(comma),
        };
        // Add an element to the vector
        with_parameter_list_list.push(with_parameter_list_list_0_built);
        self.push(
            ASTType::WithParameterListList(with_parameter_list_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 641:
    ///
    /// WithParameterListList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter_list_list_1_built = Vec::new();
        self.push(
            ASTType::WithParameterListList(with_parameter_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 642:
    ///
    /// WithParameterListOpt /* Option<T>::Some */: Comma;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_list_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let with_parameter_list_opt_0_built = WithParameterListOpt {
            comma: Box::new(comma),
        };
        self.push(
            ASTType::WithParameterListOpt(Some(Box::new(with_parameter_list_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 643:
    ///
    /// WithParameterListOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_list_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::WithParameterListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 644:
    ///
    /// WithParameterGroup: WithParameterGroupList /* Vec */ WithParameterGroupGroup;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_group(
        &mut self,
        _with_parameter_group_list: &ParseTreeType<'t>,
        _with_parameter_group_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter_group_group = pop_item!(
            self,
            with_parameter_group_group,
            WithParameterGroupGroup,
            context
        );
        let with_parameter_group_list = pop_and_reverse_item!(
            self,
            with_parameter_group_list,
            WithParameterGroupList,
            context
        );
        let with_parameter_group_built = WithParameterGroup {
            with_parameter_group_list,
            with_parameter_group_group: Box::new(with_parameter_group_group),
        };
        // Calling user action here
        self.user_grammar
            .with_parameter_group(&with_parameter_group_built)?;
        self.push(
            ASTType::WithParameterGroup(with_parameter_group_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 645:
    ///
    /// WithParameterGroupGroup: LBrace WithParameterList RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_group_group_0(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _with_parameter_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let with_parameter_list = pop_item!(self, with_parameter_list, WithParameterList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let with_parameter_group_group_0_built =
            WithParameterGroupGroupLBraceWithParameterListRBrace {
                l_brace: Box::new(l_brace),
                with_parameter_list: Box::new(with_parameter_list),
                r_brace: Box::new(r_brace),
            };
        let with_parameter_group_group_0_built =
            WithParameterGroupGroup::LBraceWithParameterListRBrace(
                with_parameter_group_group_0_built,
            );
        self.push(
            ASTType::WithParameterGroupGroup(with_parameter_group_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 646:
    ///
    /// WithParameterGroupGroup: WithParameterItem;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_group_group_1(
        &mut self,
        _with_parameter_item: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter_item = pop_item!(self, with_parameter_item, WithParameterItem, context);
        let with_parameter_group_group_1_built = WithParameterGroupGroupWithParameterItem {
            with_parameter_item: Box::new(with_parameter_item),
        };
        let with_parameter_group_group_1_built =
            WithParameterGroupGroup::WithParameterItem(with_parameter_group_group_1_built);
        self.push(
            ASTType::WithParameterGroupGroup(with_parameter_group_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 647:
    ///
    /// WithParameterGroupList /* Vec<T>::Push */: Attribute WithParameterGroupList;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_group_list_0(
        &mut self,
        _attribute: &ParseTreeType<'t>,
        _with_parameter_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut with_parameter_group_list = pop_item!(
            self,
            with_parameter_group_list,
            WithParameterGroupList,
            context
        );
        let attribute = pop_item!(self, attribute, Attribute, context);
        let with_parameter_group_list_0_built = WithParameterGroupList {
            attribute: Box::new(attribute),
        };
        // Add an element to the vector
        with_parameter_group_list.push(with_parameter_group_list_0_built);
        self.push(
            ASTType::WithParameterGroupList(with_parameter_group_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 648:
    ///
    /// WithParameterGroupList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter_group_list_1_built = Vec::new();
        self.push(
            ASTType::WithParameterGroupList(with_parameter_group_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 649:
    ///
    /// WithParameterItem: WithParameterItemGroup Identifier Colon WithParameterItemGroup0;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_item(
        &mut self,
        _with_parameter_item_group: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _with_parameter_item_group0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter_item_group0 = pop_item!(
            self,
            with_parameter_item_group0,
            WithParameterItemGroup0,
            context
        );
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let with_parameter_item_group = pop_item!(
            self,
            with_parameter_item_group,
            WithParameterItemGroup,
            context
        );
        let with_parameter_item_built = WithParameterItem {
            with_parameter_item_group: Box::new(with_parameter_item_group),
            identifier: Box::new(identifier),
            colon: Box::new(colon),
            with_parameter_item_group0: Box::new(with_parameter_item_group0),
        };
        // Calling user action here
        self.user_grammar
            .with_parameter_item(&with_parameter_item_built)?;
        self.push(
            ASTType::WithParameterItem(with_parameter_item_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 650:
    ///
    /// WithParameterItemGroup0: ArrayType Equ Expression;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_item_group0_0(
        &mut self,
        _array_type: &ParseTreeType<'t>,
        _equ: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let equ = pop_item!(self, equ, Equ, context);
        let array_type = pop_item!(self, array_type, ArrayType, context);
        let with_parameter_item_group0_0_built = WithParameterItemGroup0ArrayTypeEquExpression {
            array_type: Box::new(array_type),
            equ: Box::new(equ),
            expression: Box::new(expression),
        };
        let with_parameter_item_group0_0_built =
            WithParameterItemGroup0::ArrayTypeEquExpression(with_parameter_item_group0_0_built);
        self.push(
            ASTType::WithParameterItemGroup0(with_parameter_item_group0_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 651:
    ///
    /// WithParameterItemGroup0: Type Equ TypeExpression;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_item_group0_1(
        &mut self,
        _type: &ParseTreeType<'t>,
        _equ: &ParseTreeType<'t>,
        _type_expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_expression = pop_item!(self, type_expression, TypeExpression, context);
        let equ = pop_item!(self, equ, Equ, context);
        let r#type = pop_item!(self, r#type, Type, context);
        let with_parameter_item_group0_1_built = WithParameterItemGroup0TypeEquTypeExpression {
            r#type: Box::new(r#type),
            equ: Box::new(equ),
            type_expression: Box::new(type_expression),
        };
        let with_parameter_item_group0_1_built =
            WithParameterItemGroup0::TypeEquTypeExpression(with_parameter_item_group0_1_built);
        self.push(
            ASTType::WithParameterItemGroup0(with_parameter_item_group0_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 652:
    ///
    /// WithParameterItemGroup: Parameter;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_item_group_0(&mut self, _parameter: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let parameter = pop_item!(self, parameter, Parameter, context);
        let with_parameter_item_group_0_built = WithParameterItemGroupParameter {
            parameter: Box::new(parameter),
        };
        let with_parameter_item_group_0_built =
            WithParameterItemGroup::Parameter(with_parameter_item_group_0_built);
        self.push(
            ASTType::WithParameterItemGroup(with_parameter_item_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 653:
    ///
    /// WithParameterItemGroup: Localparam;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_item_group_1(&mut self, _localparam: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let localparam = pop_item!(self, localparam, Localparam, context);
        let with_parameter_item_group_1_built = WithParameterItemGroupLocalparam {
            localparam: Box::new(localparam),
        };
        let with_parameter_item_group_1_built =
            WithParameterItemGroup::Localparam(with_parameter_item_group_1_built);
        self.push(
            ASTType::WithParameterItemGroup(with_parameter_item_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 654:
    ///
    /// PortDeclaration: LParen PortDeclarationOpt /* Option */ RParen;
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration(
        &mut self,
        _l_paren: &ParseTreeType<'t>,
        _port_declaration_opt: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let port_declaration_opt =
            pop_item!(self, port_declaration_opt, PortDeclarationOpt, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let port_declaration_built = PortDeclaration {
            l_paren: Box::new(l_paren),
            port_declaration_opt,
            r_paren: Box::new(r_paren),
        };
        // Calling user action here
        self.user_grammar
            .port_declaration(&port_declaration_built)?;
        self.push(ASTType::PortDeclaration(port_declaration_built), context);
        Ok(())
    }

    /// Semantic action for production 655:
    ///
    /// PortDeclarationOpt /* Option<T>::Some */: PortDeclarationList;
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_opt_0(&mut self, _port_declaration_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let port_declaration_list =
            pop_item!(self, port_declaration_list, PortDeclarationList, context);
        let port_declaration_opt_0_built = PortDeclarationOpt {
            port_declaration_list: Box::new(port_declaration_list),
        };
        self.push(
            ASTType::PortDeclarationOpt(Some(Box::new(port_declaration_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 656:
    ///
    /// PortDeclarationOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::PortDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 657:
    ///
    /// PortDeclarationList: PortDeclarationGroup PortDeclarationListList /* Vec */ PortDeclarationListOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_list(
        &mut self,
        _port_declaration_group: &ParseTreeType<'t>,
        _port_declaration_list_list: &ParseTreeType<'t>,
        _port_declaration_list_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let port_declaration_list_opt = pop_item!(
            self,
            port_declaration_list_opt,
            PortDeclarationListOpt,
            context
        );
        let port_declaration_list_list = pop_and_reverse_item!(
            self,
            port_declaration_list_list,
            PortDeclarationListList,
            context
        );
        let port_declaration_group =
            pop_item!(self, port_declaration_group, PortDeclarationGroup, context);
        let port_declaration_list_built = PortDeclarationList {
            port_declaration_group: Box::new(port_declaration_group),
            port_declaration_list_list,
            port_declaration_list_opt,
        };
        // Calling user action here
        self.user_grammar
            .port_declaration_list(&port_declaration_list_built)?;
        self.push(
            ASTType::PortDeclarationList(port_declaration_list_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 658:
    ///
    /// PortDeclarationListList /* Vec<T>::Push */: Comma PortDeclarationGroup PortDeclarationListList;
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _port_declaration_group: &ParseTreeType<'t>,
        _port_declaration_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut port_declaration_list_list = pop_item!(
            self,
            port_declaration_list_list,
            PortDeclarationListList,
            context
        );
        let port_declaration_group =
            pop_item!(self, port_declaration_group, PortDeclarationGroup, context);
        let comma = pop_item!(self, comma, Comma, context);
        let port_declaration_list_list_0_built = PortDeclarationListList {
            port_declaration_group: Box::new(port_declaration_group),
            comma: Box::new(comma),
        };
        // Add an element to the vector
        port_declaration_list_list.push(port_declaration_list_list_0_built);
        self.push(
            ASTType::PortDeclarationListList(port_declaration_list_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 659:
    ///
    /// PortDeclarationListList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let port_declaration_list_list_1_built = Vec::new();
        self.push(
            ASTType::PortDeclarationListList(port_declaration_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 660:
    ///
    /// PortDeclarationListOpt /* Option<T>::Some */: Comma;
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_list_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let port_declaration_list_opt_0_built = PortDeclarationListOpt {
            comma: Box::new(comma),
        };
        self.push(
            ASTType::PortDeclarationListOpt(Some(Box::new(port_declaration_list_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 661:
    ///
    /// PortDeclarationListOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_list_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::PortDeclarationListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 662:
    ///
    /// PortDeclarationGroup: PortDeclarationGroupList /* Vec */ PortDeclarationGroupGroup;
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_group(
        &mut self,
        _port_declaration_group_list: &ParseTreeType<'t>,
        _port_declaration_group_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let port_declaration_group_group = pop_item!(
            self,
            port_declaration_group_group,
            PortDeclarationGroupGroup,
            context
        );
        let port_declaration_group_list = pop_and_reverse_item!(
            self,
            port_declaration_group_list,
            PortDeclarationGroupList,
            context
        );
        let port_declaration_group_built = PortDeclarationGroup {
            port_declaration_group_list,
            port_declaration_group_group: Box::new(port_declaration_group_group),
        };
        // Calling user action here
        self.user_grammar
            .port_declaration_group(&port_declaration_group_built)?;
        self.push(
            ASTType::PortDeclarationGroup(port_declaration_group_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 663:
    ///
    /// PortDeclarationGroupGroup: LBrace PortDeclarationList RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_group_group_0(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _port_declaration_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let port_declaration_list =
            pop_item!(self, port_declaration_list, PortDeclarationList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let port_declaration_group_group_0_built =
            PortDeclarationGroupGroupLBracePortDeclarationListRBrace {
                l_brace: Box::new(l_brace),
                port_declaration_list: Box::new(port_declaration_list),
                r_brace: Box::new(r_brace),
            };
        let port_declaration_group_group_0_built =
            PortDeclarationGroupGroup::LBracePortDeclarationListRBrace(
                port_declaration_group_group_0_built,
            );
        self.push(
            ASTType::PortDeclarationGroupGroup(port_declaration_group_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 664:
    ///
    /// PortDeclarationGroupGroup: PortDeclarationItem;
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_group_group_1(
        &mut self,
        _port_declaration_item: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let port_declaration_item =
            pop_item!(self, port_declaration_item, PortDeclarationItem, context);
        let port_declaration_group_group_1_built = PortDeclarationGroupGroupPortDeclarationItem {
            port_declaration_item: Box::new(port_declaration_item),
        };
        let port_declaration_group_group_1_built =
            PortDeclarationGroupGroup::PortDeclarationItem(port_declaration_group_group_1_built);
        self.push(
            ASTType::PortDeclarationGroupGroup(port_declaration_group_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 665:
    ///
    /// PortDeclarationGroupList /* Vec<T>::Push */: Attribute PortDeclarationGroupList;
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_group_list_0(
        &mut self,
        _attribute: &ParseTreeType<'t>,
        _port_declaration_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut port_declaration_group_list = pop_item!(
            self,
            port_declaration_group_list,
            PortDeclarationGroupList,
            context
        );
        let attribute = pop_item!(self, attribute, Attribute, context);
        let port_declaration_group_list_0_built = PortDeclarationGroupList {
            attribute: Box::new(attribute),
        };
        // Add an element to the vector
        port_declaration_group_list.push(port_declaration_group_list_0_built);
        self.push(
            ASTType::PortDeclarationGroupList(port_declaration_group_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 666:
    ///
    /// PortDeclarationGroupList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let port_declaration_group_list_1_built = Vec::new();
        self.push(
            ASTType::PortDeclarationGroupList(port_declaration_group_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 667:
    ///
    /// PortDeclarationItem: Identifier Colon PortDeclarationItemGroup;
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_item(
        &mut self,
        _identifier: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _port_declaration_item_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let port_declaration_item_group = pop_item!(
            self,
            port_declaration_item_group,
            PortDeclarationItemGroup,
            context
        );
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let port_declaration_item_built = PortDeclarationItem {
            identifier: Box::new(identifier),
            colon: Box::new(colon),
            port_declaration_item_group: Box::new(port_declaration_item_group),
        };
        // Calling user action here
        self.user_grammar
            .port_declaration_item(&port_declaration_item_built)?;
        self.push(
            ASTType::PortDeclarationItem(port_declaration_item_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 668:
    ///
    /// PortDeclarationItemGroup: Direction ArrayType;
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_item_group_0(
        &mut self,
        _direction: &ParseTreeType<'t>,
        _array_type: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_type = pop_item!(self, array_type, ArrayType, context);
        let direction = pop_item!(self, direction, Direction, context);
        let port_declaration_item_group_0_built = PortDeclarationItemGroupDirectionArrayType {
            direction: Box::new(direction),
            array_type: Box::new(array_type),
        };
        let port_declaration_item_group_0_built =
            PortDeclarationItemGroup::DirectionArrayType(port_declaration_item_group_0_built);
        self.push(
            ASTType::PortDeclarationItemGroup(port_declaration_item_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 669:
    ///
    /// PortDeclarationItemGroup: Interface PortDeclarationItemOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_item_group_1(
        &mut self,
        _interface: &ParseTreeType<'t>,
        _port_declaration_item_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let port_declaration_item_opt = pop_item!(
            self,
            port_declaration_item_opt,
            PortDeclarationItemOpt,
            context
        );
        let interface = pop_item!(self, interface, Interface, context);
        let port_declaration_item_group_1_built =
            PortDeclarationItemGroupInterfacePortDeclarationItemOpt {
                interface: Box::new(interface),
                port_declaration_item_opt,
            };
        let port_declaration_item_group_1_built =
            PortDeclarationItemGroup::InterfacePortDeclarationItemOpt(
                port_declaration_item_group_1_built,
            );
        self.push(
            ASTType::PortDeclarationItemGroup(port_declaration_item_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 670:
    ///
    /// PortDeclarationItemOpt /* Option<T>::Some */: Array;
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_item_opt_0(&mut self, _array: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array = pop_item!(self, array, Array, context);
        let port_declaration_item_opt_0_built = PortDeclarationItemOpt {
            array: Box::new(array),
        };
        self.push(
            ASTType::PortDeclarationItemOpt(Some(Box::new(port_declaration_item_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 671:
    ///
    /// PortDeclarationItemOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_item_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::PortDeclarationItemOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 672:
    ///
    /// Direction: Input;
    ///
    #[parol_runtime::function_name::named]
    fn direction_0(&mut self, _input: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let input = pop_item!(self, input, Input, context);
        let direction_0_built = DirectionInput {
            input: Box::new(input),
        };
        let direction_0_built = Direction::Input(direction_0_built);
        // Calling user action here
        self.user_grammar.direction(&direction_0_built)?;
        self.push(ASTType::Direction(direction_0_built), context);
        Ok(())
    }

    /// Semantic action for production 673:
    ///
    /// Direction: Output;
    ///
    #[parol_runtime::function_name::named]
    fn direction_1(&mut self, _output: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let output = pop_item!(self, output, Output, context);
        let direction_1_built = DirectionOutput {
            output: Box::new(output),
        };
        let direction_1_built = Direction::Output(direction_1_built);
        // Calling user action here
        self.user_grammar.direction(&direction_1_built)?;
        self.push(ASTType::Direction(direction_1_built), context);
        Ok(())
    }

    /// Semantic action for production 674:
    ///
    /// Direction: Inout;
    ///
    #[parol_runtime::function_name::named]
    fn direction_2(&mut self, _inout: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inout = pop_item!(self, inout, Inout, context);
        let direction_2_built = DirectionInout {
            inout: Box::new(inout),
        };
        let direction_2_built = Direction::Inout(direction_2_built);
        // Calling user action here
        self.user_grammar.direction(&direction_2_built)?;
        self.push(ASTType::Direction(direction_2_built), context);
        Ok(())
    }

    /// Semantic action for production 675:
    ///
    /// Direction: Ref;
    ///
    #[parol_runtime::function_name::named]
    fn direction_3(&mut self, _ref: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#ref = pop_item!(self, r#ref, Ref, context);
        let direction_3_built = DirectionRef {
            r#ref: Box::new(r#ref),
        };
        let direction_3_built = Direction::Ref(direction_3_built);
        // Calling user action here
        self.user_grammar.direction(&direction_3_built)?;
        self.push(ASTType::Direction(direction_3_built), context);
        Ok(())
    }

    /// Semantic action for production 676:
    ///
    /// Direction: Modport;
    ///
    #[parol_runtime::function_name::named]
    fn direction_4(&mut self, _modport: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport = pop_item!(self, modport, Modport, context);
        let direction_4_built = DirectionModport {
            modport: Box::new(modport),
        };
        let direction_4_built = Direction::Modport(direction_4_built);
        // Calling user action here
        self.user_grammar.direction(&direction_4_built)?;
        self.push(ASTType::Direction(direction_4_built), context);
        Ok(())
    }

    /// Semantic action for production 677:
    ///
    /// FunctionDeclaration: Function Identifier FunctionDeclarationOpt /* Option */ FunctionDeclarationOpt0 /* Option */ MinusGT ScalarType LBrace FunctionDeclarationList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn function_declaration(
        &mut self,
        _function: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _function_declaration_opt: &ParseTreeType<'t>,
        _function_declaration_opt0: &ParseTreeType<'t>,
        _minus_g_t: &ParseTreeType<'t>,
        _scalar_type: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _function_declaration_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let function_declaration_list = pop_and_reverse_item!(
            self,
            function_declaration_list,
            FunctionDeclarationList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let scalar_type = pop_item!(self, scalar_type, ScalarType, context);
        let minus_g_t = pop_item!(self, minus_g_t, MinusGT, context);
        let function_declaration_opt0 = pop_item!(
            self,
            function_declaration_opt0,
            FunctionDeclarationOpt0,
            context
        );
        let function_declaration_opt = pop_item!(
            self,
            function_declaration_opt,
            FunctionDeclarationOpt,
            context
        );
        let identifier = pop_item!(self, identifier, Identifier, context);
        let function = pop_item!(self, function, Function, context);
        let function_declaration_built = FunctionDeclaration {
            function: Box::new(function),
            identifier: Box::new(identifier),
            function_declaration_opt,
            function_declaration_opt0,
            minus_g_t: Box::new(minus_g_t),
            scalar_type: Box::new(scalar_type),
            l_brace: Box::new(l_brace),
            function_declaration_list,
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar
            .function_declaration(&function_declaration_built)?;
        self.push(
            ASTType::FunctionDeclaration(function_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 678:
    ///
    /// FunctionDeclarationList /* Vec<T>::Push */: FunctionItem FunctionDeclarationList;
    ///
    #[parol_runtime::function_name::named]
    fn function_declaration_list_0(
        &mut self,
        _function_item: &ParseTreeType<'t>,
        _function_declaration_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut function_declaration_list = pop_item!(
            self,
            function_declaration_list,
            FunctionDeclarationList,
            context
        );
        let function_item = pop_item!(self, function_item, FunctionItem, context);
        let function_declaration_list_0_built = FunctionDeclarationList {
            function_item: Box::new(function_item),
        };
        // Add an element to the vector
        function_declaration_list.push(function_declaration_list_0_built);
        self.push(
            ASTType::FunctionDeclarationList(function_declaration_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 679:
    ///
    /// FunctionDeclarationList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn function_declaration_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_declaration_list_1_built = Vec::new();
        self.push(
            ASTType::FunctionDeclarationList(function_declaration_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 680:
    ///
    /// FunctionDeclarationOpt0 /* Option<T>::Some */: PortDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn function_declaration_opt0_0(&mut self, _port_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let port_declaration = pop_item!(self, port_declaration, PortDeclaration, context);
        let function_declaration_opt0_0_built = FunctionDeclarationOpt0 {
            port_declaration: Box::new(port_declaration),
        };
        self.push(
            ASTType::FunctionDeclarationOpt0(Some(Box::new(function_declaration_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 681:
    ///
    /// FunctionDeclarationOpt0 /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn function_declaration_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FunctionDeclarationOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 682:
    ///
    /// FunctionDeclarationOpt /* Option<T>::Some */: WithParameter;
    ///
    #[parol_runtime::function_name::named]
    fn function_declaration_opt_0(&mut self, _with_parameter: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter = pop_item!(self, with_parameter, WithParameter, context);
        let function_declaration_opt_0_built = FunctionDeclarationOpt {
            with_parameter: Box::new(with_parameter),
        };
        self.push(
            ASTType::FunctionDeclarationOpt(Some(Box::new(function_declaration_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 683:
    ///
    /// FunctionDeclarationOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn function_declaration_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FunctionDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 684:
    ///
    /// FunctionItem: VarDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn function_item_0(&mut self, _var_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let var_declaration = pop_item!(self, var_declaration, VarDeclaration, context);
        let function_item_0_built = FunctionItemVarDeclaration {
            var_declaration: Box::new(var_declaration),
        };
        let function_item_0_built = FunctionItem::VarDeclaration(function_item_0_built);
        // Calling user action here
        self.user_grammar.function_item(&function_item_0_built)?;
        self.push(ASTType::FunctionItem(function_item_0_built), context);
        Ok(())
    }

    /// Semantic action for production 685:
    ///
    /// FunctionItem: Statement;
    ///
    #[parol_runtime::function_name::named]
    fn function_item_1(&mut self, _statement: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement = pop_item!(self, statement, Statement, context);
        let function_item_1_built = FunctionItemStatement {
            statement: Box::new(statement),
        };
        let function_item_1_built = FunctionItem::Statement(function_item_1_built);
        // Calling user action here
        self.user_grammar.function_item(&function_item_1_built)?;
        self.push(ASTType::FunctionItem(function_item_1_built), context);
        Ok(())
    }

    /// Semantic action for production 686:
    ///
    /// ImportDeclaration: Import Identifier ColonColon ImportDeclarationGroup Semicolon;
    ///
    #[parol_runtime::function_name::named]
    fn import_declaration(
        &mut self,
        _import: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _colon_colon: &ParseTreeType<'t>,
        _import_declaration_group: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let import_declaration_group = pop_item!(
            self,
            import_declaration_group,
            ImportDeclarationGroup,
            context
        );
        let colon_colon = pop_item!(self, colon_colon, ColonColon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let import = pop_item!(self, import, Import, context);
        let import_declaration_built = ImportDeclaration {
            import: Box::new(import),
            identifier: Box::new(identifier),
            colon_colon: Box::new(colon_colon),
            import_declaration_group: Box::new(import_declaration_group),
            semicolon: Box::new(semicolon),
        };
        // Calling user action here
        self.user_grammar
            .import_declaration(&import_declaration_built)?;
        self.push(
            ASTType::ImportDeclaration(import_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 687:
    ///
    /// ImportDeclarationGroup: Identifier;
    ///
    #[parol_runtime::function_name::named]
    fn import_declaration_group_0(&mut self, _identifier: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier = pop_item!(self, identifier, Identifier, context);
        let import_declaration_group_0_built = ImportDeclarationGroupIdentifier {
            identifier: Box::new(identifier),
        };
        let import_declaration_group_0_built =
            ImportDeclarationGroup::Identifier(import_declaration_group_0_built);
        self.push(
            ASTType::ImportDeclarationGroup(import_declaration_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 688:
    ///
    /// ImportDeclarationGroup: Star;
    ///
    #[parol_runtime::function_name::named]
    fn import_declaration_group_1(&mut self, _star: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let star = pop_item!(self, star, Star, context);
        let import_declaration_group_1_built = ImportDeclarationGroupStar {
            star: Box::new(star),
        };
        let import_declaration_group_1_built =
            ImportDeclarationGroup::Star(import_declaration_group_1_built);
        self.push(
            ASTType::ImportDeclarationGroup(import_declaration_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 689:
    ///
    /// ExportDeclaration: Export ExportDeclarationGroup ColonColon ExportDeclarationGroup0 Semicolon;
    ///
    #[parol_runtime::function_name::named]
    fn export_declaration(
        &mut self,
        _export: &ParseTreeType<'t>,
        _export_declaration_group: &ParseTreeType<'t>,
        _colon_colon: &ParseTreeType<'t>,
        _export_declaration_group0: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let export_declaration_group0 = pop_item!(
            self,
            export_declaration_group0,
            ExportDeclarationGroup0,
            context
        );
        let colon_colon = pop_item!(self, colon_colon, ColonColon, context);
        let export_declaration_group = pop_item!(
            self,
            export_declaration_group,
            ExportDeclarationGroup,
            context
        );
        let export = pop_item!(self, export, Export, context);
        let export_declaration_built = ExportDeclaration {
            export: Box::new(export),
            export_declaration_group: Box::new(export_declaration_group),
            colon_colon: Box::new(colon_colon),
            export_declaration_group0: Box::new(export_declaration_group0),
            semicolon: Box::new(semicolon),
        };
        // Calling user action here
        self.user_grammar
            .export_declaration(&export_declaration_built)?;
        self.push(
            ASTType::ExportDeclaration(export_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 690:
    ///
    /// ExportDeclarationGroup0: Identifier;
    ///
    #[parol_runtime::function_name::named]
    fn export_declaration_group0_0(&mut self, _identifier: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier = pop_item!(self, identifier, Identifier, context);
        let export_declaration_group0_0_built = ExportDeclarationGroup0Identifier {
            identifier: Box::new(identifier),
        };
        let export_declaration_group0_0_built =
            ExportDeclarationGroup0::Identifier(export_declaration_group0_0_built);
        self.push(
            ASTType::ExportDeclarationGroup0(export_declaration_group0_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 691:
    ///
    /// ExportDeclarationGroup0: Star;
    ///
    #[parol_runtime::function_name::named]
    fn export_declaration_group0_1(&mut self, _star: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let star = pop_item!(self, star, Star, context);
        let export_declaration_group0_1_built = ExportDeclarationGroup0Star {
            star: Box::new(star),
        };
        let export_declaration_group0_1_built =
            ExportDeclarationGroup0::Star(export_declaration_group0_1_built);
        self.push(
            ASTType::ExportDeclarationGroup0(export_declaration_group0_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 692:
    ///
    /// ExportDeclarationGroup: Identifier;
    ///
    #[parol_runtime::function_name::named]
    fn export_declaration_group_0(&mut self, _identifier: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier = pop_item!(self, identifier, Identifier, context);
        let export_declaration_group_0_built = ExportDeclarationGroupIdentifier {
            identifier: Box::new(identifier),
        };
        let export_declaration_group_0_built =
            ExportDeclarationGroup::Identifier(export_declaration_group_0_built);
        self.push(
            ASTType::ExportDeclarationGroup(export_declaration_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 693:
    ///
    /// ExportDeclarationGroup: Star;
    ///
    #[parol_runtime::function_name::named]
    fn export_declaration_group_1(&mut self, _star: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let star = pop_item!(self, star, Star, context);
        let export_declaration_group_1_built = ExportDeclarationGroupStar {
            star: Box::new(star),
        };
        let export_declaration_group_1_built =
            ExportDeclarationGroup::Star(export_declaration_group_1_built);
        self.push(
            ASTType::ExportDeclarationGroup(export_declaration_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 694:
    ///
    /// ModuleDeclaration: Module Identifier ModuleDeclarationOpt /* Option */ ModuleDeclarationOpt0 /* Option */ LBrace ModuleDeclarationList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration(
        &mut self,
        _module: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _module_declaration_opt: &ParseTreeType<'t>,
        _module_declaration_opt0: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _module_declaration_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let module_declaration_list = pop_and_reverse_item!(
            self,
            module_declaration_list,
            ModuleDeclarationList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let module_declaration_opt0 = pop_item!(
            self,
            module_declaration_opt0,
            ModuleDeclarationOpt0,
            context
        );
        let module_declaration_opt =
            pop_item!(self, module_declaration_opt, ModuleDeclarationOpt, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let module = pop_item!(self, module, Module, context);
        let module_declaration_built = ModuleDeclaration {
            module: Box::new(module),
            identifier: Box::new(identifier),
            module_declaration_opt,
            module_declaration_opt0,
            l_brace: Box::new(l_brace),
            module_declaration_list,
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar
            .module_declaration(&module_declaration_built)?;
        self.push(
            ASTType::ModuleDeclaration(module_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 695:
    ///
    /// ModuleDeclarationList /* Vec<T>::Push */: ModuleGroup ModuleDeclarationList;
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_list_0(
        &mut self,
        _module_group: &ParseTreeType<'t>,
        _module_declaration_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut module_declaration_list = pop_item!(
            self,
            module_declaration_list,
            ModuleDeclarationList,
            context
        );
        let module_group = pop_item!(self, module_group, ModuleGroup, context);
        let module_declaration_list_0_built = ModuleDeclarationList {
            module_group: Box::new(module_group),
        };
        // Add an element to the vector
        module_declaration_list.push(module_declaration_list_0_built);
        self.push(
            ASTType::ModuleDeclarationList(module_declaration_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 696:
    ///
    /// ModuleDeclarationList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_declaration_list_1_built = Vec::new();
        self.push(
            ASTType::ModuleDeclarationList(module_declaration_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 697:
    ///
    /// ModuleDeclarationOpt0 /* Option<T>::Some */: PortDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_opt0_0(&mut self, _port_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let port_declaration = pop_item!(self, port_declaration, PortDeclaration, context);
        let module_declaration_opt0_0_built = ModuleDeclarationOpt0 {
            port_declaration: Box::new(port_declaration),
        };
        self.push(
            ASTType::ModuleDeclarationOpt0(Some(Box::new(module_declaration_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 698:
    ///
    /// ModuleDeclarationOpt0 /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ModuleDeclarationOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 699:
    ///
    /// ModuleDeclarationOpt /* Option<T>::Some */: WithParameter;
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_opt_0(&mut self, _with_parameter: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter = pop_item!(self, with_parameter, WithParameter, context);
        let module_declaration_opt_0_built = ModuleDeclarationOpt {
            with_parameter: Box::new(with_parameter),
        };
        self.push(
            ASTType::ModuleDeclarationOpt(Some(Box::new(module_declaration_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 700:
    ///
    /// ModuleDeclarationOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ModuleDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 701:
    ///
    /// ModuleIfDeclaration: If Expression ModuleNamedBlock ModuleIfDeclarationList /* Vec */ ModuleIfDeclarationOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn module_if_declaration(
        &mut self,
        _if: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _module_named_block: &ParseTreeType<'t>,
        _module_if_declaration_list: &ParseTreeType<'t>,
        _module_if_declaration_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_if_declaration_opt = pop_item!(
            self,
            module_if_declaration_opt,
            ModuleIfDeclarationOpt,
            context
        );
        let module_if_declaration_list = pop_and_reverse_item!(
            self,
            module_if_declaration_list,
            ModuleIfDeclarationList,
            context
        );
        let module_named_block = pop_item!(self, module_named_block, ModuleNamedBlock, context);
        let expression = pop_item!(self, expression, Expression, context);
        let r#if = pop_item!(self, r#if, If, context);
        let module_if_declaration_built = ModuleIfDeclaration {
            r#if: Box::new(r#if),
            expression: Box::new(expression),
            module_named_block: Box::new(module_named_block),
            module_if_declaration_list,
            module_if_declaration_opt,
        };
        // Calling user action here
        self.user_grammar
            .module_if_declaration(&module_if_declaration_built)?;
        self.push(
            ASTType::ModuleIfDeclaration(module_if_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 702:
    ///
    /// ModuleIfDeclarationList /* Vec<T>::Push */: Else If Expression ModuleOptionalNamedBlock ModuleIfDeclarationList;
    ///
    #[parol_runtime::function_name::named]
    fn module_if_declaration_list_0(
        &mut self,
        _else: &ParseTreeType<'t>,
        _if: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _module_optional_named_block: &ParseTreeType<'t>,
        _module_if_declaration_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut module_if_declaration_list = pop_item!(
            self,
            module_if_declaration_list,
            ModuleIfDeclarationList,
            context
        );
        let module_optional_named_block = pop_item!(
            self,
            module_optional_named_block,
            ModuleOptionalNamedBlock,
            context
        );
        let expression = pop_item!(self, expression, Expression, context);
        let r#if = pop_item!(self, r#if, If, context);
        let r#else = pop_item!(self, r#else, Else, context);
        let module_if_declaration_list_0_built = ModuleIfDeclarationList {
            module_optional_named_block: Box::new(module_optional_named_block),
            expression: Box::new(expression),
            r#if: Box::new(r#if),
            r#else: Box::new(r#else),
        };
        // Add an element to the vector
        module_if_declaration_list.push(module_if_declaration_list_0_built);
        self.push(
            ASTType::ModuleIfDeclarationList(module_if_declaration_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 703:
    ///
    /// ModuleIfDeclarationList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_if_declaration_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_if_declaration_list_1_built = Vec::new();
        self.push(
            ASTType::ModuleIfDeclarationList(module_if_declaration_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 704:
    ///
    /// ModuleIfDeclarationOpt /* Option<T>::Some */: Else ModuleOptionalNamedBlock;
    ///
    #[parol_runtime::function_name::named]
    fn module_if_declaration_opt_0(
        &mut self,
        _else: &ParseTreeType<'t>,
        _module_optional_named_block: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_optional_named_block = pop_item!(
            self,
            module_optional_named_block,
            ModuleOptionalNamedBlock,
            context
        );
        let r#else = pop_item!(self, r#else, Else, context);
        let module_if_declaration_opt_0_built = ModuleIfDeclarationOpt {
            r#else: Box::new(r#else),
            module_optional_named_block: Box::new(module_optional_named_block),
        };
        self.push(
            ASTType::ModuleIfDeclarationOpt(Some(Box::new(module_if_declaration_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 705:
    ///
    /// ModuleIfDeclarationOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_if_declaration_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ModuleIfDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 706:
    ///
    /// ModuleForDeclaration: For Identifier In Range ModuleForDeclarationOpt /* Option */ ModuleNamedBlock;
    ///
    #[parol_runtime::function_name::named]
    fn module_for_declaration(
        &mut self,
        _for: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _in: &ParseTreeType<'t>,
        _range: &ParseTreeType<'t>,
        _module_for_declaration_opt: &ParseTreeType<'t>,
        _module_named_block: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_named_block = pop_item!(self, module_named_block, ModuleNamedBlock, context);
        let module_for_declaration_opt = pop_item!(
            self,
            module_for_declaration_opt,
            ModuleForDeclarationOpt,
            context
        );
        let range = pop_item!(self, range, Range, context);
        let r#in = pop_item!(self, r#in, In, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let r#for = pop_item!(self, r#for, For, context);
        let module_for_declaration_built = ModuleForDeclaration {
            r#for: Box::new(r#for),
            identifier: Box::new(identifier),
            r#in: Box::new(r#in),
            range: Box::new(range),
            module_for_declaration_opt,
            module_named_block: Box::new(module_named_block),
        };
        // Calling user action here
        self.user_grammar
            .module_for_declaration(&module_for_declaration_built)?;
        self.push(
            ASTType::ModuleForDeclaration(module_for_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 707:
    ///
    /// ModuleForDeclarationOpt /* Option<T>::Some */: Step AssignmentOperator Expression;
    ///
    #[parol_runtime::function_name::named]
    fn module_for_declaration_opt_0(
        &mut self,
        _step: &ParseTreeType<'t>,
        _assignment_operator: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let assignment_operator = pop_item!(self, assignment_operator, AssignmentOperator, context);
        let step = pop_item!(self, step, Step, context);
        let module_for_declaration_opt_0_built = ModuleForDeclarationOpt {
            step: Box::new(step),
            assignment_operator: Box::new(assignment_operator),
            expression: Box::new(expression),
        };
        self.push(
            ASTType::ModuleForDeclarationOpt(Some(Box::new(module_for_declaration_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 708:
    ///
    /// ModuleForDeclarationOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_for_declaration_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ModuleForDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 709:
    ///
    /// ModuleNamedBlock: Colon Identifier LBrace ModuleNamedBlockList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn module_named_block(
        &mut self,
        _colon: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _module_named_block_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let module_named_block_list =
            pop_and_reverse_item!(self, module_named_block_list, ModuleNamedBlockList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let colon = pop_item!(self, colon, Colon, context);
        let module_named_block_built = ModuleNamedBlock {
            colon: Box::new(colon),
            identifier: Box::new(identifier),
            l_brace: Box::new(l_brace),
            module_named_block_list,
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar
            .module_named_block(&module_named_block_built)?;
        self.push(ASTType::ModuleNamedBlock(module_named_block_built), context);
        Ok(())
    }

    /// Semantic action for production 710:
    ///
    /// ModuleNamedBlockList /* Vec<T>::Push */: ModuleGroup ModuleNamedBlockList;
    ///
    #[parol_runtime::function_name::named]
    fn module_named_block_list_0(
        &mut self,
        _module_group: &ParseTreeType<'t>,
        _module_named_block_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut module_named_block_list =
            pop_item!(self, module_named_block_list, ModuleNamedBlockList, context);
        let module_group = pop_item!(self, module_group, ModuleGroup, context);
        let module_named_block_list_0_built = ModuleNamedBlockList {
            module_group: Box::new(module_group),
        };
        // Add an element to the vector
        module_named_block_list.push(module_named_block_list_0_built);
        self.push(
            ASTType::ModuleNamedBlockList(module_named_block_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 711:
    ///
    /// ModuleNamedBlockList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_named_block_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_named_block_list_1_built = Vec::new();
        self.push(
            ASTType::ModuleNamedBlockList(module_named_block_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 712:
    ///
    /// ModuleOptionalNamedBlock: ModuleOptionalNamedBlockOpt /* Option */ LBrace ModuleOptionalNamedBlockList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn module_optional_named_block(
        &mut self,
        _module_optional_named_block_opt: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _module_optional_named_block_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let module_optional_named_block_list = pop_and_reverse_item!(
            self,
            module_optional_named_block_list,
            ModuleOptionalNamedBlockList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let module_optional_named_block_opt = pop_item!(
            self,
            module_optional_named_block_opt,
            ModuleOptionalNamedBlockOpt,
            context
        );
        let module_optional_named_block_built = ModuleOptionalNamedBlock {
            module_optional_named_block_opt,
            l_brace: Box::new(l_brace),
            module_optional_named_block_list,
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar
            .module_optional_named_block(&module_optional_named_block_built)?;
        self.push(
            ASTType::ModuleOptionalNamedBlock(module_optional_named_block_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 713:
    ///
    /// ModuleOptionalNamedBlockList /* Vec<T>::Push */: ModuleGroup ModuleOptionalNamedBlockList;
    ///
    #[parol_runtime::function_name::named]
    fn module_optional_named_block_list_0(
        &mut self,
        _module_group: &ParseTreeType<'t>,
        _module_optional_named_block_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut module_optional_named_block_list = pop_item!(
            self,
            module_optional_named_block_list,
            ModuleOptionalNamedBlockList,
            context
        );
        let module_group = pop_item!(self, module_group, ModuleGroup, context);
        let module_optional_named_block_list_0_built = ModuleOptionalNamedBlockList {
            module_group: Box::new(module_group),
        };
        // Add an element to the vector
        module_optional_named_block_list.push(module_optional_named_block_list_0_built);
        self.push(
            ASTType::ModuleOptionalNamedBlockList(module_optional_named_block_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 714:
    ///
    /// ModuleOptionalNamedBlockList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_optional_named_block_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_optional_named_block_list_1_built = Vec::new();
        self.push(
            ASTType::ModuleOptionalNamedBlockList(module_optional_named_block_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 715:
    ///
    /// ModuleOptionalNamedBlockOpt /* Option<T>::Some */: Colon Identifier;
    ///
    #[parol_runtime::function_name::named]
    fn module_optional_named_block_opt_0(
        &mut self,
        _colon: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier = pop_item!(self, identifier, Identifier, context);
        let colon = pop_item!(self, colon, Colon, context);
        let module_optional_named_block_opt_0_built = ModuleOptionalNamedBlockOpt {
            colon: Box::new(colon),
            identifier: Box::new(identifier),
        };
        self.push(
            ASTType::ModuleOptionalNamedBlockOpt(Some(Box::new(
                module_optional_named_block_opt_0_built,
            ))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 716:
    ///
    /// ModuleOptionalNamedBlockOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_optional_named_block_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ModuleOptionalNamedBlockOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 717:
    ///
    /// ModuleGroup: ModuleGroupList /* Vec */ ModuleGroupGroup;
    ///
    #[parol_runtime::function_name::named]
    fn module_group(
        &mut self,
        _module_group_list: &ParseTreeType<'t>,
        _module_group_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_group_group = pop_item!(self, module_group_group, ModuleGroupGroup, context);
        let module_group_list =
            pop_and_reverse_item!(self, module_group_list, ModuleGroupList, context);
        let module_group_built = ModuleGroup {
            module_group_list,
            module_group_group: Box::new(module_group_group),
        };
        // Calling user action here
        self.user_grammar.module_group(&module_group_built)?;
        self.push(ASTType::ModuleGroup(module_group_built), context);
        Ok(())
    }

    /// Semantic action for production 718:
    ///
    /// ModuleGroupGroup: LBrace ModuleGroupGroupList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn module_group_group_0(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _module_group_group_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let module_group_group_list =
            pop_and_reverse_item!(self, module_group_group_list, ModuleGroupGroupList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let module_group_group_0_built = ModuleGroupGroupLBraceModuleGroupGroupListRBrace {
            l_brace: Box::new(l_brace),
            module_group_group_list,
            r_brace: Box::new(r_brace),
        };
        let module_group_group_0_built =
            ModuleGroupGroup::LBraceModuleGroupGroupListRBrace(module_group_group_0_built);
        self.push(
            ASTType::ModuleGroupGroup(module_group_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 719:
    ///
    /// ModuleGroupGroupList /* Vec<T>::Push */: ModuleGroup ModuleGroupGroupList;
    ///
    #[parol_runtime::function_name::named]
    fn module_group_group_list_0(
        &mut self,
        _module_group: &ParseTreeType<'t>,
        _module_group_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut module_group_group_list =
            pop_item!(self, module_group_group_list, ModuleGroupGroupList, context);
        let module_group = pop_item!(self, module_group, ModuleGroup, context);
        let module_group_group_list_0_built = ModuleGroupGroupList {
            module_group: Box::new(module_group),
        };
        // Add an element to the vector
        module_group_group_list.push(module_group_group_list_0_built);
        self.push(
            ASTType::ModuleGroupGroupList(module_group_group_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 720:
    ///
    /// ModuleGroupGroupList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_group_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_group_group_list_1_built = Vec::new();
        self.push(
            ASTType::ModuleGroupGroupList(module_group_group_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 721:
    ///
    /// ModuleGroupGroup: ModuleItem;
    ///
    #[parol_runtime::function_name::named]
    fn module_group_group_1(&mut self, _module_item: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_item = pop_item!(self, module_item, ModuleItem, context);
        let module_group_group_1_built = ModuleGroupGroupModuleItem {
            module_item: Box::new(module_item),
        };
        let module_group_group_1_built = ModuleGroupGroup::ModuleItem(module_group_group_1_built);
        self.push(
            ASTType::ModuleGroupGroup(module_group_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 722:
    ///
    /// ModuleGroupList /* Vec<T>::Push */: Attribute ModuleGroupList;
    ///
    #[parol_runtime::function_name::named]
    fn module_group_list_0(
        &mut self,
        _attribute: &ParseTreeType<'t>,
        _module_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut module_group_list = pop_item!(self, module_group_list, ModuleGroupList, context);
        let attribute = pop_item!(self, attribute, Attribute, context);
        let module_group_list_0_built = ModuleGroupList {
            attribute: Box::new(attribute),
        };
        // Add an element to the vector
        module_group_list.push(module_group_list_0_built);
        self.push(ASTType::ModuleGroupList(module_group_list), context);
        Ok(())
    }

    /// Semantic action for production 723:
    ///
    /// ModuleGroupList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_group_list_1_built = Vec::new();
        self.push(ASTType::ModuleGroupList(module_group_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 724:
    ///
    /// ModuleItem: VarDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_0(&mut self, _var_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let var_declaration = pop_item!(self, var_declaration, VarDeclaration, context);
        let module_item_0_built = ModuleItemVarDeclaration {
            var_declaration: Box::new(var_declaration),
        };
        let module_item_0_built = ModuleItem::VarDeclaration(module_item_0_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_0_built)?;
        self.push(ASTType::ModuleItem(module_item_0_built), context);
        Ok(())
    }

    /// Semantic action for production 725:
    ///
    /// ModuleItem: InstDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_1(&mut self, _inst_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_declaration = pop_item!(self, inst_declaration, InstDeclaration, context);
        let module_item_1_built = ModuleItemInstDeclaration {
            inst_declaration: Box::new(inst_declaration),
        };
        let module_item_1_built = ModuleItem::InstDeclaration(module_item_1_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_1_built)?;
        self.push(ASTType::ModuleItem(module_item_1_built), context);
        Ok(())
    }

    /// Semantic action for production 726:
    ///
    /// ModuleItem: LocalparamDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_2(&mut self, _localparam_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let localparam_declaration =
            pop_item!(self, localparam_declaration, LocalparamDeclaration, context);
        let module_item_2_built = ModuleItemLocalparamDeclaration {
            localparam_declaration: Box::new(localparam_declaration),
        };
        let module_item_2_built = ModuleItem::LocalparamDeclaration(module_item_2_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_2_built)?;
        self.push(ASTType::ModuleItem(module_item_2_built), context);
        Ok(())
    }

    /// Semantic action for production 727:
    ///
    /// ModuleItem: AlwaysFfDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_3(&mut self, _always_ff_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_ff_declaration =
            pop_item!(self, always_ff_declaration, AlwaysFfDeclaration, context);
        let module_item_3_built = ModuleItemAlwaysFfDeclaration {
            always_ff_declaration: Box::new(always_ff_declaration),
        };
        let module_item_3_built = ModuleItem::AlwaysFfDeclaration(module_item_3_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_3_built)?;
        self.push(ASTType::ModuleItem(module_item_3_built), context);
        Ok(())
    }

    /// Semantic action for production 728:
    ///
    /// ModuleItem: AlwaysCombDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_4(&mut self, _always_comb_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_comb_declaration = pop_item!(
            self,
            always_comb_declaration,
            AlwaysCombDeclaration,
            context
        );
        let module_item_4_built = ModuleItemAlwaysCombDeclaration {
            always_comb_declaration: Box::new(always_comb_declaration),
        };
        let module_item_4_built = ModuleItem::AlwaysCombDeclaration(module_item_4_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_4_built)?;
        self.push(ASTType::ModuleItem(module_item_4_built), context);
        Ok(())
    }

    /// Semantic action for production 729:
    ///
    /// ModuleItem: AssignDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_5(&mut self, _assign_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assign_declaration = pop_item!(self, assign_declaration, AssignDeclaration, context);
        let module_item_5_built = ModuleItemAssignDeclaration {
            assign_declaration: Box::new(assign_declaration),
        };
        let module_item_5_built = ModuleItem::AssignDeclaration(module_item_5_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_5_built)?;
        self.push(ASTType::ModuleItem(module_item_5_built), context);
        Ok(())
    }

    /// Semantic action for production 730:
    ///
    /// ModuleItem: FunctionDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_6(&mut self, _function_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_declaration =
            pop_item!(self, function_declaration, FunctionDeclaration, context);
        let module_item_6_built = ModuleItemFunctionDeclaration {
            function_declaration: Box::new(function_declaration),
        };
        let module_item_6_built = ModuleItem::FunctionDeclaration(module_item_6_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_6_built)?;
        self.push(ASTType::ModuleItem(module_item_6_built), context);
        Ok(())
    }

    /// Semantic action for production 731:
    ///
    /// ModuleItem: ModuleIfDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_7(&mut self, _module_if_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_if_declaration =
            pop_item!(self, module_if_declaration, ModuleIfDeclaration, context);
        let module_item_7_built = ModuleItemModuleIfDeclaration {
            module_if_declaration: Box::new(module_if_declaration),
        };
        let module_item_7_built = ModuleItem::ModuleIfDeclaration(module_item_7_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_7_built)?;
        self.push(ASTType::ModuleItem(module_item_7_built), context);
        Ok(())
    }

    /// Semantic action for production 732:
    ///
    /// ModuleItem: ModuleForDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_8(&mut self, _module_for_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_for_declaration =
            pop_item!(self, module_for_declaration, ModuleForDeclaration, context);
        let module_item_8_built = ModuleItemModuleForDeclaration {
            module_for_declaration: Box::new(module_for_declaration),
        };
        let module_item_8_built = ModuleItem::ModuleForDeclaration(module_item_8_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_8_built)?;
        self.push(ASTType::ModuleItem(module_item_8_built), context);
        Ok(())
    }

    /// Semantic action for production 733:
    ///
    /// ModuleItem: EnumDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_9(&mut self, _enum_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enum_declaration = pop_item!(self, enum_declaration, EnumDeclaration, context);
        let module_item_9_built = ModuleItemEnumDeclaration {
            enum_declaration: Box::new(enum_declaration),
        };
        let module_item_9_built = ModuleItem::EnumDeclaration(module_item_9_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_9_built)?;
        self.push(ASTType::ModuleItem(module_item_9_built), context);
        Ok(())
    }

    /// Semantic action for production 734:
    ///
    /// ModuleItem: StructDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_10(&mut self, _struct_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let struct_declaration = pop_item!(self, struct_declaration, StructDeclaration, context);
        let module_item_10_built = ModuleItemStructDeclaration {
            struct_declaration: Box::new(struct_declaration),
        };
        let module_item_10_built = ModuleItem::StructDeclaration(module_item_10_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_10_built)?;
        self.push(ASTType::ModuleItem(module_item_10_built), context);
        Ok(())
    }

    /// Semantic action for production 735:
    ///
    /// ModuleItem: ModuleNamedBlock;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_11(&mut self, _module_named_block: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_named_block = pop_item!(self, module_named_block, ModuleNamedBlock, context);
        let module_item_11_built = ModuleItemModuleNamedBlock {
            module_named_block: Box::new(module_named_block),
        };
        let module_item_11_built = ModuleItem::ModuleNamedBlock(module_item_11_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_11_built)?;
        self.push(ASTType::ModuleItem(module_item_11_built), context);
        Ok(())
    }

    /// Semantic action for production 736:
    ///
    /// ModuleItem: ImportDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_12(&mut self, _import_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let import_declaration = pop_item!(self, import_declaration, ImportDeclaration, context);
        let module_item_12_built = ModuleItemImportDeclaration {
            import_declaration: Box::new(import_declaration),
        };
        let module_item_12_built = ModuleItem::ImportDeclaration(module_item_12_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_12_built)?;
        self.push(ASTType::ModuleItem(module_item_12_built), context);
        Ok(())
    }

    /// Semantic action for production 737:
    ///
    /// ModuleItem: InitialDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_13(&mut self, _initial_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let initial_declaration = pop_item!(self, initial_declaration, InitialDeclaration, context);
        let module_item_13_built = ModuleItemInitialDeclaration {
            initial_declaration: Box::new(initial_declaration),
        };
        let module_item_13_built = ModuleItem::InitialDeclaration(module_item_13_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_13_built)?;
        self.push(ASTType::ModuleItem(module_item_13_built), context);
        Ok(())
    }

    /// Semantic action for production 738:
    ///
    /// ModuleItem: FinalDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_14(&mut self, _final_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let final_declaration = pop_item!(self, final_declaration, FinalDeclaration, context);
        let module_item_14_built = ModuleItemFinalDeclaration {
            final_declaration: Box::new(final_declaration),
        };
        let module_item_14_built = ModuleItem::FinalDeclaration(module_item_14_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_14_built)?;
        self.push(ASTType::ModuleItem(module_item_14_built), context);
        Ok(())
    }

    /// Semantic action for production 739:
    ///
    /// InterfaceDeclaration: Interface Identifier InterfaceDeclarationOpt /* Option */ LBrace InterfaceDeclarationList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn interface_declaration(
        &mut self,
        _interface: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _interface_declaration_opt: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _interface_declaration_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let interface_declaration_list = pop_and_reverse_item!(
            self,
            interface_declaration_list,
            InterfaceDeclarationList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let interface_declaration_opt = pop_item!(
            self,
            interface_declaration_opt,
            InterfaceDeclarationOpt,
            context
        );
        let identifier = pop_item!(self, identifier, Identifier, context);
        let interface = pop_item!(self, interface, Interface, context);
        let interface_declaration_built = InterfaceDeclaration {
            interface: Box::new(interface),
            identifier: Box::new(identifier),
            interface_declaration_opt,
            l_brace: Box::new(l_brace),
            interface_declaration_list,
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar
            .interface_declaration(&interface_declaration_built)?;
        self.push(
            ASTType::InterfaceDeclaration(interface_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 740:
    ///
    /// InterfaceDeclarationList /* Vec<T>::Push */: InterfaceGroup InterfaceDeclarationList;
    ///
    #[parol_runtime::function_name::named]
    fn interface_declaration_list_0(
        &mut self,
        _interface_group: &ParseTreeType<'t>,
        _interface_declaration_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut interface_declaration_list = pop_item!(
            self,
            interface_declaration_list,
            InterfaceDeclarationList,
            context
        );
        let interface_group = pop_item!(self, interface_group, InterfaceGroup, context);
        let interface_declaration_list_0_built = InterfaceDeclarationList {
            interface_group: Box::new(interface_group),
        };
        // Add an element to the vector
        interface_declaration_list.push(interface_declaration_list_0_built);
        self.push(
            ASTType::InterfaceDeclarationList(interface_declaration_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 741:
    ///
    /// InterfaceDeclarationList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn interface_declaration_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_declaration_list_1_built = Vec::new();
        self.push(
            ASTType::InterfaceDeclarationList(interface_declaration_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 742:
    ///
    /// InterfaceDeclarationOpt /* Option<T>::Some */: WithParameter;
    ///
    #[parol_runtime::function_name::named]
    fn interface_declaration_opt_0(&mut self, _with_parameter: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter = pop_item!(self, with_parameter, WithParameter, context);
        let interface_declaration_opt_0_built = InterfaceDeclarationOpt {
            with_parameter: Box::new(with_parameter),
        };
        self.push(
            ASTType::InterfaceDeclarationOpt(Some(Box::new(interface_declaration_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 743:
    ///
    /// InterfaceDeclarationOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn interface_declaration_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InterfaceDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 744:
    ///
    /// InterfaceIfDeclaration: If Expression InterfaceNamedBlock InterfaceIfDeclarationList /* Vec */ InterfaceIfDeclarationOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn interface_if_declaration(
        &mut self,
        _if: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _interface_named_block: &ParseTreeType<'t>,
        _interface_if_declaration_list: &ParseTreeType<'t>,
        _interface_if_declaration_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_if_declaration_opt = pop_item!(
            self,
            interface_if_declaration_opt,
            InterfaceIfDeclarationOpt,
            context
        );
        let interface_if_declaration_list = pop_and_reverse_item!(
            self,
            interface_if_declaration_list,
            InterfaceIfDeclarationList,
            context
        );
        let interface_named_block =
            pop_item!(self, interface_named_block, InterfaceNamedBlock, context);
        let expression = pop_item!(self, expression, Expression, context);
        let r#if = pop_item!(self, r#if, If, context);
        let interface_if_declaration_built = InterfaceIfDeclaration {
            r#if: Box::new(r#if),
            expression: Box::new(expression),
            interface_named_block: Box::new(interface_named_block),
            interface_if_declaration_list,
            interface_if_declaration_opt,
        };
        // Calling user action here
        self.user_grammar
            .interface_if_declaration(&interface_if_declaration_built)?;
        self.push(
            ASTType::InterfaceIfDeclaration(interface_if_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 745:
    ///
    /// InterfaceIfDeclarationList /* Vec<T>::Push */: Else If Expression InterfaceOptionalNamedBlock InterfaceIfDeclarationList;
    ///
    #[parol_runtime::function_name::named]
    fn interface_if_declaration_list_0(
        &mut self,
        _else: &ParseTreeType<'t>,
        _if: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _interface_optional_named_block: &ParseTreeType<'t>,
        _interface_if_declaration_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut interface_if_declaration_list = pop_item!(
            self,
            interface_if_declaration_list,
            InterfaceIfDeclarationList,
            context
        );
        let interface_optional_named_block = pop_item!(
            self,
            interface_optional_named_block,
            InterfaceOptionalNamedBlock,
            context
        );
        let expression = pop_item!(self, expression, Expression, context);
        let r#if = pop_item!(self, r#if, If, context);
        let r#else = pop_item!(self, r#else, Else, context);
        let interface_if_declaration_list_0_built = InterfaceIfDeclarationList {
            interface_optional_named_block: Box::new(interface_optional_named_block),
            expression: Box::new(expression),
            r#if: Box::new(r#if),
            r#else: Box::new(r#else),
        };
        // Add an element to the vector
        interface_if_declaration_list.push(interface_if_declaration_list_0_built);
        self.push(
            ASTType::InterfaceIfDeclarationList(interface_if_declaration_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 746:
    ///
    /// InterfaceIfDeclarationList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn interface_if_declaration_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_if_declaration_list_1_built = Vec::new();
        self.push(
            ASTType::InterfaceIfDeclarationList(interface_if_declaration_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 747:
    ///
    /// InterfaceIfDeclarationOpt /* Option<T>::Some */: Else InterfaceOptionalNamedBlock;
    ///
    #[parol_runtime::function_name::named]
    fn interface_if_declaration_opt_0(
        &mut self,
        _else: &ParseTreeType<'t>,
        _interface_optional_named_block: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_optional_named_block = pop_item!(
            self,
            interface_optional_named_block,
            InterfaceOptionalNamedBlock,
            context
        );
        let r#else = pop_item!(self, r#else, Else, context);
        let interface_if_declaration_opt_0_built = InterfaceIfDeclarationOpt {
            r#else: Box::new(r#else),
            interface_optional_named_block: Box::new(interface_optional_named_block),
        };
        self.push(
            ASTType::InterfaceIfDeclarationOpt(Some(Box::new(
                interface_if_declaration_opt_0_built,
            ))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 748:
    ///
    /// InterfaceIfDeclarationOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn interface_if_declaration_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InterfaceIfDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 749:
    ///
    /// InterfaceForDeclaration: For Identifier In Range InterfaceForDeclarationOpt /* Option */ InterfaceNamedBlock;
    ///
    #[parol_runtime::function_name::named]
    fn interface_for_declaration(
        &mut self,
        _for: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _in: &ParseTreeType<'t>,
        _range: &ParseTreeType<'t>,
        _interface_for_declaration_opt: &ParseTreeType<'t>,
        _interface_named_block: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_named_block =
            pop_item!(self, interface_named_block, InterfaceNamedBlock, context);
        let interface_for_declaration_opt = pop_item!(
            self,
            interface_for_declaration_opt,
            InterfaceForDeclarationOpt,
            context
        );
        let range = pop_item!(self, range, Range, context);
        let r#in = pop_item!(self, r#in, In, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let r#for = pop_item!(self, r#for, For, context);
        let interface_for_declaration_built = InterfaceForDeclaration {
            r#for: Box::new(r#for),
            identifier: Box::new(identifier),
            r#in: Box::new(r#in),
            range: Box::new(range),
            interface_for_declaration_opt,
            interface_named_block: Box::new(interface_named_block),
        };
        // Calling user action here
        self.user_grammar
            .interface_for_declaration(&interface_for_declaration_built)?;
        self.push(
            ASTType::InterfaceForDeclaration(interface_for_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 750:
    ///
    /// InterfaceForDeclarationOpt /* Option<T>::Some */: Step AssignmentOperator Expression;
    ///
    #[parol_runtime::function_name::named]
    fn interface_for_declaration_opt_0(
        &mut self,
        _step: &ParseTreeType<'t>,
        _assignment_operator: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let assignment_operator = pop_item!(self, assignment_operator, AssignmentOperator, context);
        let step = pop_item!(self, step, Step, context);
        let interface_for_declaration_opt_0_built = InterfaceForDeclarationOpt {
            step: Box::new(step),
            assignment_operator: Box::new(assignment_operator),
            expression: Box::new(expression),
        };
        self.push(
            ASTType::InterfaceForDeclarationOpt(Some(Box::new(
                interface_for_declaration_opt_0_built,
            ))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 751:
    ///
    /// InterfaceForDeclarationOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn interface_for_declaration_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InterfaceForDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 752:
    ///
    /// InterfaceNamedBlock: Colon Identifier LBrace InterfaceNamedBlockList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn interface_named_block(
        &mut self,
        _colon: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _interface_named_block_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let interface_named_block_list = pop_and_reverse_item!(
            self,
            interface_named_block_list,
            InterfaceNamedBlockList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let colon = pop_item!(self, colon, Colon, context);
        let interface_named_block_built = InterfaceNamedBlock {
            colon: Box::new(colon),
            identifier: Box::new(identifier),
            l_brace: Box::new(l_brace),
            interface_named_block_list,
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar
            .interface_named_block(&interface_named_block_built)?;
        self.push(
            ASTType::InterfaceNamedBlock(interface_named_block_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 753:
    ///
    /// InterfaceNamedBlockList /* Vec<T>::Push */: InterfaceGroup InterfaceNamedBlockList;
    ///
    #[parol_runtime::function_name::named]
    fn interface_named_block_list_0(
        &mut self,
        _interface_group: &ParseTreeType<'t>,
        _interface_named_block_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut interface_named_block_list = pop_item!(
            self,
            interface_named_block_list,
            InterfaceNamedBlockList,
            context
        );
        let interface_group = pop_item!(self, interface_group, InterfaceGroup, context);
        let interface_named_block_list_0_built = InterfaceNamedBlockList {
            interface_group: Box::new(interface_group),
        };
        // Add an element to the vector
        interface_named_block_list.push(interface_named_block_list_0_built);
        self.push(
            ASTType::InterfaceNamedBlockList(interface_named_block_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 754:
    ///
    /// InterfaceNamedBlockList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn interface_named_block_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_named_block_list_1_built = Vec::new();
        self.push(
            ASTType::InterfaceNamedBlockList(interface_named_block_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 755:
    ///
    /// InterfaceOptionalNamedBlock: InterfaceOptionalNamedBlockOpt /* Option */ LBrace InterfaceOptionalNamedBlockList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn interface_optional_named_block(
        &mut self,
        _interface_optional_named_block_opt: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _interface_optional_named_block_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let interface_optional_named_block_list = pop_and_reverse_item!(
            self,
            interface_optional_named_block_list,
            InterfaceOptionalNamedBlockList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let interface_optional_named_block_opt = pop_item!(
            self,
            interface_optional_named_block_opt,
            InterfaceOptionalNamedBlockOpt,
            context
        );
        let interface_optional_named_block_built = InterfaceOptionalNamedBlock {
            interface_optional_named_block_opt,
            l_brace: Box::new(l_brace),
            interface_optional_named_block_list,
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar
            .interface_optional_named_block(&interface_optional_named_block_built)?;
        self.push(
            ASTType::InterfaceOptionalNamedBlock(interface_optional_named_block_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 756:
    ///
    /// InterfaceOptionalNamedBlockList /* Vec<T>::Push */: InterfaceGroup InterfaceOptionalNamedBlockList;
    ///
    #[parol_runtime::function_name::named]
    fn interface_optional_named_block_list_0(
        &mut self,
        _interface_group: &ParseTreeType<'t>,
        _interface_optional_named_block_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut interface_optional_named_block_list = pop_item!(
            self,
            interface_optional_named_block_list,
            InterfaceOptionalNamedBlockList,
            context
        );
        let interface_group = pop_item!(self, interface_group, InterfaceGroup, context);
        let interface_optional_named_block_list_0_built = InterfaceOptionalNamedBlockList {
            interface_group: Box::new(interface_group),
        };
        // Add an element to the vector
        interface_optional_named_block_list.push(interface_optional_named_block_list_0_built);
        self.push(
            ASTType::InterfaceOptionalNamedBlockList(interface_optional_named_block_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 757:
    ///
    /// InterfaceOptionalNamedBlockList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn interface_optional_named_block_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_optional_named_block_list_1_built = Vec::new();
        self.push(
            ASTType::InterfaceOptionalNamedBlockList(interface_optional_named_block_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 758:
    ///
    /// InterfaceOptionalNamedBlockOpt /* Option<T>::Some */: Colon Identifier;
    ///
    #[parol_runtime::function_name::named]
    fn interface_optional_named_block_opt_0(
        &mut self,
        _colon: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier = pop_item!(self, identifier, Identifier, context);
        let colon = pop_item!(self, colon, Colon, context);
        let interface_optional_named_block_opt_0_built = InterfaceOptionalNamedBlockOpt {
            colon: Box::new(colon),
            identifier: Box::new(identifier),
        };
        self.push(
            ASTType::InterfaceOptionalNamedBlockOpt(Some(Box::new(
                interface_optional_named_block_opt_0_built,
            ))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 759:
    ///
    /// InterfaceOptionalNamedBlockOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn interface_optional_named_block_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InterfaceOptionalNamedBlockOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 760:
    ///
    /// InterfaceGroup: InterfaceGroupList /* Vec */ InterfaceGroupGroup;
    ///
    #[parol_runtime::function_name::named]
    fn interface_group(
        &mut self,
        _interface_group_list: &ParseTreeType<'t>,
        _interface_group_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_group_group =
            pop_item!(self, interface_group_group, InterfaceGroupGroup, context);
        let interface_group_list =
            pop_and_reverse_item!(self, interface_group_list, InterfaceGroupList, context);
        let interface_group_built = InterfaceGroup {
            interface_group_list,
            interface_group_group: Box::new(interface_group_group),
        };
        // Calling user action here
        self.user_grammar.interface_group(&interface_group_built)?;
        self.push(ASTType::InterfaceGroup(interface_group_built), context);
        Ok(())
    }

    /// Semantic action for production 761:
    ///
    /// InterfaceGroupGroup: LBrace InterfaceGroupGroupList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn interface_group_group_0(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _interface_group_group_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let interface_group_group_list = pop_and_reverse_item!(
            self,
            interface_group_group_list,
            InterfaceGroupGroupList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let interface_group_group_0_built =
            InterfaceGroupGroupLBraceInterfaceGroupGroupListRBrace {
                l_brace: Box::new(l_brace),
                interface_group_group_list,
                r_brace: Box::new(r_brace),
            };
        let interface_group_group_0_built =
            InterfaceGroupGroup::LBraceInterfaceGroupGroupListRBrace(interface_group_group_0_built);
        self.push(
            ASTType::InterfaceGroupGroup(interface_group_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 762:
    ///
    /// InterfaceGroupGroupList /* Vec<T>::Push */: InterfaceGroup InterfaceGroupGroupList;
    ///
    #[parol_runtime::function_name::named]
    fn interface_group_group_list_0(
        &mut self,
        _interface_group: &ParseTreeType<'t>,
        _interface_group_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut interface_group_group_list = pop_item!(
            self,
            interface_group_group_list,
            InterfaceGroupGroupList,
            context
        );
        let interface_group = pop_item!(self, interface_group, InterfaceGroup, context);
        let interface_group_group_list_0_built = InterfaceGroupGroupList {
            interface_group: Box::new(interface_group),
        };
        // Add an element to the vector
        interface_group_group_list.push(interface_group_group_list_0_built);
        self.push(
            ASTType::InterfaceGroupGroupList(interface_group_group_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 763:
    ///
    /// InterfaceGroupGroupList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn interface_group_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_group_group_list_1_built = Vec::new();
        self.push(
            ASTType::InterfaceGroupGroupList(interface_group_group_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 764:
    ///
    /// InterfaceGroupGroup: InterfaceItem;
    ///
    #[parol_runtime::function_name::named]
    fn interface_group_group_1(&mut self, _interface_item: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_item = pop_item!(self, interface_item, InterfaceItem, context);
        let interface_group_group_1_built = InterfaceGroupGroupInterfaceItem {
            interface_item: Box::new(interface_item),
        };
        let interface_group_group_1_built =
            InterfaceGroupGroup::InterfaceItem(interface_group_group_1_built);
        self.push(
            ASTType::InterfaceGroupGroup(interface_group_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 765:
    ///
    /// InterfaceGroupList /* Vec<T>::Push */: Attribute InterfaceGroupList;
    ///
    #[parol_runtime::function_name::named]
    fn interface_group_list_0(
        &mut self,
        _attribute: &ParseTreeType<'t>,
        _interface_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut interface_group_list =
            pop_item!(self, interface_group_list, InterfaceGroupList, context);
        let attribute = pop_item!(self, attribute, Attribute, context);
        let interface_group_list_0_built = InterfaceGroupList {
            attribute: Box::new(attribute),
        };
        // Add an element to the vector
        interface_group_list.push(interface_group_list_0_built);
        self.push(ASTType::InterfaceGroupList(interface_group_list), context);
        Ok(())
    }

    /// Semantic action for production 766:
    ///
    /// InterfaceGroupList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn interface_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_group_list_1_built = Vec::new();
        self.push(
            ASTType::InterfaceGroupList(interface_group_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 767:
    ///
    /// InterfaceItem: VarDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn interface_item_0(&mut self, _var_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let var_declaration = pop_item!(self, var_declaration, VarDeclaration, context);
        let interface_item_0_built = InterfaceItemVarDeclaration {
            var_declaration: Box::new(var_declaration),
        };
        let interface_item_0_built = InterfaceItem::VarDeclaration(interface_item_0_built);
        // Calling user action here
        self.user_grammar.interface_item(&interface_item_0_built)?;
        self.push(ASTType::InterfaceItem(interface_item_0_built), context);
        Ok(())
    }

    /// Semantic action for production 768:
    ///
    /// InterfaceItem: LocalparamDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn interface_item_1(&mut self, _localparam_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let localparam_declaration =
            pop_item!(self, localparam_declaration, LocalparamDeclaration, context);
        let interface_item_1_built = InterfaceItemLocalparamDeclaration {
            localparam_declaration: Box::new(localparam_declaration),
        };
        let interface_item_1_built = InterfaceItem::LocalparamDeclaration(interface_item_1_built);
        // Calling user action here
        self.user_grammar.interface_item(&interface_item_1_built)?;
        self.push(ASTType::InterfaceItem(interface_item_1_built), context);
        Ok(())
    }

    /// Semantic action for production 769:
    ///
    /// InterfaceItem: ModportDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn interface_item_2(&mut self, _modport_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport_declaration = pop_item!(self, modport_declaration, ModportDeclaration, context);
        let interface_item_2_built = InterfaceItemModportDeclaration {
            modport_declaration: Box::new(modport_declaration),
        };
        let interface_item_2_built = InterfaceItem::ModportDeclaration(interface_item_2_built);
        // Calling user action here
        self.user_grammar.interface_item(&interface_item_2_built)?;
        self.push(ASTType::InterfaceItem(interface_item_2_built), context);
        Ok(())
    }

    /// Semantic action for production 770:
    ///
    /// InterfaceItem: InterfaceIfDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn interface_item_3(&mut self, _interface_if_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_if_declaration = pop_item!(
            self,
            interface_if_declaration,
            InterfaceIfDeclaration,
            context
        );
        let interface_item_3_built = InterfaceItemInterfaceIfDeclaration {
            interface_if_declaration: Box::new(interface_if_declaration),
        };
        let interface_item_3_built = InterfaceItem::InterfaceIfDeclaration(interface_item_3_built);
        // Calling user action here
        self.user_grammar.interface_item(&interface_item_3_built)?;
        self.push(ASTType::InterfaceItem(interface_item_3_built), context);
        Ok(())
    }

    /// Semantic action for production 771:
    ///
    /// InterfaceItem: InterfaceForDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn interface_item_4(&mut self, _interface_for_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_for_declaration = pop_item!(
            self,
            interface_for_declaration,
            InterfaceForDeclaration,
            context
        );
        let interface_item_4_built = InterfaceItemInterfaceForDeclaration {
            interface_for_declaration: Box::new(interface_for_declaration),
        };
        let interface_item_4_built = InterfaceItem::InterfaceForDeclaration(interface_item_4_built);
        // Calling user action here
        self.user_grammar.interface_item(&interface_item_4_built)?;
        self.push(ASTType::InterfaceItem(interface_item_4_built), context);
        Ok(())
    }

    /// Semantic action for production 772:
    ///
    /// InterfaceItem: EnumDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn interface_item_5(&mut self, _enum_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enum_declaration = pop_item!(self, enum_declaration, EnumDeclaration, context);
        let interface_item_5_built = InterfaceItemEnumDeclaration {
            enum_declaration: Box::new(enum_declaration),
        };
        let interface_item_5_built = InterfaceItem::EnumDeclaration(interface_item_5_built);
        // Calling user action here
        self.user_grammar.interface_item(&interface_item_5_built)?;
        self.push(ASTType::InterfaceItem(interface_item_5_built), context);
        Ok(())
    }

    /// Semantic action for production 773:
    ///
    /// InterfaceItem: StructDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn interface_item_6(&mut self, _struct_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let struct_declaration = pop_item!(self, struct_declaration, StructDeclaration, context);
        let interface_item_6_built = InterfaceItemStructDeclaration {
            struct_declaration: Box::new(struct_declaration),
        };
        let interface_item_6_built = InterfaceItem::StructDeclaration(interface_item_6_built);
        // Calling user action here
        self.user_grammar.interface_item(&interface_item_6_built)?;
        self.push(ASTType::InterfaceItem(interface_item_6_built), context);
        Ok(())
    }

    /// Semantic action for production 774:
    ///
    /// InterfaceItem: InterfaceNamedBlock;
    ///
    #[parol_runtime::function_name::named]
    fn interface_item_7(&mut self, _interface_named_block: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_named_block =
            pop_item!(self, interface_named_block, InterfaceNamedBlock, context);
        let interface_item_7_built = InterfaceItemInterfaceNamedBlock {
            interface_named_block: Box::new(interface_named_block),
        };
        let interface_item_7_built = InterfaceItem::InterfaceNamedBlock(interface_item_7_built);
        // Calling user action here
        self.user_grammar.interface_item(&interface_item_7_built)?;
        self.push(ASTType::InterfaceItem(interface_item_7_built), context);
        Ok(())
    }

    /// Semantic action for production 775:
    ///
    /// InterfaceItem: FunctionDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn interface_item_8(&mut self, _function_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_declaration =
            pop_item!(self, function_declaration, FunctionDeclaration, context);
        let interface_item_8_built = InterfaceItemFunctionDeclaration {
            function_declaration: Box::new(function_declaration),
        };
        let interface_item_8_built = InterfaceItem::FunctionDeclaration(interface_item_8_built);
        // Calling user action here
        self.user_grammar.interface_item(&interface_item_8_built)?;
        self.push(ASTType::InterfaceItem(interface_item_8_built), context);
        Ok(())
    }

    /// Semantic action for production 776:
    ///
    /// InterfaceItem: ImportDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn interface_item_9(&mut self, _import_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let import_declaration = pop_item!(self, import_declaration, ImportDeclaration, context);
        let interface_item_9_built = InterfaceItemImportDeclaration {
            import_declaration: Box::new(import_declaration),
        };
        let interface_item_9_built = InterfaceItem::ImportDeclaration(interface_item_9_built);
        // Calling user action here
        self.user_grammar.interface_item(&interface_item_9_built)?;
        self.push(ASTType::InterfaceItem(interface_item_9_built), context);
        Ok(())
    }

    /// Semantic action for production 777:
    ///
    /// InterfaceItem: InitialDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn interface_item_10(&mut self, _initial_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let initial_declaration = pop_item!(self, initial_declaration, InitialDeclaration, context);
        let interface_item_10_built = InterfaceItemInitialDeclaration {
            initial_declaration: Box::new(initial_declaration),
        };
        let interface_item_10_built = InterfaceItem::InitialDeclaration(interface_item_10_built);
        // Calling user action here
        self.user_grammar.interface_item(&interface_item_10_built)?;
        self.push(ASTType::InterfaceItem(interface_item_10_built), context);
        Ok(())
    }

    /// Semantic action for production 778:
    ///
    /// InterfaceItem: FinalDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn interface_item_11(&mut self, _final_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let final_declaration = pop_item!(self, final_declaration, FinalDeclaration, context);
        let interface_item_11_built = InterfaceItemFinalDeclaration {
            final_declaration: Box::new(final_declaration),
        };
        let interface_item_11_built = InterfaceItem::FinalDeclaration(interface_item_11_built);
        // Calling user action here
        self.user_grammar.interface_item(&interface_item_11_built)?;
        self.push(ASTType::InterfaceItem(interface_item_11_built), context);
        Ok(())
    }

    /// Semantic action for production 779:
    ///
    /// PackageDeclaration: Package Identifier LBrace PackageDeclarationList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn package_declaration(
        &mut self,
        _package: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _package_declaration_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let package_declaration_list = pop_and_reverse_item!(
            self,
            package_declaration_list,
            PackageDeclarationList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let package = pop_item!(self, package, Package, context);
        let package_declaration_built = PackageDeclaration {
            package: Box::new(package),
            identifier: Box::new(identifier),
            l_brace: Box::new(l_brace),
            package_declaration_list,
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar
            .package_declaration(&package_declaration_built)?;
        self.push(
            ASTType::PackageDeclaration(package_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 780:
    ///
    /// PackageDeclarationList /* Vec<T>::Push */: PackageGroup PackageDeclarationList;
    ///
    #[parol_runtime::function_name::named]
    fn package_declaration_list_0(
        &mut self,
        _package_group: &ParseTreeType<'t>,
        _package_declaration_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut package_declaration_list = pop_item!(
            self,
            package_declaration_list,
            PackageDeclarationList,
            context
        );
        let package_group = pop_item!(self, package_group, PackageGroup, context);
        let package_declaration_list_0_built = PackageDeclarationList {
            package_group: Box::new(package_group),
        };
        // Add an element to the vector
        package_declaration_list.push(package_declaration_list_0_built);
        self.push(
            ASTType::PackageDeclarationList(package_declaration_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 781:
    ///
    /// PackageDeclarationList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn package_declaration_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let package_declaration_list_1_built = Vec::new();
        self.push(
            ASTType::PackageDeclarationList(package_declaration_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 782:
    ///
    /// PackageGroup: PackageGroupList /* Vec */ PackageGroupGroup;
    ///
    #[parol_runtime::function_name::named]
    fn package_group(
        &mut self,
        _package_group_list: &ParseTreeType<'t>,
        _package_group_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let package_group_group = pop_item!(self, package_group_group, PackageGroupGroup, context);
        let package_group_list =
            pop_and_reverse_item!(self, package_group_list, PackageGroupList, context);
        let package_group_built = PackageGroup {
            package_group_list,
            package_group_group: Box::new(package_group_group),
        };
        // Calling user action here
        self.user_grammar.package_group(&package_group_built)?;
        self.push(ASTType::PackageGroup(package_group_built), context);
        Ok(())
    }

    /// Semantic action for production 783:
    ///
    /// PackageGroupGroup: LBrace PackageGroupGroupList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn package_group_group_0(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _package_group_group_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let package_group_group_list = pop_and_reverse_item!(
            self,
            package_group_group_list,
            PackageGroupGroupList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let package_group_group_0_built = PackageGroupGroupLBracePackageGroupGroupListRBrace {
            l_brace: Box::new(l_brace),
            package_group_group_list,
            r_brace: Box::new(r_brace),
        };
        let package_group_group_0_built =
            PackageGroupGroup::LBracePackageGroupGroupListRBrace(package_group_group_0_built);
        self.push(
            ASTType::PackageGroupGroup(package_group_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 784:
    ///
    /// PackageGroupGroupList /* Vec<T>::Push */: PackageGroup PackageGroupGroupList;
    ///
    #[parol_runtime::function_name::named]
    fn package_group_group_list_0(
        &mut self,
        _package_group: &ParseTreeType<'t>,
        _package_group_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut package_group_group_list = pop_item!(
            self,
            package_group_group_list,
            PackageGroupGroupList,
            context
        );
        let package_group = pop_item!(self, package_group, PackageGroup, context);
        let package_group_group_list_0_built = PackageGroupGroupList {
            package_group: Box::new(package_group),
        };
        // Add an element to the vector
        package_group_group_list.push(package_group_group_list_0_built);
        self.push(
            ASTType::PackageGroupGroupList(package_group_group_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 785:
    ///
    /// PackageGroupGroupList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn package_group_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let package_group_group_list_1_built = Vec::new();
        self.push(
            ASTType::PackageGroupGroupList(package_group_group_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 786:
    ///
    /// PackageGroupGroup: PackageItem;
    ///
    #[parol_runtime::function_name::named]
    fn package_group_group_1(&mut self, _package_item: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let package_item = pop_item!(self, package_item, PackageItem, context);
        let package_group_group_1_built = PackageGroupGroupPackageItem {
            package_item: Box::new(package_item),
        };
        let package_group_group_1_built =
            PackageGroupGroup::PackageItem(package_group_group_1_built);
        self.push(
            ASTType::PackageGroupGroup(package_group_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 787:
    ///
    /// PackageGroupList /* Vec<T>::Push */: Attribute PackageGroupList;
    ///
    #[parol_runtime::function_name::named]
    fn package_group_list_0(
        &mut self,
        _attribute: &ParseTreeType<'t>,
        _package_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut package_group_list = pop_item!(self, package_group_list, PackageGroupList, context);
        let attribute = pop_item!(self, attribute, Attribute, context);
        let package_group_list_0_built = PackageGroupList {
            attribute: Box::new(attribute),
        };
        // Add an element to the vector
        package_group_list.push(package_group_list_0_built);
        self.push(ASTType::PackageGroupList(package_group_list), context);
        Ok(())
    }

    /// Semantic action for production 788:
    ///
    /// PackageGroupList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn package_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let package_group_list_1_built = Vec::new();
        self.push(
            ASTType::PackageGroupList(package_group_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 789:
    ///
    /// PackageItem: VarDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn package_item_0(&mut self, _var_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let var_declaration = pop_item!(self, var_declaration, VarDeclaration, context);
        let package_item_0_built = PackageItemVarDeclaration {
            var_declaration: Box::new(var_declaration),
        };
        let package_item_0_built = PackageItem::VarDeclaration(package_item_0_built);
        // Calling user action here
        self.user_grammar.package_item(&package_item_0_built)?;
        self.push(ASTType::PackageItem(package_item_0_built), context);
        Ok(())
    }

    /// Semantic action for production 790:
    ///
    /// PackageItem: LocalparamDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn package_item_1(&mut self, _localparam_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let localparam_declaration =
            pop_item!(self, localparam_declaration, LocalparamDeclaration, context);
        let package_item_1_built = PackageItemLocalparamDeclaration {
            localparam_declaration: Box::new(localparam_declaration),
        };
        let package_item_1_built = PackageItem::LocalparamDeclaration(package_item_1_built);
        // Calling user action here
        self.user_grammar.package_item(&package_item_1_built)?;
        self.push(ASTType::PackageItem(package_item_1_built), context);
        Ok(())
    }

    /// Semantic action for production 791:
    ///
    /// PackageItem: EnumDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn package_item_2(&mut self, _enum_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enum_declaration = pop_item!(self, enum_declaration, EnumDeclaration, context);
        let package_item_2_built = PackageItemEnumDeclaration {
            enum_declaration: Box::new(enum_declaration),
        };
        let package_item_2_built = PackageItem::EnumDeclaration(package_item_2_built);
        // Calling user action here
        self.user_grammar.package_item(&package_item_2_built)?;
        self.push(ASTType::PackageItem(package_item_2_built), context);
        Ok(())
    }

    /// Semantic action for production 792:
    ///
    /// PackageItem: StructDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn package_item_3(&mut self, _struct_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let struct_declaration = pop_item!(self, struct_declaration, StructDeclaration, context);
        let package_item_3_built = PackageItemStructDeclaration {
            struct_declaration: Box::new(struct_declaration),
        };
        let package_item_3_built = PackageItem::StructDeclaration(package_item_3_built);
        // Calling user action here
        self.user_grammar.package_item(&package_item_3_built)?;
        self.push(ASTType::PackageItem(package_item_3_built), context);
        Ok(())
    }

    /// Semantic action for production 793:
    ///
    /// PackageItem: FunctionDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn package_item_4(&mut self, _function_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_declaration =
            pop_item!(self, function_declaration, FunctionDeclaration, context);
        let package_item_4_built = PackageItemFunctionDeclaration {
            function_declaration: Box::new(function_declaration),
        };
        let package_item_4_built = PackageItem::FunctionDeclaration(package_item_4_built);
        // Calling user action here
        self.user_grammar.package_item(&package_item_4_built)?;
        self.push(ASTType::PackageItem(package_item_4_built), context);
        Ok(())
    }

    /// Semantic action for production 794:
    ///
    /// PackageItem: ImportDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn package_item_5(&mut self, _import_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let import_declaration = pop_item!(self, import_declaration, ImportDeclaration, context);
        let package_item_5_built = PackageItemImportDeclaration {
            import_declaration: Box::new(import_declaration),
        };
        let package_item_5_built = PackageItem::ImportDeclaration(package_item_5_built);
        // Calling user action here
        self.user_grammar.package_item(&package_item_5_built)?;
        self.push(ASTType::PackageItem(package_item_5_built), context);
        Ok(())
    }

    /// Semantic action for production 795:
    ///
    /// PackageItem: ExportDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn package_item_6(&mut self, _export_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let export_declaration = pop_item!(self, export_declaration, ExportDeclaration, context);
        let package_item_6_built = PackageItemExportDeclaration {
            export_declaration: Box::new(export_declaration),
        };
        let package_item_6_built = PackageItem::ExportDeclaration(package_item_6_built);
        // Calling user action here
        self.user_grammar.package_item(&package_item_6_built)?;
        self.push(ASTType::PackageItem(package_item_6_built), context);
        Ok(())
    }

    /// Semantic action for production 796:
    ///
    /// PackageItem: InitialDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn package_item_7(&mut self, _initial_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let initial_declaration = pop_item!(self, initial_declaration, InitialDeclaration, context);
        let package_item_7_built = PackageItemInitialDeclaration {
            initial_declaration: Box::new(initial_declaration),
        };
        let package_item_7_built = PackageItem::InitialDeclaration(package_item_7_built);
        // Calling user action here
        self.user_grammar.package_item(&package_item_7_built)?;
        self.push(ASTType::PackageItem(package_item_7_built), context);
        Ok(())
    }

    /// Semantic action for production 797:
    ///
    /// PackageItem: FinalDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn package_item_8(&mut self, _final_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let final_declaration = pop_item!(self, final_declaration, FinalDeclaration, context);
        let package_item_8_built = PackageItemFinalDeclaration {
            final_declaration: Box::new(final_declaration),
        };
        let package_item_8_built = PackageItem::FinalDeclaration(package_item_8_built);
        // Calling user action here
        self.user_grammar.package_item(&package_item_8_built)?;
        self.push(ASTType::PackageItem(package_item_8_built), context);
        Ok(())
    }

    /// Semantic action for production 798:
    ///
    /// DescriptionGroup: DescriptionGroupList /* Vec */ DescriptionGroupGroup;
    ///
    #[parol_runtime::function_name::named]
    fn description_group(
        &mut self,
        _description_group_list: &ParseTreeType<'t>,
        _description_group_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let description_group_group = pop_item!(
            self,
            description_group_group,
            DescriptionGroupGroup,
            context
        );
        let description_group_list =
            pop_and_reverse_item!(self, description_group_list, DescriptionGroupList, context);
        let description_group_built = DescriptionGroup {
            description_group_list,
            description_group_group: Box::new(description_group_group),
        };
        // Calling user action here
        self.user_grammar
            .description_group(&description_group_built)?;
        self.push(ASTType::DescriptionGroup(description_group_built), context);
        Ok(())
    }

    /// Semantic action for production 799:
    ///
    /// DescriptionGroupGroup: LBrace DescriptionGroupGroupList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn description_group_group_0(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _description_group_group_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let description_group_group_list = pop_and_reverse_item!(
            self,
            description_group_group_list,
            DescriptionGroupGroupList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let description_group_group_0_built =
            DescriptionGroupGroupLBraceDescriptionGroupGroupListRBrace {
                l_brace: Box::new(l_brace),
                description_group_group_list,
                r_brace: Box::new(r_brace),
            };
        let description_group_group_0_built =
            DescriptionGroupGroup::LBraceDescriptionGroupGroupListRBrace(
                description_group_group_0_built,
            );
        self.push(
            ASTType::DescriptionGroupGroup(description_group_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 800:
    ///
    /// DescriptionGroupGroupList /* Vec<T>::Push */: DescriptionGroup DescriptionGroupGroupList;
    ///
    #[parol_runtime::function_name::named]
    fn description_group_group_list_0(
        &mut self,
        _description_group: &ParseTreeType<'t>,
        _description_group_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut description_group_group_list = pop_item!(
            self,
            description_group_group_list,
            DescriptionGroupGroupList,
            context
        );
        let description_group = pop_item!(self, description_group, DescriptionGroup, context);
        let description_group_group_list_0_built = DescriptionGroupGroupList {
            description_group: Box::new(description_group),
        };
        // Add an element to the vector
        description_group_group_list.push(description_group_group_list_0_built);
        self.push(
            ASTType::DescriptionGroupGroupList(description_group_group_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 801:
    ///
    /// DescriptionGroupGroupList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn description_group_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let description_group_group_list_1_built = Vec::new();
        self.push(
            ASTType::DescriptionGroupGroupList(description_group_group_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 802:
    ///
    /// DescriptionGroupGroup: DescriptionItem;
    ///
    #[parol_runtime::function_name::named]
    fn description_group_group_1(&mut self, _description_item: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let description_item = pop_item!(self, description_item, DescriptionItem, context);
        let description_group_group_1_built = DescriptionGroupGroupDescriptionItem {
            description_item: Box::new(description_item),
        };
        let description_group_group_1_built =
            DescriptionGroupGroup::DescriptionItem(description_group_group_1_built);
        self.push(
            ASTType::DescriptionGroupGroup(description_group_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 803:
    ///
    /// DescriptionGroupList /* Vec<T>::Push */: Attribute DescriptionGroupList;
    ///
    #[parol_runtime::function_name::named]
    fn description_group_list_0(
        &mut self,
        _attribute: &ParseTreeType<'t>,
        _description_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut description_group_list =
            pop_item!(self, description_group_list, DescriptionGroupList, context);
        let attribute = pop_item!(self, attribute, Attribute, context);
        let description_group_list_0_built = DescriptionGroupList {
            attribute: Box::new(attribute),
        };
        // Add an element to the vector
        description_group_list.push(description_group_list_0_built);
        self.push(
            ASTType::DescriptionGroupList(description_group_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 804:
    ///
    /// DescriptionGroupList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn description_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let description_group_list_1_built = Vec::new();
        self.push(
            ASTType::DescriptionGroupList(description_group_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 805:
    ///
    /// DescriptionItem: ModuleDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn description_item_0(&mut self, _module_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_declaration = pop_item!(self, module_declaration, ModuleDeclaration, context);
        let description_item_0_built = DescriptionItemModuleDeclaration {
            module_declaration: Box::new(module_declaration),
        };
        let description_item_0_built = DescriptionItem::ModuleDeclaration(description_item_0_built);
        // Calling user action here
        self.user_grammar
            .description_item(&description_item_0_built)?;
        self.push(ASTType::DescriptionItem(description_item_0_built), context);
        Ok(())
    }

    /// Semantic action for production 806:
    ///
    /// DescriptionItem: InterfaceDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn description_item_1(&mut self, _interface_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_declaration =
            pop_item!(self, interface_declaration, InterfaceDeclaration, context);
        let description_item_1_built = DescriptionItemInterfaceDeclaration {
            interface_declaration: Box::new(interface_declaration),
        };
        let description_item_1_built =
            DescriptionItem::InterfaceDeclaration(description_item_1_built);
        // Calling user action here
        self.user_grammar
            .description_item(&description_item_1_built)?;
        self.push(ASTType::DescriptionItem(description_item_1_built), context);
        Ok(())
    }

    /// Semantic action for production 807:
    ///
    /// DescriptionItem: PackageDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn description_item_2(&mut self, _package_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let package_declaration = pop_item!(self, package_declaration, PackageDeclaration, context);
        let description_item_2_built = DescriptionItemPackageDeclaration {
            package_declaration: Box::new(package_declaration),
        };
        let description_item_2_built =
            DescriptionItem::PackageDeclaration(description_item_2_built);
        // Calling user action here
        self.user_grammar
            .description_item(&description_item_2_built)?;
        self.push(ASTType::DescriptionItem(description_item_2_built), context);
        Ok(())
    }

    /// Semantic action for production 808:
    ///
    /// DescriptionItem: ImportDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn description_item_3(&mut self, _import_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let import_declaration = pop_item!(self, import_declaration, ImportDeclaration, context);
        let description_item_3_built = DescriptionItemImportDeclaration {
            import_declaration: Box::new(import_declaration),
        };
        let description_item_3_built = DescriptionItem::ImportDeclaration(description_item_3_built);
        // Calling user action here
        self.user_grammar
            .description_item(&description_item_3_built)?;
        self.push(ASTType::DescriptionItem(description_item_3_built), context);
        Ok(())
    }

    /// Semantic action for production 809:
    ///
    /// Veryl: Start VerylList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn veryl(&mut self, _start: &ParseTreeType<'t>, _veryl_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let veryl_list = pop_and_reverse_item!(self, veryl_list, VerylList, context);
        let start = pop_item!(self, start, Start, context);
        let veryl_built = Veryl {
            start: Box::new(start),
            veryl_list,
        };
        // Calling user action here
        self.user_grammar.veryl(&veryl_built)?;
        self.push(ASTType::Veryl(veryl_built), context);
        Ok(())
    }

    /// Semantic action for production 810:
    ///
    /// VerylList /* Vec<T>::Push */: DescriptionGroup VerylList;
    ///
    #[parol_runtime::function_name::named]
    fn veryl_list_0(
        &mut self,
        _description_group: &ParseTreeType<'t>,
        _veryl_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut veryl_list = pop_item!(self, veryl_list, VerylList, context);
        let description_group = pop_item!(self, description_group, DescriptionGroup, context);
        let veryl_list_0_built = VerylList {
            description_group: Box::new(description_group),
        };
        // Add an element to the vector
        veryl_list.push(veryl_list_0_built);
        self.push(ASTType::VerylList(veryl_list), context);
        Ok(())
    }

    /// Semantic action for production 811:
    ///
    /// VerylList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn veryl_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let veryl_list_1_built = Vec::new();
        self.push(ASTType::VerylList(veryl_list_1_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for VerylGrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item VerylGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeType<'t>],
    ) -> Result<()> {
        match prod_num {
            0 => self.comments_term(&children[0]),
            1 => self.string_literal_term(&children[0]),
            2 => self.exponent_term(&children[0]),
            3 => self.fixed_point_term(&children[0]),
            4 => self.based_term(&children[0]),
            5 => self.all_bit_term(&children[0]),
            6 => self.base_less_term(&children[0]),
            7 => self.minus_colon_term(&children[0]),
            8 => self.minus_g_t_term(&children[0]),
            9 => self.plus_colon_term(&children[0]),
            10 => self.assignment_operator_term(&children[0]),
            11 => self.operator11_term(&children[0]),
            12 => self.operator10_term(&children[0]),
            13 => self.operator09_term(&children[0]),
            14 => self.operator08_term(&children[0]),
            15 => self.operator07_term(&children[0]),
            16 => self.operator06_term(&children[0]),
            17 => self.operator02_term(&children[0]),
            18 => self.operator01_term(&children[0]),
            19 => self.operator05_term(&children[0]),
            20 => self.operator04_term(&children[0]),
            21 => self.operator03_term(&children[0]),
            22 => self.unary_operator_term(&children[0]),
            23 => self.colon_colon_term(&children[0]),
            24 => self.colon_term(&children[0]),
            25 => self.comma_term(&children[0]),
            26 => self.dollar_term(&children[0]),
            27 => self.dot_dot_equ_term(&children[0]),
            28 => self.dot_dot_term(&children[0]),
            29 => self.dot_term(&children[0]),
            30 => self.equ_term(&children[0]),
            31 => self.hash_term(&children[0]),
            32 => self.l_angle_term(&children[0]),
            33 => self.l_brace_term(&children[0]),
            34 => self.l_bracket_term(&children[0]),
            35 => self.l_paren_term(&children[0]),
            36 => self.r_angle_term(&children[0]),
            37 => self.r_brace_term(&children[0]),
            38 => self.r_bracket_term(&children[0]),
            39 => self.r_paren_term(&children[0]),
            40 => self.semicolon_term(&children[0]),
            41 => self.star_term(&children[0]),
            42 => self.always_comb_term(&children[0]),
            43 => self.always_ff_term(&children[0]),
            44 => self.assign_term(&children[0]),
            45 => self.async_high_term(&children[0]),
            46 => self.async_low_term(&children[0]),
            47 => self.as_term(&children[0]),
            48 => self.bit_term(&children[0]),
            49 => self.case_term(&children[0]),
            50 => self.default_term(&children[0]),
            51 => self.else_term(&children[0]),
            52 => self.enum_term(&children[0]),
            53 => self.export_term(&children[0]),
            54 => self.f32_term(&children[0]),
            55 => self.f64_term(&children[0]),
            56 => self.final_term(&children[0]),
            57 => self.for_term(&children[0]),
            58 => self.function_term(&children[0]),
            59 => self.i32_term(&children[0]),
            60 => self.i64_term(&children[0]),
            61 => self.if_reset_term(&children[0]),
            62 => self.if_term(&children[0]),
            63 => self.import_term(&children[0]),
            64 => self.initial_term(&children[0]),
            65 => self.inout_term(&children[0]),
            66 => self.input_term(&children[0]),
            67 => self.inside_term(&children[0]),
            68 => self.inst_term(&children[0]),
            69 => self.interface_term(&children[0]),
            70 => self.in_term(&children[0]),
            71 => self.localparam_term(&children[0]),
            72 => self.logic_term(&children[0]),
            73 => self.lsb_term(&children[0]),
            74 => self.modport_term(&children[0]),
            75 => self.module_term(&children[0]),
            76 => self.msb_term(&children[0]),
            77 => self.negedge_term(&children[0]),
            78 => self.output_term(&children[0]),
            79 => self.outside_term(&children[0]),
            80 => self.package_term(&children[0]),
            81 => self.parameter_term(&children[0]),
            82 => self.posedge_term(&children[0]),
            83 => self.ref_term(&children[0]),
            84 => self.repeat_term(&children[0]),
            85 => self.return_term(&children[0]),
            86 => self.signed_term(&children[0]),
            87 => self.step_term(&children[0]),
            88 => self.string_term(&children[0]),
            89 => self.struct_term(&children[0]),
            90 => self.sync_high_term(&children[0]),
            91 => self.sync_low_term(&children[0]),
            92 => self.tri_term(&children[0]),
            93 => self.type_term(&children[0]),
            94 => self.u32_term(&children[0]),
            95 => self.u64_term(&children[0]),
            96 => self.var_term(&children[0]),
            97 => self.identifier_term(&children[0]),
            98 => self.comments(&children[0]),
            99 => self.comments_opt_0(&children[0]),
            100 => self.comments_opt_1(),
            101 => self.start_token(&children[0]),
            102 => self.string_literal_token(&children[0], &children[1]),
            103 => self.exponent_token(&children[0], &children[1]),
            104 => self.fixed_point_token(&children[0], &children[1]),
            105 => self.based_token(&children[0], &children[1]),
            106 => self.base_less_token(&children[0], &children[1]),
            107 => self.all_bit_token(&children[0], &children[1]),
            108 => self.assignment_operator_token(&children[0], &children[1]),
            109 => self.operator01_token(&children[0], &children[1]),
            110 => self.operator02_token(&children[0], &children[1]),
            111 => self.operator03_token(&children[0], &children[1]),
            112 => self.operator04_token(&children[0], &children[1]),
            113 => self.operator05_token(&children[0], &children[1]),
            114 => self.operator06_token(&children[0], &children[1]),
            115 => self.operator07_token(&children[0], &children[1]),
            116 => self.operator08_token(&children[0], &children[1]),
            117 => self.operator09_token(&children[0], &children[1]),
            118 => self.operator10_token(&children[0], &children[1]),
            119 => self.operator11_token(&children[0], &children[1]),
            120 => self.unary_operator_token(&children[0], &children[1]),
            121 => self.colon_token(&children[0], &children[1]),
            122 => self.colon_colon_token(&children[0], &children[1]),
            123 => self.comma_token(&children[0], &children[1]),
            124 => self.dollar_token(&children[0], &children[1]),
            125 => self.dot_dot_token(&children[0], &children[1]),
            126 => self.dot_dot_equ_token(&children[0], &children[1]),
            127 => self.dot_token(&children[0], &children[1]),
            128 => self.equ_token(&children[0], &children[1]),
            129 => self.hash_token(&children[0], &children[1]),
            130 => self.l_angle_token(&children[0], &children[1]),
            131 => self.l_brace_token(&children[0], &children[1]),
            132 => self.l_bracket_token(&children[0], &children[1]),
            133 => self.l_paren_token(&children[0], &children[1]),
            134 => self.minus_colon_token(&children[0], &children[1]),
            135 => self.minus_g_t_token(&children[0], &children[1]),
            136 => self.plus_colon_token(&children[0], &children[1]),
            137 => self.r_angle_token(&children[0], &children[1]),
            138 => self.r_brace_token(&children[0], &children[1]),
            139 => self.r_bracket_token(&children[0], &children[1]),
            140 => self.r_paren_token(&children[0], &children[1]),
            141 => self.semicolon_token(&children[0], &children[1]),
            142 => self.star_token(&children[0], &children[1]),
            143 => self.always_comb_token(&children[0], &children[1]),
            144 => self.always_ff_token(&children[0], &children[1]),
            145 => self.as_token(&children[0], &children[1]),
            146 => self.assign_token(&children[0], &children[1]),
            147 => self.async_high_token(&children[0], &children[1]),
            148 => self.async_low_token(&children[0], &children[1]),
            149 => self.bit_token(&children[0], &children[1]),
            150 => self.case_token(&children[0], &children[1]),
            151 => self.default_token(&children[0], &children[1]),
            152 => self.else_token(&children[0], &children[1]),
            153 => self.enum_token(&children[0], &children[1]),
            154 => self.export_token(&children[0], &children[1]),
            155 => self.f32_token(&children[0], &children[1]),
            156 => self.f64_token(&children[0], &children[1]),
            157 => self.final_token(&children[0], &children[1]),
            158 => self.for_token(&children[0], &children[1]),
            159 => self.function_token(&children[0], &children[1]),
            160 => self.i32_token(&children[0], &children[1]),
            161 => self.i64_token(&children[0], &children[1]),
            162 => self.if_reset_token(&children[0], &children[1]),
            163 => self.if_token(&children[0], &children[1]),
            164 => self.import_token(&children[0], &children[1]),
            165 => self.initial_token(&children[0], &children[1]),
            166 => self.inout_token(&children[0], &children[1]),
            167 => self.input_token(&children[0], &children[1]),
            168 => self.inside_token(&children[0], &children[1]),
            169 => self.inst_token(&children[0], &children[1]),
            170 => self.interface_token(&children[0], &children[1]),
            171 => self.in_token(&children[0], &children[1]),
            172 => self.localparam_token(&children[0], &children[1]),
            173 => self.logic_token(&children[0], &children[1]),
            174 => self.lsb_token(&children[0], &children[1]),
            175 => self.modport_token(&children[0], &children[1]),
            176 => self.module_token(&children[0], &children[1]),
            177 => self.msb_token(&children[0], &children[1]),
            178 => self.negedge_token(&children[0], &children[1]),
            179 => self.output_token(&children[0], &children[1]),
            180 => self.outside_token(&children[0], &children[1]),
            181 => self.package_token(&children[0], &children[1]),
            182 => self.parameter_token(&children[0], &children[1]),
            183 => self.posedge_token(&children[0], &children[1]),
            184 => self.ref_token(&children[0], &children[1]),
            185 => self.repeat_token(&children[0], &children[1]),
            186 => self.return_token(&children[0], &children[1]),
            187 => self.signed_token(&children[0], &children[1]),
            188 => self.step_token(&children[0], &children[1]),
            189 => self.string_token(&children[0], &children[1]),
            190 => self.struct_token(&children[0], &children[1]),
            191 => self.sync_high_token(&children[0], &children[1]),
            192 => self.sync_low_token(&children[0], &children[1]),
            193 => self.tri_token(&children[0], &children[1]),
            194 => self.type_token(&children[0], &children[1]),
            195 => self.u32_token(&children[0], &children[1]),
            196 => self.u64_token(&children[0], &children[1]),
            197 => self.var_token(&children[0], &children[1]),
            198 => self.identifier_token(&children[0], &children[1]),
            199 => self.start(&children[0]),
            200 => self.string_literal(&children[0]),
            201 => self.exponent(&children[0]),
            202 => self.fixed_point(&children[0]),
            203 => self.based(&children[0]),
            204 => self.base_less(&children[0]),
            205 => self.all_bit(&children[0]),
            206 => self.assignment_operator(&children[0]),
            207 => self.operator01(&children[0]),
            208 => self.operator02(&children[0]),
            209 => self.operator03(&children[0]),
            210 => self.operator04(&children[0]),
            211 => self.operator05(&children[0]),
            212 => self.operator06(&children[0]),
            213 => self.operator07(&children[0]),
            214 => self.operator08(&children[0]),
            215 => self.operator09(&children[0]),
            216 => self.operator10(&children[0]),
            217 => self.operator11(&children[0]),
            218 => self.unary_operator(&children[0]),
            219 => self.colon(&children[0]),
            220 => self.colon_colon(&children[0]),
            221 => self.comma(&children[0]),
            222 => self.dollar(&children[0]),
            223 => self.dot_dot(&children[0]),
            224 => self.dot_dot_equ(&children[0]),
            225 => self.dot(&children[0]),
            226 => self.equ(&children[0]),
            227 => self.hash(&children[0]),
            228 => self.l_angle(&children[0]),
            229 => self.l_brace(&children[0]),
            230 => self.l_bracket(&children[0]),
            231 => self.l_paren(&children[0]),
            232 => self.minus_colon(&children[0]),
            233 => self.minus_g_t(&children[0]),
            234 => self.plus_colon(&children[0]),
            235 => self.r_angle(&children[0]),
            236 => self.r_brace(&children[0]),
            237 => self.r_bracket(&children[0]),
            238 => self.r_paren(&children[0]),
            239 => self.semicolon(&children[0]),
            240 => self.star(&children[0]),
            241 => self.always_comb(&children[0]),
            242 => self.always_ff(&children[0]),
            243 => self.r#as(&children[0]),
            244 => self.assign(&children[0]),
            245 => self.async_high(&children[0]),
            246 => self.async_low(&children[0]),
            247 => self.bit(&children[0]),
            248 => self.case(&children[0]),
            249 => self.defaul(&children[0]),
            250 => self.r#else(&children[0]),
            251 => self.r#enum(&children[0]),
            252 => self.export(&children[0]),
            253 => self.f32(&children[0]),
            254 => self.f64(&children[0]),
            255 => self.r#final(&children[0]),
            256 => self.r#for(&children[0]),
            257 => self.function(&children[0]),
            258 => self.i32(&children[0]),
            259 => self.i64(&children[0]),
            260 => self.r#if(&children[0]),
            261 => self.if_reset(&children[0]),
            262 => self.import(&children[0]),
            263 => self.r#in(&children[0]),
            264 => self.initial(&children[0]),
            265 => self.inout(&children[0]),
            266 => self.input(&children[0]),
            267 => self.inside(&children[0]),
            268 => self.inst(&children[0]),
            269 => self.interface(&children[0]),
            270 => self.localparam(&children[0]),
            271 => self.logic(&children[0]),
            272 => self.lsb(&children[0]),
            273 => self.modport(&children[0]),
            274 => self.module(&children[0]),
            275 => self.msb(&children[0]),
            276 => self.negedge(&children[0]),
            277 => self.output(&children[0]),
            278 => self.outside(&children[0]),
            279 => self.package(&children[0]),
            280 => self.parameter(&children[0]),
            281 => self.posedge(&children[0]),
            282 => self.r#ref(&children[0]),
            283 => self.repeat(&children[0]),
            284 => self.r#return(&children[0]),
            285 => self.signed(&children[0]),
            286 => self.step(&children[0]),
            287 => self.strin(&children[0]),
            288 => self.r#struct(&children[0]),
            289 => self.sync_high(&children[0]),
            290 => self.sync_low(&children[0]),
            291 => self.tri(&children[0]),
            292 => self.r#type(&children[0]),
            293 => self.u32(&children[0]),
            294 => self.u64(&children[0]),
            295 => self.var(&children[0]),
            296 => self.identifier(&children[0]),
            297 => self.number_0(&children[0]),
            298 => self.number_1(&children[0]),
            299 => self.integral_number_0(&children[0]),
            300 => self.integral_number_1(&children[0]),
            301 => self.integral_number_2(&children[0]),
            302 => self.real_number_0(&children[0]),
            303 => self.real_number_1(&children[0]),
            304 => self.hierarchical_identifier(&children[0], &children[1], &children[2]),
            305 => self.hierarchical_identifier_list0_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
            ),
            306 => self.hierarchical_identifier_list0_list_0(&children[0], &children[1]),
            307 => self.hierarchical_identifier_list0_list_1(),
            308 => self.hierarchical_identifier_list0_1(),
            309 => self.hierarchical_identifier_list_0(&children[0], &children[1]),
            310 => self.hierarchical_identifier_list_1(),
            311 => self.scoped_identifier(&children[0], &children[1]),
            312 => self.scoped_identifier_list_0(&children[0], &children[1], &children[2]),
            313 => self.scoped_identifier_list_1(),
            314 => self.expression_identifier(&children[0], &children[1], &children[2]),
            315 => self.expression_identifier_group_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
            ),
            316 => self.expression_identifier_group_list0_0(&children[0], &children[1]),
            317 => self.expression_identifier_group_list0_1(),
            318 => {
                self.expression_identifier_group_list_0(&children[0], &children[1], &children[2])
            }
            319 => self.expression_identifier_group_list_1(),
            320 => self.expression_identifier_group_1(&children[0], &children[1]),
            321 => self.expression_identifier_group_list2_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
            ),
            322 => self.expression_identifier_group_list2_list_0(&children[0], &children[1]),
            323 => self.expression_identifier_group_list2_list_1(),
            324 => self.expression_identifier_group_list2_1(),
            325 => self.expression_identifier_group_list1_0(&children[0], &children[1]),
            326 => self.expression_identifier_group_list1_1(),
            327 => self.expression_identifier_opt_0(&children[0]),
            328 => self.expression_identifier_opt_1(),
            329 => self.expression(&children[0], &children[1]),
            330 => self.expression_list_0(&children[0], &children[1], &children[2]),
            331 => self.expression_list_1(),
            332 => self.expression01(&children[0], &children[1]),
            333 => self.expression01_list_0(&children[0], &children[1], &children[2]),
            334 => self.expression01_list_1(),
            335 => self.expression02(&children[0], &children[1]),
            336 => self.expression02_list_0(&children[0], &children[1], &children[2]),
            337 => self.expression02_list_1(),
            338 => self.expression03(&children[0], &children[1]),
            339 => self.expression03_list_0(&children[0], &children[1], &children[2]),
            340 => self.expression03_list_1(),
            341 => self.expression04(&children[0], &children[1]),
            342 => self.expression04_list_0(&children[0], &children[1], &children[2]),
            343 => self.expression04_list_1(),
            344 => self.expression05(&children[0], &children[1]),
            345 => self.expression05_list_0(&children[0], &children[1], &children[2]),
            346 => self.expression05_list_1(),
            347 => self.expression06(&children[0], &children[1]),
            348 => self.expression06_list_0(&children[0], &children[1], &children[2]),
            349 => self.expression06_list_1(),
            350 => self.expression07(&children[0], &children[1]),
            351 => self.expression07_list_0(&children[0], &children[1], &children[2]),
            352 => self.expression07_list_1(),
            353 => self.expression08(&children[0], &children[1]),
            354 => self.expression08_list_0(&children[0], &children[1], &children[2]),
            355 => self.expression08_list_1(),
            356 => self.expression09(&children[0], &children[1]),
            357 => self.expression09_list_0(&children[0], &children[1], &children[2]),
            358 => self.expression09_list_group_0(&children[0]),
            359 => self.expression09_list_group_1(&children[0]),
            360 => self.expression09_list_1(),
            361 => self.expression10(&children[0], &children[1]),
            362 => self.expression10_list_0(&children[0], &children[1], &children[2]),
            363 => self.expression10_list_1(),
            364 => self.expression11(&children[0], &children[1]),
            365 => self.expression11_list_0(&children[0], &children[1], &children[2]),
            366 => self.expression11_list_1(),
            367 => self.expression12(&children[0], &children[1]),
            368 => self.expression12_list_0(&children[0], &children[1]),
            369 => self.expression12_list_group_0(&children[0]),
            370 => self.expression12_list_group_1(&children[0]),
            371 => self.expression12_list_group_2(&children[0]),
            372 => self.expression12_list_group_3(&children[0]),
            373 => self.expression12_list_group_4(&children[0]),
            374 => self.expression12_list_1(),
            375 => self.factor_0(&children[0]),
            376 => self.factor_1(&children[0], &children[1]),
            377 => self.factor_2(&children[0], &children[1], &children[2]),
            378 => self.factor_3(&children[0], &children[1], &children[2]),
            379 => self.factor_4(&children[0]),
            380 => self.factor_5(&children[0]),
            381 => self.factor_6(&children[0]),
            382 => self.factor_7(&children[0]),
            383 => self.factor_group_0(&children[0]),
            384 => self.factor_group_1(&children[0]),
            385 => self.factor_8(&children[0]),
            386 => self.factor_9(&children[0]),
            387 => self.factor_opt_0(&children[0]),
            388 => self.factor_opt_1(),
            389 => self.function_call(&children[0], &children[1], &children[2]),
            390 => self.function_call_opt_0(&children[0]),
            391 => self.function_call_opt_1(),
            392 => self.argument_list(&children[0], &children[1], &children[2]),
            393 => self.argument_list_list_0(&children[0], &children[1], &children[2]),
            394 => self.argument_list_list_1(),
            395 => self.argument_list_opt_0(&children[0]),
            396 => self.argument_list_opt_1(),
            397 => self.argument_item(&children[0]),
            398 => self.concatenation_list(&children[0], &children[1], &children[2]),
            399 => self.concatenation_list_list_0(&children[0], &children[1], &children[2]),
            400 => self.concatenation_list_list_1(),
            401 => self.concatenation_list_opt_0(&children[0]),
            402 => self.concatenation_list_opt_1(),
            403 => self.concatenation_item(&children[0], &children[1]),
            404 => self.concatenation_item_opt_0(&children[0], &children[1]),
            405 => self.concatenation_item_opt_1(),
            406 => self.if_expression(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                &children[7],
                &children[8],
                &children[9],
            ),
            407 => self.if_expression_list_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
            ),
            408 => self.if_expression_list_1(),
            409 => self.case_expression(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                &children[7],
                &children[8],
                &children[9],
                &children[10],
                &children[11],
                &children[12],
            ),
            410 => self.case_expression_list_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            411 => self.case_expression_list_1(),
            412 => self.case_expression_opt_0(&children[0]),
            413 => self.case_expression_opt_1(),
            414 => self.type_expression_0(&children[0]),
            415 => self.type_expression_1(&children[0], &children[1], &children[2], &children[3]),
            416 => self.inside_expression(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            417 => self.outside_expression(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            418 => self.range_list(&children[0], &children[1], &children[2]),
            419 => self.range_list_list_0(&children[0], &children[1], &children[2]),
            420 => self.range_list_list_1(),
            421 => self.range_list_opt_0(&children[0]),
            422 => self.range_list_opt_1(),
            423 => self.range_item(&children[0]),
            424 => self.select(&children[0], &children[1], &children[2], &children[3]),
            425 => self.select_opt_0(&children[0], &children[1]),
            426 => self.select_opt_1(),
            427 => self.select_operator_0(&children[0]),
            428 => self.select_operator_1(&children[0]),
            429 => self.select_operator_2(&children[0]),
            430 => self.select_operator_3(&children[0]),
            431 => self.width(&children[0], &children[1], &children[2], &children[3]),
            432 => self.width_list_0(&children[0], &children[1], &children[2]),
            433 => self.width_list_1(),
            434 => self.array(&children[0], &children[1], &children[2], &children[3]),
            435 => self.array_list_0(&children[0], &children[1], &children[2]),
            436 => self.array_list_1(),
            437 => self.range(&children[0], &children[1]),
            438 => self.range_opt_0(&children[0], &children[1]),
            439 => self.range_opt_1(),
            440 => self.range_operator_0(&children[0]),
            441 => self.range_operator_1(&children[0]),
            442 => self.fixed_type_0(&children[0]),
            443 => self.fixed_type_1(&children[0]),
            444 => self.fixed_type_2(&children[0]),
            445 => self.fixed_type_3(&children[0]),
            446 => self.fixed_type_4(&children[0]),
            447 => self.fixed_type_5(&children[0]),
            448 => self.fixed_type_6(&children[0]),
            449 => self.variable_type(&children[0], &children[1]),
            450 => self.variable_type_group_0(&children[0]),
            451 => self.variable_type_group_1(&children[0]),
            452 => self.variable_type_group_2(&children[0]),
            453 => self.variable_type_opt_0(&children[0]),
            454 => self.variable_type_opt_1(),
            455 => self.type_modifier_0(&children[0]),
            456 => self.type_modifier_1(&children[0]),
            457 => self.scalar_type(&children[0], &children[1]),
            458 => self.scalar_type_group_0(&children[0]),
            459 => self.scalar_type_group_1(&children[0]),
            460 => self.scalar_type_list_0(&children[0], &children[1]),
            461 => self.scalar_type_list_1(),
            462 => self.array_type(&children[0], &children[1]),
            463 => self.array_type_opt_0(&children[0]),
            464 => self.array_type_opt_1(),
            465 => self.statement_0(&children[0]),
            466 => self.statement_1(&children[0]),
            467 => self.statement_2(&children[0]),
            468 => self.statement_3(&children[0]),
            469 => self.statement_4(&children[0]),
            470 => self.statement_5(&children[0]),
            471 => self.identifier_statement(&children[0], &children[1], &children[2]),
            472 => self.identifier_statement_group_0(&children[0]),
            473 => self.identifier_statement_group_1(&children[0]),
            474 => self.assignment(&children[0], &children[1]),
            475 => self.assignment_group_0(&children[0]),
            476 => self.assignment_group_1(&children[0]),
            477 => self.if_statement(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
            ),
            478 => self.if_statement_list0_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
            ),
            479 => self.if_statement_list0_list_0(&children[0], &children[1]),
            480 => self.if_statement_list0_list_1(),
            481 => self.if_statement_list0_1(),
            482 => self.if_statement_list_0(&children[0], &children[1]),
            483 => self.if_statement_list_1(),
            484 => self.if_statement_opt_0(&children[0], &children[1], &children[2], &children[3]),
            485 => self.if_statement_opt_list_0(&children[0], &children[1]),
            486 => self.if_statement_opt_list_1(),
            487 => self.if_statement_opt_1(),
            488 => self.if_reset_statement(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
            ),
            489 => self.if_reset_statement_list0_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
            ),
            490 => self.if_reset_statement_list0_list_0(&children[0], &children[1]),
            491 => self.if_reset_statement_list0_list_1(),
            492 => self.if_reset_statement_list0_1(),
            493 => self.if_reset_statement_list_0(&children[0], &children[1]),
            494 => self.if_reset_statement_list_1(),
            495 => self.if_reset_statement_opt_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
            ),
            496 => self.if_reset_statement_opt_list_0(&children[0], &children[1]),
            497 => self.if_reset_statement_opt_list_1(),
            498 => self.if_reset_statement_opt_1(),
            499 => self.return_statement(&children[0], &children[1], &children[2]),
            500 => self.for_statement(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                &children[7],
                &children[8],
                &children[9],
            ),
            501 => self.for_statement_list_0(&children[0], &children[1]),
            502 => self.for_statement_list_1(),
            503 => self.for_statement_opt_0(&children[0], &children[1], &children[2]),
            504 => self.for_statement_opt_1(),
            505 => self.case_statement(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            506 => self.case_statement_list_0(&children[0], &children[1]),
            507 => self.case_statement_list_1(),
            508 => self.case_item(&children[0], &children[1], &children[2]),
            509 => self.case_item_group0_0(&children[0]),
            510 => self.case_item_group0_1(&children[0], &children[1], &children[2]),
            511 => self.case_item_group0_list_0(&children[0], &children[1]),
            512 => self.case_item_group0_list_1(),
            513 => self.case_item_group_0(&children[0]),
            514 => self.case_item_group_1(&children[0]),
            515 => self.attribute(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            516 => self.attribute_opt_0(&children[0], &children[1], &children[2]),
            517 => self.attribute_opt_1(),
            518 => self.attribute_list(&children[0], &children[1], &children[2]),
            519 => self.attribute_list_list_0(&children[0], &children[1], &children[2]),
            520 => self.attribute_list_list_1(),
            521 => self.attribute_list_opt_0(&children[0]),
            522 => self.attribute_list_opt_1(),
            523 => self.attribute_item_0(&children[0]),
            524 => self.attribute_item_1(&children[0]),
            525 => self.var_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
            ),
            526 => self.var_declaration_opt_0(&children[0], &children[1]),
            527 => self.var_declaration_opt_1(),
            528 => self.localparam_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            529 => self.localparam_declaration_group_0(&children[0], &children[1], &children[2]),
            530 => self.localparam_declaration_group_1(&children[0], &children[1], &children[2]),
            531 => self.always_ff_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                &children[7],
            ),
            532 => self.always_ff_declaration_list_0(&children[0], &children[1]),
            533 => self.always_ff_declaration_list_1(),
            534 => self.always_ff_declaration_opt_0(&children[0], &children[1]),
            535 => self.always_ff_declaration_opt_1(),
            536 => self.always_ff_clock(&children[0], &children[1]),
            537 => self.always_ff_clock_opt_0(&children[0]),
            538 => self.always_ff_clock_opt_group_0(&children[0]),
            539 => self.always_ff_clock_opt_group_1(&children[0]),
            540 => self.always_ff_clock_opt_1(),
            541 => self.always_ff_reset(&children[0], &children[1]),
            542 => self.always_ff_reset_opt_0(&children[0]),
            543 => self.always_ff_reset_opt_group_0(&children[0]),
            544 => self.always_ff_reset_opt_group_1(&children[0]),
            545 => self.always_ff_reset_opt_group_2(&children[0]),
            546 => self.always_ff_reset_opt_group_3(&children[0]),
            547 => self.always_ff_reset_opt_1(),
            548 => {
                self.always_comb_declaration(&children[0], &children[1], &children[2], &children[3])
            }
            549 => self.always_comb_declaration_list_0(&children[0], &children[1]),
            550 => self.always_comb_declaration_list_1(),
            551 => self.assign_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            552 => self.modport_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            553 => self.modport_list(&children[0], &children[1], &children[2]),
            554 => self.modport_list_list_0(&children[0], &children[1], &children[2]),
            555 => self.modport_list_list_1(),
            556 => self.modport_list_opt_0(&children[0]),
            557 => self.modport_list_opt_1(),
            558 => self.modport_group(&children[0], &children[1]),
            559 => self.modport_group_group_0(&children[0], &children[1], &children[2]),
            560 => self.modport_group_group_1(&children[0]),
            561 => self.modport_group_list_0(&children[0], &children[1]),
            562 => self.modport_group_list_1(),
            563 => self.modport_item(&children[0], &children[1], &children[2]),
            564 => self.enum_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
            ),
            565 => self.enum_list(&children[0], &children[1], &children[2]),
            566 => self.enum_list_list_0(&children[0], &children[1], &children[2]),
            567 => self.enum_list_list_1(),
            568 => self.enum_list_opt_0(&children[0]),
            569 => self.enum_list_opt_1(),
            570 => self.enum_group(&children[0], &children[1]),
            571 => self.enum_group_group_0(&children[0], &children[1], &children[2]),
            572 => self.enum_group_group_1(&children[0]),
            573 => self.enum_group_list_0(&children[0], &children[1]),
            574 => self.enum_group_list_1(),
            575 => self.enum_item(&children[0], &children[1]),
            576 => self.enum_item_opt_0(&children[0], &children[1]),
            577 => self.enum_item_opt_1(),
            578 => self.struct_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            579 => self.struct_list(&children[0], &children[1], &children[2]),
            580 => self.struct_list_list_0(&children[0], &children[1], &children[2]),
            581 => self.struct_list_list_1(),
            582 => self.struct_list_opt_0(&children[0]),
            583 => self.struct_list_opt_1(),
            584 => self.struct_group(&children[0], &children[1]),
            585 => self.struct_group_group_0(&children[0], &children[1], &children[2]),
            586 => self.struct_group_group_1(&children[0]),
            587 => self.struct_group_list_0(&children[0], &children[1]),
            588 => self.struct_group_list_1(),
            589 => self.struct_item(&children[0], &children[1], &children[2]),
            590 => self.initial_declaration(&children[0], &children[1], &children[2], &children[3]),
            591 => self.initial_declaration_list_0(&children[0], &children[1]),
            592 => self.initial_declaration_list_1(),
            593 => self.initial_item_0(&children[0]),
            594 => self.initial_item_1(&children[0]),
            595 => self.final_declaration(&children[0], &children[1], &children[2], &children[3]),
            596 => self.final_declaration_list_0(&children[0], &children[1]),
            597 => self.final_declaration_list_1(),
            598 => self.inst_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                &children[7],
            ),
            599 => self.inst_declaration_opt1_0(&children[0], &children[1], &children[2]),
            600 => self.inst_declaration_opt2_0(&children[0]),
            601 => self.inst_declaration_opt2_1(),
            602 => self.inst_declaration_opt1_1(),
            603 => self.inst_declaration_opt0_0(&children[0]),
            604 => self.inst_declaration_opt0_1(),
            605 => self.inst_declaration_opt_0(&children[0]),
            606 => self.inst_declaration_opt_1(),
            607 => self.inst_parameter(&children[0], &children[1], &children[2], &children[3]),
            608 => self.inst_parameter_opt_0(&children[0]),
            609 => self.inst_parameter_opt_1(),
            610 => self.inst_parameter_list(&children[0], &children[1], &children[2]),
            611 => self.inst_parameter_list_list_0(&children[0], &children[1], &children[2]),
            612 => self.inst_parameter_list_list_1(),
            613 => self.inst_parameter_list_opt_0(&children[0]),
            614 => self.inst_parameter_list_opt_1(),
            615 => self.inst_parameter_group(&children[0], &children[1]),
            616 => self.inst_parameter_group_group_0(&children[0], &children[1], &children[2]),
            617 => self.inst_parameter_group_group_1(&children[0]),
            618 => self.inst_parameter_group_list_0(&children[0], &children[1]),
            619 => self.inst_parameter_group_list_1(),
            620 => self.inst_parameter_item(&children[0], &children[1]),
            621 => self.inst_parameter_item_opt_0(&children[0], &children[1]),
            622 => self.inst_parameter_item_opt_1(),
            623 => self.inst_port_list(&children[0], &children[1], &children[2]),
            624 => self.inst_port_list_list_0(&children[0], &children[1], &children[2]),
            625 => self.inst_port_list_list_1(),
            626 => self.inst_port_list_opt_0(&children[0]),
            627 => self.inst_port_list_opt_1(),
            628 => self.inst_port_group(&children[0], &children[1]),
            629 => self.inst_port_group_group_0(&children[0], &children[1], &children[2]),
            630 => self.inst_port_group_group_1(&children[0]),
            631 => self.inst_port_group_list_0(&children[0], &children[1]),
            632 => self.inst_port_group_list_1(),
            633 => self.inst_port_item(&children[0], &children[1]),
            634 => self.inst_port_item_opt_0(&children[0], &children[1]),
            635 => self.inst_port_item_opt_1(),
            636 => self.with_parameter(&children[0], &children[1], &children[2], &children[3]),
            637 => self.with_parameter_opt_0(&children[0]),
            638 => self.with_parameter_opt_1(),
            639 => self.with_parameter_list(&children[0], &children[1], &children[2]),
            640 => self.with_parameter_list_list_0(&children[0], &children[1], &children[2]),
            641 => self.with_parameter_list_list_1(),
            642 => self.with_parameter_list_opt_0(&children[0]),
            643 => self.with_parameter_list_opt_1(),
            644 => self.with_parameter_group(&children[0], &children[1]),
            645 => self.with_parameter_group_group_0(&children[0], &children[1], &children[2]),
            646 => self.with_parameter_group_group_1(&children[0]),
            647 => self.with_parameter_group_list_0(&children[0], &children[1]),
            648 => self.with_parameter_group_list_1(),
            649 => self.with_parameter_item(&children[0], &children[1], &children[2], &children[3]),
            650 => self.with_parameter_item_group0_0(&children[0], &children[1], &children[2]),
            651 => self.with_parameter_item_group0_1(&children[0], &children[1], &children[2]),
            652 => self.with_parameter_item_group_0(&children[0]),
            653 => self.with_parameter_item_group_1(&children[0]),
            654 => self.port_declaration(&children[0], &children[1], &children[2]),
            655 => self.port_declaration_opt_0(&children[0]),
            656 => self.port_declaration_opt_1(),
            657 => self.port_declaration_list(&children[0], &children[1], &children[2]),
            658 => self.port_declaration_list_list_0(&children[0], &children[1], &children[2]),
            659 => self.port_declaration_list_list_1(),
            660 => self.port_declaration_list_opt_0(&children[0]),
            661 => self.port_declaration_list_opt_1(),
            662 => self.port_declaration_group(&children[0], &children[1]),
            663 => self.port_declaration_group_group_0(&children[0], &children[1], &children[2]),
            664 => self.port_declaration_group_group_1(&children[0]),
            665 => self.port_declaration_group_list_0(&children[0], &children[1]),
            666 => self.port_declaration_group_list_1(),
            667 => self.port_declaration_item(&children[0], &children[1], &children[2]),
            668 => self.port_declaration_item_group_0(&children[0], &children[1]),
            669 => self.port_declaration_item_group_1(&children[0], &children[1]),
            670 => self.port_declaration_item_opt_0(&children[0]),
            671 => self.port_declaration_item_opt_1(),
            672 => self.direction_0(&children[0]),
            673 => self.direction_1(&children[0]),
            674 => self.direction_2(&children[0]),
            675 => self.direction_3(&children[0]),
            676 => self.direction_4(&children[0]),
            677 => self.function_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                &children[7],
                &children[8],
            ),
            678 => self.function_declaration_list_0(&children[0], &children[1]),
            679 => self.function_declaration_list_1(),
            680 => self.function_declaration_opt0_0(&children[0]),
            681 => self.function_declaration_opt0_1(),
            682 => self.function_declaration_opt_0(&children[0]),
            683 => self.function_declaration_opt_1(),
            684 => self.function_item_0(&children[0]),
            685 => self.function_item_1(&children[0]),
            686 => self.import_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            687 => self.import_declaration_group_0(&children[0]),
            688 => self.import_declaration_group_1(&children[0]),
            689 => self.export_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            690 => self.export_declaration_group0_0(&children[0]),
            691 => self.export_declaration_group0_1(&children[0]),
            692 => self.export_declaration_group_0(&children[0]),
            693 => self.export_declaration_group_1(&children[0]),
            694 => self.module_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
            ),
            695 => self.module_declaration_list_0(&children[0], &children[1]),
            696 => self.module_declaration_list_1(),
            697 => self.module_declaration_opt0_0(&children[0]),
            698 => self.module_declaration_opt0_1(),
            699 => self.module_declaration_opt_0(&children[0]),
            700 => self.module_declaration_opt_1(),
            701 => self.module_if_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            702 => self.module_if_declaration_list_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            703 => self.module_if_declaration_list_1(),
            704 => self.module_if_declaration_opt_0(&children[0], &children[1]),
            705 => self.module_if_declaration_opt_1(),
            706 => self.module_for_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
            ),
            707 => self.module_for_declaration_opt_0(&children[0], &children[1], &children[2]),
            708 => self.module_for_declaration_opt_1(),
            709 => self.module_named_block(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            710 => self.module_named_block_list_0(&children[0], &children[1]),
            711 => self.module_named_block_list_1(),
            712 => self.module_optional_named_block(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
            ),
            713 => self.module_optional_named_block_list_0(&children[0], &children[1]),
            714 => self.module_optional_named_block_list_1(),
            715 => self.module_optional_named_block_opt_0(&children[0], &children[1]),
            716 => self.module_optional_named_block_opt_1(),
            717 => self.module_group(&children[0], &children[1]),
            718 => self.module_group_group_0(&children[0], &children[1], &children[2]),
            719 => self.module_group_group_list_0(&children[0], &children[1]),
            720 => self.module_group_group_list_1(),
            721 => self.module_group_group_1(&children[0]),
            722 => self.module_group_list_0(&children[0], &children[1]),
            723 => self.module_group_list_1(),
            724 => self.module_item_0(&children[0]),
            725 => self.module_item_1(&children[0]),
            726 => self.module_item_2(&children[0]),
            727 => self.module_item_3(&children[0]),
            728 => self.module_item_4(&children[0]),
            729 => self.module_item_5(&children[0]),
            730 => self.module_item_6(&children[0]),
            731 => self.module_item_7(&children[0]),
            732 => self.module_item_8(&children[0]),
            733 => self.module_item_9(&children[0]),
            734 => self.module_item_10(&children[0]),
            735 => self.module_item_11(&children[0]),
            736 => self.module_item_12(&children[0]),
            737 => self.module_item_13(&children[0]),
            738 => self.module_item_14(&children[0]),
            739 => self.interface_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
            ),
            740 => self.interface_declaration_list_0(&children[0], &children[1]),
            741 => self.interface_declaration_list_1(),
            742 => self.interface_declaration_opt_0(&children[0]),
            743 => self.interface_declaration_opt_1(),
            744 => self.interface_if_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            745 => self.interface_if_declaration_list_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            746 => self.interface_if_declaration_list_1(),
            747 => self.interface_if_declaration_opt_0(&children[0], &children[1]),
            748 => self.interface_if_declaration_opt_1(),
            749 => self.interface_for_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
            ),
            750 => self.interface_for_declaration_opt_0(&children[0], &children[1], &children[2]),
            751 => self.interface_for_declaration_opt_1(),
            752 => self.interface_named_block(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            753 => self.interface_named_block_list_0(&children[0], &children[1]),
            754 => self.interface_named_block_list_1(),
            755 => self.interface_optional_named_block(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
            ),
            756 => self.interface_optional_named_block_list_0(&children[0], &children[1]),
            757 => self.interface_optional_named_block_list_1(),
            758 => self.interface_optional_named_block_opt_0(&children[0], &children[1]),
            759 => self.interface_optional_named_block_opt_1(),
            760 => self.interface_group(&children[0], &children[1]),
            761 => self.interface_group_group_0(&children[0], &children[1], &children[2]),
            762 => self.interface_group_group_list_0(&children[0], &children[1]),
            763 => self.interface_group_group_list_1(),
            764 => self.interface_group_group_1(&children[0]),
            765 => self.interface_group_list_0(&children[0], &children[1]),
            766 => self.interface_group_list_1(),
            767 => self.interface_item_0(&children[0]),
            768 => self.interface_item_1(&children[0]),
            769 => self.interface_item_2(&children[0]),
            770 => self.interface_item_3(&children[0]),
            771 => self.interface_item_4(&children[0]),
            772 => self.interface_item_5(&children[0]),
            773 => self.interface_item_6(&children[0]),
            774 => self.interface_item_7(&children[0]),
            775 => self.interface_item_8(&children[0]),
            776 => self.interface_item_9(&children[0]),
            777 => self.interface_item_10(&children[0]),
            778 => self.interface_item_11(&children[0]),
            779 => self.package_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            780 => self.package_declaration_list_0(&children[0], &children[1]),
            781 => self.package_declaration_list_1(),
            782 => self.package_group(&children[0], &children[1]),
            783 => self.package_group_group_0(&children[0], &children[1], &children[2]),
            784 => self.package_group_group_list_0(&children[0], &children[1]),
            785 => self.package_group_group_list_1(),
            786 => self.package_group_group_1(&children[0]),
            787 => self.package_group_list_0(&children[0], &children[1]),
            788 => self.package_group_list_1(),
            789 => self.package_item_0(&children[0]),
            790 => self.package_item_1(&children[0]),
            791 => self.package_item_2(&children[0]),
            792 => self.package_item_3(&children[0]),
            793 => self.package_item_4(&children[0]),
            794 => self.package_item_5(&children[0]),
            795 => self.package_item_6(&children[0]),
            796 => self.package_item_7(&children[0]),
            797 => self.package_item_8(&children[0]),
            798 => self.description_group(&children[0], &children[1]),
            799 => self.description_group_group_0(&children[0], &children[1], &children[2]),
            800 => self.description_group_group_list_0(&children[0], &children[1]),
            801 => self.description_group_group_list_1(),
            802 => self.description_group_group_1(&children[0]),
            803 => self.description_group_list_0(&children[0], &children[1]),
            804 => self.description_group_list_1(),
            805 => self.description_item_0(&children[0]),
            806 => self.description_item_1(&children[0]),
            807 => self.description_item_2(&children[0]),
            808 => self.description_item_3(&children[0]),
            809 => self.veryl(&children[0], &children[1]),
            810 => self.veryl_list_0(&children[0], &children[1]),
            811 => self.veryl_list_1(),
            _ => Err(ParserError::InternalError(format!(
                "Unhandled production number: {}",
                prod_num
            ))
            .into()),
        }
    }
}
